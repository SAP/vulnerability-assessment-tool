package com.sap.psr.vulas.kb.task;

import java.io.File;
import java.io.FileFilter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.ConcurrentModificationException;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import org.apache.commons.lang.StringUtils;
import org.apache.logging.log4j.Logger;
import com.google.gson.JsonSyntaxException;
import com.sap.psr.vulas.ConstructChange;
import com.sap.psr.vulas.backend.BackendConnectionException;
import com.sap.psr.vulas.backend.BackendConnector;
import com.sap.psr.vulas.core.util.CoreConfiguration;
import com.sap.psr.vulas.kb.model.Commit;
import com.sap.psr.vulas.kb.model.Note;
import com.sap.psr.vulas.kb.model.Vulnerability;
import com.sap.psr.vulas.kb.util.ConstructSet;
import com.sap.psr.vulas.kb.util.Metadata;
import com.sap.psr.vulas.shared.enums.BugOrigin;
import com.sap.psr.vulas.shared.enums.ContentMaturityLevel;
import com.sap.psr.vulas.shared.json.JsonBuilder;
import com.sap.psr.vulas.shared.util.VulasConfiguration;

public class ImportVulnerability {
  private Vulnerability vuln;
  private HashMap<String, Object> args;
  private static final String UPLOAD_CONSTRUCT_OPTION = "u";
  private static final String OVERWRITE_OPTION = "o";
  private static final String DIRECTORY_OPTION = "d";
  private static final String VERBOSE_OPTION = "v";
  private static final String VERBOSE_LONG_OPTION = "verbose";

  private static final Logger log = org.apache.logging.log4j.LogManager.getLogger();

  public ImportVulnerability(Vulnerability vuln, HashMap<String, Object> args) {
    this.vuln = vuln;
    this.args = args;
  }

  public void execute() throws BackendConnectionException, JsonSyntaxException, IOException {
    String vulnId = vuln.getVulnId();

    // Whether to upload JSON to the backend or save to the disk
    VulasConfiguration.getGlobal()
        .setProperty(
            CoreConfiguration.BACKEND_CONNECT,
            ((Boolean) args.get(UPLOAD_CONSTRUCT_OPTION)
                ? CoreConfiguration.ConnectType.READ_WRITE.toString()
                : CoreConfiguration.ConnectType.READ_ONLY.toString()));

    Boolean overwrite = (Boolean) args.get(OVERWRITE_OPTION);
    if (!overwrite && BackendConnector.getInstance().isBugExisting(vulnId)) {
      log.info("Bug [{}] already exists in backend, analysis will be skipped", vulnId);
      return;
    }

    List<Commit> commits = new ArrayList<Commit>();
    File file = new File((String) args.get(DIRECTORY_OPTION));

    File commitDirs[] =
        file.listFiles(
            new FileFilter() {
              @Override
              public boolean accept(File file) {
                return file.isDirectory();
              }
            });

    for (File commitDir : commitDirs) {
      String dir = commitDir.getAbsolutePath();
      Commit commit = null;
      commit = Metadata.getCommitMetadata(dir);

      if (commit != null) {
        commits.add(commit);
      }
    }

    Set<ConstructChange> changes = null;
    Map<String, Set<ConstructChange>> allChanges = new HashMap<String, Set<ConstructChange>>();
    for (Commit commit : commits) {
      changes = ConstructSet.identifyConstructChanges(commit, allChanges);
      if ((Boolean) args.get(VERBOSE_OPTION) || (Boolean) args.get(VERBOSE_LONG_OPTION)) {
        for (ConstructChange chg : changes) {
          log.info(chg.toString());
        }
      }
    }

    final String json = toJSON(vuln, commits, allChanges);

    BackendConnector.getInstance().uploadChangeList(vulnId, json);
  }

  /**
   * <p>
   * toJSON.
   * </p>
   *
   * @param _vulnerability a {@link com.sap.psr.vulas.kb.model.Vulnerability} object.
   * @param _commits {@link java.util.List}.
   * @param _allChanges a {@link java.util.Map}.
   * @return a {@link java.lang.String} object.
   */
  private String toJSON(
      Vulnerability _vulnerability,
      List<Commit> _commits,
      Map<String, Set<ConstructChange>> _allChanges)
      throws ConcurrentModificationException {
    final StringBuilder b = new StringBuilder();
    b.append(" { ");
    b.append(" \"bugId\" : \"").append(_vulnerability.getVulnId()).append("\", ");

    /* TODO: How do we handle mutiple alternate Bug Ids */
    List<String> aliases = _vulnerability.getAliases();
    if (aliases != null && !aliases.isEmpty()) {
      b.append(" \"bugIdAlt\" : \"");
      for (String aliase : aliases) {
        b.append(aliase).append(",");
      }
      b.append("\", ");
    }

    b.append(" \"maturity\" : \"" + ContentMaturityLevel.DRAFT.toString() + "\", ");
    b.append(" \"origin\" : \"" + BugOrigin.PUBLIC.toString() + "\", ");

    List<Note> notes = _vulnerability.getNotes();

    /* TODO: Handle multiple descriptions */
    if (notes != null && !notes.isEmpty() && StringUtils.isNotBlank(notes.get(0).getText())) {
      b.append(" \"descriptionAlt\" : ")
          .append(JsonBuilder.escape(notes.get(0).getText()))
          .append(",");
    }

    /* TODO: Should we merge all the links */
    Set<String> links = new HashSet<>();
    if (notes != null) {
      for (Note note : notes) {
        List<String> noteLinks = note.getLinks();
        if (noteLinks != null) links.addAll(noteLinks);
      }
    }

    if (links != null) {
      int i = 0;
      b.append(" \"reference\" : [");
      for (String link : links) {
        if (i != 0) {
          b.append(", ");
        } else i++;
        b.append(JsonBuilder.escape(link));
      }

      b.append("], ");
    }

    b.append(" \"constructChanges\" : [ ");
    int i = 0;
    final Set<ConstructChange> consol_ch =
        ConstructSet.getConsolidatedChanges(_commits, _allChanges);
    for (ConstructChange c : consol_ch) {
      b.append(c.toJSON());
      if (++i < consol_ch.size()) b.append(", ");
    }
    b.append(" ] } ");
    return b.toString();
  }
}
