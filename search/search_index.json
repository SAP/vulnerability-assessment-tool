{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Eclipse Steady \u00b6 General What is Eclipse Steady? Users Quickstart Frequently Asked Questions/Troubleshooting User Manual Get support Admins Operating your own Eclipse Steady servers Vulnerabilities Learn about Eclipse Steady's vulnerability database","title":"Home"},{"location":"#eclipse-steady","text":"General What is Eclipse Steady? Users Quickstart Frequently Asked Questions/Troubleshooting User Manual Get support Admins Operating your own Eclipse Steady servers Vulnerabilities Learn about Eclipse Steady's vulnerability database","title":"Eclipse Steady"},{"location":"about/","text":"About \u00b6 Eclipse Steady analyzes Java and Python applications in order to: detect whether they depend on open-source components with known vulnerabilities, collect evidence of the execution of vulnerable code in a given application context (through a novel combination of static and dynamic analysis), and support developers in the mitigation of such vulnerable dependencies. Eclipse Steady addresses the OWASP Top 10 security risk A9, Using Components with Known Vulnerabilities . Differently from other tools that have similar goals, the detection approach of Eclipse Steady is code-centric and usage-based , which allows for a more accurate detection and assessment than tools relying on meta-data. Eclipse Steady is implemented as a collection of client-side tools (for Java and Python), server-side RESTful services and several Web frontends. Initially developed by SAP Security Research , Eclipse Steady was adopted internally by SAP as early as 2015. The tool has been open-sourced in October 2018 under the Apache License v.2.0. The approach implemented in Eclipse Steady is described in detail in the the following scientific papers: Serena Ponta, Henrik Plate, Antonino Sabetta, Beyond Metadata: Code-centric and Usage-based Analysis of Known Vulnerabilities in Open-source Software , 34 th International Conference on Software Maintenance and Evolution (ICSME), 2018 (recipient of the IEEE TCSE Distinguished Paper Award) Henrik Plate, Serena Ponta, Antonino Sabetta, Impact Assessment for Vulnerabilities in Open-Source Software Libraries , 31 st International Conference on Software Maintenance and Evolution (ICSME), 2015 Contributors \u00b6 Henrik Plate (SAP Security Research) Serena E. Ponta (SAP Security Research) Antonino Sabetta (SAP Security Research) C\u00e9dric Dangremont (SAP Security Testing and Validation) Sumeet Patil (SAP Security Testing and Validation) Alessandro Pezz\u00e9 Hoang Quoc Trung","title":"About"},{"location":"about/#about","text":"Eclipse Steady analyzes Java and Python applications in order to: detect whether they depend on open-source components with known vulnerabilities, collect evidence of the execution of vulnerable code in a given application context (through a novel combination of static and dynamic analysis), and support developers in the mitigation of such vulnerable dependencies. Eclipse Steady addresses the OWASP Top 10 security risk A9, Using Components with Known Vulnerabilities . Differently from other tools that have similar goals, the detection approach of Eclipse Steady is code-centric and usage-based , which allows for a more accurate detection and assessment than tools relying on meta-data. Eclipse Steady is implemented as a collection of client-side tools (for Java and Python), server-side RESTful services and several Web frontends. Initially developed by SAP Security Research , Eclipse Steady was adopted internally by SAP as early as 2015. The tool has been open-sourced in October 2018 under the Apache License v.2.0. The approach implemented in Eclipse Steady is described in detail in the the following scientific papers: Serena Ponta, Henrik Plate, Antonino Sabetta, Beyond Metadata: Code-centric and Usage-based Analysis of Known Vulnerabilities in Open-source Software , 34 th International Conference on Software Maintenance and Evolution (ICSME), 2018 (recipient of the IEEE TCSE Distinguished Paper Award) Henrik Plate, Serena Ponta, Antonino Sabetta, Impact Assessment for Vulnerabilities in Open-Source Software Libraries , 31 st International Conference on Software Maintenance and Evolution (ICSME), 2015","title":"About"},{"location":"about/#contributors","text":"Henrik Plate (SAP Security Research) Serena E. Ponta (SAP Security Research) Antonino Sabetta (SAP Security Research) C\u00e9dric Dangremont (SAP Security Testing and Validation) Sumeet Patil (SAP Security Testing and Validation) Alessandro Pezz\u00e9 Hoang Quoc Trung","title":"Contributors"},{"location":"admin/","text":"DevOps \u00b6 Eclipse Steady is meant to run within the internal network of software development organizations, and this tutorial is meant to facilitate the operation of Eclipse Steady using local Docker repositories. Important : Because Eclipse Steady does not currently implement authorization functionality, it is not advised to expose an instance of Eclipse Steady to the public Internet. Deploy on Docker Build JAVA archives and local Docker images Push Docker images to a registry","title":"DevOps"},{"location":"admin/#devops","text":"Eclipse Steady is meant to run within the internal network of software development organizations, and this tutorial is meant to facilitate the operation of Eclipse Steady using local Docker repositories. Important : Because Eclipse Steady does not currently implement authorization functionality, it is not advised to expose an instance of Eclipse Steady to the public Internet. Deploy on Docker Build JAVA archives and local Docker images Push Docker images to a registry","title":"DevOps"},{"location":"admin/manuals/","text":"","title":"Home"},{"location":"admin/support/faq/","text":"","title":"Faq"},{"location":"admin/support/getting_help/","text":"","title":"Getting help"},{"location":"admin/tutorials/build/","text":"Building Docker images from source \u00b6 Pre-requisites \u00b6 git docker docker-compose Customization \u00b6 All the following commands are supposed to be executed from the root folder of the project. If you want to build images specific to a version you can checkout a stable version of Steady. Usually the master branch holds a -SNAPSHOT version. git checkout tags/3.2.2 Make a copy of the sample configuration: cp docker/.env.sample docker/.env Customize the file docker/.env to match your needs, make sure you set the version you want to build in VULAS_RELEASE. In docker/.env you must configure at least POSTGRES_USER= , you should also configure the HAPROXY 's user and password as well as the credentials to access the bugs' frontend Generate JAVA archives \u00b6 At this point, you are ready to build the JAR/WAR artifacts with the following command: docker build --tag steady-generator:3.2.2 -f docker/Dockerfile . docker run -it --rm -v ${ PWD } /docker:/exporter --env-file ./docker/.env -e mvn_flags = -DskipTests steady-generator:3.2.2 If the command above fails, add -DreuseForks=False flag to mvn_flags . As shown in the example below. docker run -it --rm -v ${ PWD } /docker:/exporter --env-file ./docker/.env -e mvn_flags = '-DskipTests -DreuseForks=False' steady-generator:3.2.2 In case you are running behind a proxy you need to configure it in the --build-arg arguments. Check the predefined ARG s documentation to know more. As a result, the folders docker/<component-name> will contain compiled JARs (or WARs, depending on the component). The folder docker/client-tools will be populated with the JARs for client side tools (CLI, plugins, patchanalyzer). Additionally, you may want to make the artifacts available to the developers of your organization (e.g., through an internal Nexus or other artifact distribution system). Generate Docker images \u00b6 You are now ready to run the system with the generated archives and create the Docker images: ( cd docker && docker-compose -f docker-compose.build.yml build ) You can create and run containers from the generated images. ( cd docker && docker-compose -f docker-compose.yml -f docker-compose.build.yml up -d ) To check everything started successfully, browse the page http://localhost:8033/haproxy?stats . All endpoints should appear as green. username and password can be found in your .env file, be also advised that rest-backend could take more than 30 seconds to be ready to answer HTTP requests Get going: Push the images you have built to a private Docker registry Deploy Eclipse Steady locally with Docker","title":"Build JAVA archives/Docker images"},{"location":"admin/tutorials/build/#building-docker-images-from-source","text":"","title":"Building Docker images from source"},{"location":"admin/tutorials/build/#pre-requisites","text":"git docker docker-compose","title":"Pre-requisites"},{"location":"admin/tutorials/build/#customization","text":"All the following commands are supposed to be executed from the root folder of the project. If you want to build images specific to a version you can checkout a stable version of Steady. Usually the master branch holds a -SNAPSHOT version. git checkout tags/3.2.2 Make a copy of the sample configuration: cp docker/.env.sample docker/.env Customize the file docker/.env to match your needs, make sure you set the version you want to build in VULAS_RELEASE. In docker/.env you must configure at least POSTGRES_USER= , you should also configure the HAPROXY 's user and password as well as the credentials to access the bugs' frontend","title":"Customization"},{"location":"admin/tutorials/build/#generate-java-archives","text":"At this point, you are ready to build the JAR/WAR artifacts with the following command: docker build --tag steady-generator:3.2.2 -f docker/Dockerfile . docker run -it --rm -v ${ PWD } /docker:/exporter --env-file ./docker/.env -e mvn_flags = -DskipTests steady-generator:3.2.2 If the command above fails, add -DreuseForks=False flag to mvn_flags . As shown in the example below. docker run -it --rm -v ${ PWD } /docker:/exporter --env-file ./docker/.env -e mvn_flags = '-DskipTests -DreuseForks=False' steady-generator:3.2.2 In case you are running behind a proxy you need to configure it in the --build-arg arguments. Check the predefined ARG s documentation to know more. As a result, the folders docker/<component-name> will contain compiled JARs (or WARs, depending on the component). The folder docker/client-tools will be populated with the JARs for client side tools (CLI, plugins, patchanalyzer). Additionally, you may want to make the artifacts available to the developers of your organization (e.g., through an internal Nexus or other artifact distribution system).","title":"Generate JAVA archives"},{"location":"admin/tutorials/build/#generate-docker-images","text":"You are now ready to run the system with the generated archives and create the Docker images: ( cd docker && docker-compose -f docker-compose.build.yml build ) You can create and run containers from the generated images. ( cd docker && docker-compose -f docker-compose.yml -f docker-compose.build.yml up -d ) To check everything started successfully, browse the page http://localhost:8033/haproxy?stats . All endpoints should appear as green. username and password can be found in your .env file, be also advised that rest-backend could take more than 30 seconds to be ready to answer HTTP requests Get going: Push the images you have built to a private Docker registry Deploy Eclipse Steady locally with Docker","title":"Generate Docker images"},{"location":"admin/tutorials/docker/","text":"Deploy on Docker \u00b6 In this tutorial you will be guided through the necessary steps to set-up the Eclipse Steady backend services. Important Remark The setup obtained following these instructions is meant for demonstration purposes. It shall not be used in productive scenarios (both for security and scalability concerns). Pre-requisites \u00b6 git docker docker-compose Installation \u00b6 Setup \u00b6 Clone locally the Steady repository git clone https://github.com/eclipse/steady.git Customize the file docker/.env to match your needs, make sure you set the version you want to run in VULAS_RELEASE. cp docker/.env.sample docker/.env In docker/.env you must configure at least POSTGRES_USER= , you should also configure the HAPROXY 's user and password as well as the credentials to access the bugs' frontend Run \u00b6 You are now ready to run the system: ( cd docker && docker-compose up -d --build ) To check if everything started successfully, check the page http://localhost:8033/haproxy?stats . All endpoints should appear as green (you may want to replace localhost with the actual hostname of your machine). Credentials and start up time username and password can be found in your .env file, be also advised that rest-backend could take more than 30 seconds to be available to answer HTTP requests Populate/maintain the vulnerability database \u00b6 Vulnerabilities data are automatically fetched and imported from project KB , so there is nothing to do for you (except wait for the vulnerability data to be processed, which can take as long as 2h). After the initial import, vulnerability data is updated daily. The following configurations are available in docker/.env : you can configure KB_IMPORTER_CRON_HOUR= to set the time of the day when the update will run (midnight by default). To fetch vulnerability data from another source, you can change the configuration of KB_IMPORTER_REPO=https://github.com/sap/project-kb and KB_IMPORTER_STATEMENTS_BRANCH=vulnerability-data in docker/.env . KB_IMPORTER_STATEMENTS_REPO = https://github.com/sap/project-kb # repository used to fetch vulnerability data KB_IMPORTER_STATEMENTS_BRANCH = vulnerability-data # brach used to fetch vulnerability data KB_IMPORTER_SKIP_CLONE = True # Restrict the import to vulnerabilities whose commit changes are already available in the configured repository KB_IMPORTER_STATEMENTS_FOLDER = statements # Destination folder of the vulnerabilites fetched KB_IMPORTER_CLONE_FOLDER = repo-clones # Folder where repositories hosting fix-commits are closed See here how to list the vulnerabilities already imported. If you want to customize your system to fetch vulnerability data differently (e.g., from multiple sources), please follow the documentation here . Get going: Setup your workspace (if you don't have one) Become familiar with the various analysis goals (first time users) Analyze your Java or Python application (on a regular basis) Assess findings using the apps Web frontend (following every analysis) Further links: Configure the client-side analysis Automate with Jenkins Get help if you run into troubles","title":"Deploy on Docker"},{"location":"admin/tutorials/docker/#deploy-on-docker","text":"In this tutorial you will be guided through the necessary steps to set-up the Eclipse Steady backend services. Important Remark The setup obtained following these instructions is meant for demonstration purposes. It shall not be used in productive scenarios (both for security and scalability concerns).","title":"Deploy on Docker"},{"location":"admin/tutorials/docker/#pre-requisites","text":"git docker docker-compose","title":"Pre-requisites"},{"location":"admin/tutorials/docker/#installation","text":"","title":"Installation"},{"location":"admin/tutorials/docker/#setup","text":"Clone locally the Steady repository git clone https://github.com/eclipse/steady.git Customize the file docker/.env to match your needs, make sure you set the version you want to run in VULAS_RELEASE. cp docker/.env.sample docker/.env In docker/.env you must configure at least POSTGRES_USER= , you should also configure the HAPROXY 's user and password as well as the credentials to access the bugs' frontend","title":"Setup"},{"location":"admin/tutorials/docker/#run","text":"You are now ready to run the system: ( cd docker && docker-compose up -d --build ) To check if everything started successfully, check the page http://localhost:8033/haproxy?stats . All endpoints should appear as green (you may want to replace localhost with the actual hostname of your machine). Credentials and start up time username and password can be found in your .env file, be also advised that rest-backend could take more than 30 seconds to be available to answer HTTP requests","title":"Run"},{"location":"admin/tutorials/docker/#populatemaintain-the-vulnerability-database","text":"Vulnerabilities data are automatically fetched and imported from project KB , so there is nothing to do for you (except wait for the vulnerability data to be processed, which can take as long as 2h). After the initial import, vulnerability data is updated daily. The following configurations are available in docker/.env : you can configure KB_IMPORTER_CRON_HOUR= to set the time of the day when the update will run (midnight by default). To fetch vulnerability data from another source, you can change the configuration of KB_IMPORTER_REPO=https://github.com/sap/project-kb and KB_IMPORTER_STATEMENTS_BRANCH=vulnerability-data in docker/.env . KB_IMPORTER_STATEMENTS_REPO = https://github.com/sap/project-kb # repository used to fetch vulnerability data KB_IMPORTER_STATEMENTS_BRANCH = vulnerability-data # brach used to fetch vulnerability data KB_IMPORTER_SKIP_CLONE = True # Restrict the import to vulnerabilities whose commit changes are already available in the configured repository KB_IMPORTER_STATEMENTS_FOLDER = statements # Destination folder of the vulnerabilites fetched KB_IMPORTER_CLONE_FOLDER = repo-clones # Folder where repositories hosting fix-commits are closed See here how to list the vulnerabilities already imported. If you want to customize your system to fetch vulnerability data differently (e.g., from multiple sources), please follow the documentation here . Get going: Setup your workspace (if you don't have one) Become familiar with the various analysis goals (first time users) Analyze your Java or Python application (on a regular basis) Assess findings using the apps Web frontend (following every analysis) Further links: Configure the client-side analysis Automate with Jenkins Get help if you run into troubles","title":"Populate/maintain the vulnerability database"},{"location":"admin/tutorials/helm/","text":"Deploy on Kubernetes with Helm \u00b6 In this tutorial you will be guided through the necessary steps to set-up the Eclipse Steady services in a Kubernetes cluster using Helm version 3.0.0-beta4 and is compatible with any helm2 version 2.15.0 . Helm2 and Helm3 Helm2 has officially gone into maintenance mode (no further release after 2.15.0) but this chart is meant to be compatible with both major versions of Helm. The main difference being that in helm 3 tiller is no longer required and all charts are namespaced. Pre-requisites \u00b6 git Helm Kubernetes >=v1.15.0 with Beta APIs enabled Setup \u00b6 This repository contains three charts: vulnerability-assessment-tool-core : which encapsulates all the core components of the tool vulnerability-assessment-tool-admin : which encapsulates all the cluster admin tools (namely the ingress controller to expose the service) vulnerability-assessment-tool-monitoring : which is used to deploy the dedicated monitoring stack Clone locally Eclipse Steady repository and change the directory to the Helm chart's folder git clone https://github.com/eclipse/steady.git cd steady/kubernetes/helm Modify the values.yaml files and edit them to match your needs. In order to verify the validity of your values and get a preview of your generated chart: helm template vulnerability-assessment-tool-core helm template vulnerability-assessment-tool-admin helm template vulnerability-assessment-tool-monitoring Run \u00b6 You are now ready to deploy Eclipse Steady inside your Kubernetes cluster: Vulnerability-assessment-tool-core chart \u00b6 # For helm 2 helm install vulnerability-assessment-tool-core/ --name ReleaseName # For helm 3 helm install vulnerability-assessment-tool-core ReleaseName The above command will create a Namespace called vulnerability-assessment-tool-core (which can be specified in the vulnerability-assessment-tool-core/values.yaml ) and install all the component on it. To check if everything is starting successfully you can watch the deployments by running the command kubectl get pods -n vulnerability-assessment-tool-core . The deployment will request a couple PersistentVolumeClaims which could need some time to be created depending on the cloud provider you are running on. Vulnerability-assessment-tool-monitoring chart \u00b6 # For helm 2 helm install vulnerability-assessment-tool-monitoring/ --name ReleaseName # For helm 3 helm install vulnerability-assessment-tool-monitoring ReleaseName The above command will create a Namespace called vulnerability-assessment-tool-monitoring (which can be specified in the vulnerability-assessment-tool-monitoring/values.yaml ) and install all the component on it. To check if everything is starting successfully you can watch the deployments by running the command kubectl get pods -n vulnerability-assessment-tool-monitoring . The deployment will request a couple PersistentVolumeClaims which could need some time to be created depending on the cloud provider you are running on. Monitoring scope This chart's monitoring is not scoped to any namespace so you can add other pods to be monitored simply by adding prometheus.io/scrape: \"true\" in the correct pod annotation and in which ever namespace you desire. Vulnerability-assessment-tool-admin chart \u00b6 # For helm 2 helm install vulnerability-assessment-tool-admin/ --name ReleaseName # For helm 3 helm install vulnerability-assessment-tool-admin ReleaseName The above command will create a Namespace called vulnerability-assessment-tool-admin (which can be specified in the vulnerability-assessment-tool-admin/values.yaml ) and install all the component on it. To check if everything is starting successfully you can watch the deployments by running the command kubectl get pods -n vulnerability-assessment-tool-admin . The deployment will request a LoadBalancer which could need some time to be created depending on the cloud provider you are running on. Reaching Eclipse Steady from the Internet This chart creates a LoadBalancer to allow Internet traffic to reach the cluster provisioned by your provider and will connect to it. This LoadBalancer will be exposed on the Internet so be careful to change the authentication ingress values from the default ones. The Service type:LoadBalancer should work with most providers such as GKE, Azure. If not, you can follow this ingress-nginx guide","title":"Deploy on Kubernetes with Helm"},{"location":"admin/tutorials/helm/#deploy-on-kubernetes-with-helm","text":"In this tutorial you will be guided through the necessary steps to set-up the Eclipse Steady services in a Kubernetes cluster using Helm version 3.0.0-beta4 and is compatible with any helm2 version 2.15.0 . Helm2 and Helm3 Helm2 has officially gone into maintenance mode (no further release after 2.15.0) but this chart is meant to be compatible with both major versions of Helm. The main difference being that in helm 3 tiller is no longer required and all charts are namespaced.","title":"Deploy on Kubernetes with Helm"},{"location":"admin/tutorials/helm/#pre-requisites","text":"git Helm Kubernetes >=v1.15.0 with Beta APIs enabled","title":"Pre-requisites"},{"location":"admin/tutorials/helm/#setup","text":"This repository contains three charts: vulnerability-assessment-tool-core : which encapsulates all the core components of the tool vulnerability-assessment-tool-admin : which encapsulates all the cluster admin tools (namely the ingress controller to expose the service) vulnerability-assessment-tool-monitoring : which is used to deploy the dedicated monitoring stack Clone locally Eclipse Steady repository and change the directory to the Helm chart's folder git clone https://github.com/eclipse/steady.git cd steady/kubernetes/helm Modify the values.yaml files and edit them to match your needs. In order to verify the validity of your values and get a preview of your generated chart: helm template vulnerability-assessment-tool-core helm template vulnerability-assessment-tool-admin helm template vulnerability-assessment-tool-monitoring","title":"Setup"},{"location":"admin/tutorials/helm/#run","text":"You are now ready to deploy Eclipse Steady inside your Kubernetes cluster:","title":"Run"},{"location":"admin/tutorials/helm/#vulnerability-assessment-tool-core-chart","text":"# For helm 2 helm install vulnerability-assessment-tool-core/ --name ReleaseName # For helm 3 helm install vulnerability-assessment-tool-core ReleaseName The above command will create a Namespace called vulnerability-assessment-tool-core (which can be specified in the vulnerability-assessment-tool-core/values.yaml ) and install all the component on it. To check if everything is starting successfully you can watch the deployments by running the command kubectl get pods -n vulnerability-assessment-tool-core . The deployment will request a couple PersistentVolumeClaims which could need some time to be created depending on the cloud provider you are running on.","title":"Vulnerability-assessment-tool-core chart"},{"location":"admin/tutorials/helm/#vulnerability-assessment-tool-monitoring-chart","text":"# For helm 2 helm install vulnerability-assessment-tool-monitoring/ --name ReleaseName # For helm 3 helm install vulnerability-assessment-tool-monitoring ReleaseName The above command will create a Namespace called vulnerability-assessment-tool-monitoring (which can be specified in the vulnerability-assessment-tool-monitoring/values.yaml ) and install all the component on it. To check if everything is starting successfully you can watch the deployments by running the command kubectl get pods -n vulnerability-assessment-tool-monitoring . The deployment will request a couple PersistentVolumeClaims which could need some time to be created depending on the cloud provider you are running on. Monitoring scope This chart's monitoring is not scoped to any namespace so you can add other pods to be monitored simply by adding prometheus.io/scrape: \"true\" in the correct pod annotation and in which ever namespace you desire.","title":"Vulnerability-assessment-tool-monitoring chart"},{"location":"admin/tutorials/helm/#vulnerability-assessment-tool-admin-chart","text":"# For helm 2 helm install vulnerability-assessment-tool-admin/ --name ReleaseName # For helm 3 helm install vulnerability-assessment-tool-admin ReleaseName The above command will create a Namespace called vulnerability-assessment-tool-admin (which can be specified in the vulnerability-assessment-tool-admin/values.yaml ) and install all the component on it. To check if everything is starting successfully you can watch the deployments by running the command kubectl get pods -n vulnerability-assessment-tool-admin . The deployment will request a LoadBalancer which could need some time to be created depending on the cloud provider you are running on. Reaching Eclipse Steady from the Internet This chart creates a LoadBalancer to allow Internet traffic to reach the cluster provisioned by your provider and will connect to it. This LoadBalancer will be exposed on the Internet so be careful to change the authentication ingress values from the default ones. The Service type:LoadBalancer should work with most providers such as GKE, Azure. If not, you can follow this ingress-nginx guide","title":"Vulnerability-assessment-tool-admin chart"},{"location":"admin/tutorials/kubernetes_resources/","text":"Operational requirements \u00b6 The following document is meant to summarize the Eclipse Steady requirements when it comes to running it on the Kubernetes architecture. This will detail its operational cost for a couple of scenarios: Lightweight : the cluster is instantiated with no prior scan and data, then, the bugs are loaded using the patch-analyzer. This deployment is not destined for high availability or resilience (therefore with less replicas, no auto-scaling) and is optimal for small testing environments with a 6 month usage buffer. Lightweight HA : same as the above but with the sufficient amount of replicas that will ensure high availability and resilience. Medium Load : the cluster is instantiated with no prior scan and data, then, the bugs are loaded using the patch-analyzer. This deployment is not destined for high availability or resilience (therefore with less replicas, no auto-scaling) and is optimal for small production environments with a 2 year buffer. Medium Load HA : same as the above but with the sufficient amount of replicas that will ensure high availability and resilience. Production Load : the cluster is loaded with the latest dump of the internal SAP Eclipse Steady database (which at the time of this document creation is around 249GB). This deployment is not destined for high availability or resilience and is optimal for production environments with a 3-5 year usage buffer. This data load includes app specific data (once those are removed, the database size is around 150GB in our current setup) Production Load HA : same as the above but with the sufficient amount of replicas that will ensure high availability and resilience. Extra PVC : this use case is destined towards optimizing certain components of the Eclipse Steady which require read write many volumes (in particular rest-lib-utils ) Hosted DB : for using a pre-existing database (for cloud providers such as GCP, AWS, Azure, etc...) which require lower resources as the database are no longer self managed. CPU request CPU Limit Memory Request (GiB) Memory Limit (GiB) PV (GiB) Lightweight 8.5 17.1 12.5 25.6 30 Lightweight HA 17.6 35.2 30.5 61.2 90 Lightweight HA (with extra PVC) 17.6 35.2 30.5 61.2 102 Medium Load 16.5 33.1 24.5 49.6 50 Medium Load HA 30.2 60.7 51.7 102.7 150 Medium Load HA (with extra PVC) 30.2 60.7 51.7 102.7 195 Production Load 40.7 57.6 57.2 92.6 400 Production Load HA 107.9 160.2 159.4 262.2 1200 Production Load HA (with extra PVC) 107.9 160.2 159.4 262.2 1380 Lightweight HA (hosted db) 8.7 17.7 16.7 34.2 90 Medium Load HA (hosted db) 16.7 33.7 32.7 66.2 150 Production Load HA (hosted db) 48.9 98.2 97.4 197.2 1200 In-depth break down of resource requirements \u00b6 Frontendapps \u00b6 replicas cpu_limit cpu_request memory_limit(GiB) memory_request(GiB) PV(GiB) lightweight 1 0.1 0.3 0.1 0.3 0 lightweight_ha 2 0.1 0.3 0.1 0.3 0 lightweight_ha_extra_pvc 2 0.1 0.3 0.1 0.3 0 medium_load 1 0.1 0.3 0.1 0.3 0 medium_load_ha 2 0.1 0.3 0.1 0.3 0 medium_load_ha_extra_pvc 2 0.1 0.3 0.1 0.3 0 prod_load 1 0.1 0.3 0.1 0.3 0 prod_load_ha 2 0.1 0.3 0.1 0.3 0 prod_load_ha_extra_pvc 2 0.1 0.3 0.1 0.3 0 lightweight_ha_hosted_db 2 0.1 0.3 0.1 0.3 0 medium_load_ha_hosted_db 2 0.1 0.3 0.1 0.3 0 prod_load_ha_hosted_db 2 0.1 0.3 0.1 0.3 0 Frontendbugs \u00b6 replicas cpu_limit cpu_request memory_limit(GiB) memory_request(GiB) PV(GiB) lightweight 1 0.1 0.3 0.1 0.3 0 lightweight_ha 2 0.1 0.3 0.1 0.3 0 lightweight_ha_extra_pvc 2 0.1 0.3 0.1 0.3 0 medium_load 1 0.1 0.3 0.1 0.3 0 medium_load_ha 2 0.1 0.3 0.1 0.3 0 medium_load_ha_extra_pvc 2 0.1 0.3 0.1 0.3 0 prod_load 1 0.1 0.3 0.1 0.3 0 prod_load_ha 2 0.1 0.3 0.1 0.3 0 prod_load_ha_extra_pvc 2 0.1 0.3 0.1 0.3 0 lightweight_ha_hosted_db 2 0.1 0.3 0.1 0.3 0 medium_load_ha_hosted_db 2 0.1 0.3 0.1 0.3 0 prod_load_ha_hosted_db 2 0.1 0.3 0.1 0.3 0 Patch-lib-analyzer \u00b6 replicas cpu_limit cpu_request memory_limit(GiB) memory_request(GiB) PV(GiB) lightweight 1 0.3 0.5 0.3 1 0 lightweight_ha 2 0.3 0.5 0.3 1 0 lightweight_ha_extra_pvc 2 0.3 0.5 0.3 1 2 medium_load 1 0.3 0.5 0.3 1 0 medium_load_ha 2 0.3 0.5 0.3 1 0 medium_load_ha_extra_pvc 2 0.3 0.5 0.3 1 5 prod_load 1 0.5 1 1 4 0 prod_load_ha 2 0.5 1 1 4 30 prod_load_ha_extra_pvc 2 0.5 1 1 4 0 lightweight_ha_hosted_db 2 0.3 0.5 0.3 1 0 medium_load_ha_hosted_db 2 0.3 0.5 0.3 1 0 prod_load_ha_hosted_db 2 0.5 1 1 0.3 0 Rest-lib-utils \u00b6 replicas cpu_limit cpu_request memory_limit(GiB) memory_request(GiB) PV(GiB) lightweight 1 2 4 4 8 0 lightweight_ha 2 2 4 4 8 0 lightweight_ha_extra_pvc 2 2 4 4 8 5 medium_load 1 4 8 8 16 0 medium_load_ha 2 4 8 8 16 0 medium_load_ha_extra_pvc 2 4 8 8 16 20 prod_load 1 8 16 16 32 0 prod_load_ha 3 8 16 16 32 0 prod_load_ha_extra_pvc 3 8 16 16 32 50 lightweight_ha_hosted_db 2 2 4 4 8 0 medium_load_ha_hosted_db 2 4 8 8 16 0 prod_load_ha_hosted_db 3 8 16 16 32 0 Rest-backend \u00b6 replicas cpu_limit cpu_request memory_limit(GiB) memory_request(GiB) PV(GiB) lightweight 1 2 4 4 8 0 lightweight_ha 2 2 4 4 8 0 lightweight_ha_extra_pvc 2 2 4 4 8 0 medium_load 1 4 8 8 16 0 medium_load_ha 2 4 8 8 16 0 medium_load_ha_extra_pvc 2 4 8 8 16 0 prod_load 1 8 16 16 32 0 prod_load_ha 3 8 16 16 32 0 prod_load_ha_extra_pvc 3 8 16 16 32 0 lightweight_ha_hosted_db 2 2 4 4 8 0 medium_load_ha_hosted_db 2 4 8 8 16 0 prod_load_ha_hosted_db 3 8 16 16 32 0 Postgres master \u00b6 replicas cpu_limit cpu_request memory_limit(GiB) memory_request(GiB) PV(GiB) lightweight 1 4 8 4 8 30 lightweight_ha 1 4 8 4 8 0 lightweight_ha_extra_pvc 1 4 8 4 8 0 medium_load 1 8 16 8 16 50 medium_load_ha 1 8 16 8 16 50 medium_load_ha_extra_pvc 1 8 16 8 16 50 prod_load 1 24 24 24 24 0 prod_load_ha 1 24 24 24 24 0 prod_load_ha_extra_pvc 1 24 24 24 24 0 lightweight_ha_hosted_db 1 0 0 0 0 30 medium_load_ha_hosted_db 1 0 0 0 0 50 prod_load_ha_hosted_db 1 0 0 0 0 400 Postgres replicas \u00b6 replicas cpu_limit cpu_request memory_limit(GiB) memory_request(GiB) PV(GiB) lightweight 0 0 0 0 0 0 lightweight_ha 2 2 4 4 8 30 lightweight_ha_extra_pvc 2 2 4 4 8 0 medium_load 0 0 0 0 0 0 medium_load_ha 2 2 4 4 8 50 medium_load_ha_extra_pvc 2 2 4 4 8 50 prod_load 0 0 0 0 0 0 prod_load_ha 2 16 16 16 16 400 prod_load_ha_extra_pvc 2 16 16 16 16 400 lightweight_ha_hosted_db 2 0 0 0 0 30 medium_load_ha_hosted_db 2 0 0 0 0 50 prod_load_ha_hosted_db 2 0 0 0 0 400 Pgpool \u00b6 replicas cpu_limit cpu_request memory_limit(GiB) memory_request(GiB) PV(GiB) lightweight 0 0 0 0 0 0 lightweight_ha 3 0.3 0.5 0.6 1 0 lightweight_ha_extra_pvc 3 0.3 0.5 0.6 1 0 medium_load 0 0 0 0 0 0 medium_load_ha 3 0.5 1 1 1.5 0 medium_load_ha_extra_pvc 3 0.5 1 1 1.5 0 prod_load 0 0 0 0 0 0 prod_load_ha 3 1 2 2 3 0 prod_load_ha_extra_pvc 3 1 2 2 3 0 lightweight_ha_hosted_db 0 0 0 0 0 0 medium_load_ha_hosted_db 0 0 0 0 0 0 prod_load_ha_hosted_db 0 0 0 0 0 0","title":"Kubernetes resources requirements"},{"location":"admin/tutorials/kubernetes_resources/#operational-requirements","text":"The following document is meant to summarize the Eclipse Steady requirements when it comes to running it on the Kubernetes architecture. This will detail its operational cost for a couple of scenarios: Lightweight : the cluster is instantiated with no prior scan and data, then, the bugs are loaded using the patch-analyzer. This deployment is not destined for high availability or resilience (therefore with less replicas, no auto-scaling) and is optimal for small testing environments with a 6 month usage buffer. Lightweight HA : same as the above but with the sufficient amount of replicas that will ensure high availability and resilience. Medium Load : the cluster is instantiated with no prior scan and data, then, the bugs are loaded using the patch-analyzer. This deployment is not destined for high availability or resilience (therefore with less replicas, no auto-scaling) and is optimal for small production environments with a 2 year buffer. Medium Load HA : same as the above but with the sufficient amount of replicas that will ensure high availability and resilience. Production Load : the cluster is loaded with the latest dump of the internal SAP Eclipse Steady database (which at the time of this document creation is around 249GB). This deployment is not destined for high availability or resilience and is optimal for production environments with a 3-5 year usage buffer. This data load includes app specific data (once those are removed, the database size is around 150GB in our current setup) Production Load HA : same as the above but with the sufficient amount of replicas that will ensure high availability and resilience. Extra PVC : this use case is destined towards optimizing certain components of the Eclipse Steady which require read write many volumes (in particular rest-lib-utils ) Hosted DB : for using a pre-existing database (for cloud providers such as GCP, AWS, Azure, etc...) which require lower resources as the database are no longer self managed. CPU request CPU Limit Memory Request (GiB) Memory Limit (GiB) PV (GiB) Lightweight 8.5 17.1 12.5 25.6 30 Lightweight HA 17.6 35.2 30.5 61.2 90 Lightweight HA (with extra PVC) 17.6 35.2 30.5 61.2 102 Medium Load 16.5 33.1 24.5 49.6 50 Medium Load HA 30.2 60.7 51.7 102.7 150 Medium Load HA (with extra PVC) 30.2 60.7 51.7 102.7 195 Production Load 40.7 57.6 57.2 92.6 400 Production Load HA 107.9 160.2 159.4 262.2 1200 Production Load HA (with extra PVC) 107.9 160.2 159.4 262.2 1380 Lightweight HA (hosted db) 8.7 17.7 16.7 34.2 90 Medium Load HA (hosted db) 16.7 33.7 32.7 66.2 150 Production Load HA (hosted db) 48.9 98.2 97.4 197.2 1200","title":"Operational requirements"},{"location":"admin/tutorials/kubernetes_resources/#in-depth-break-down-of-resource-requirements","text":"","title":"In-depth break down of resource requirements"},{"location":"admin/tutorials/kustomize/","text":"Deploy on Kubernetes with Kustomize \u00b6 In this tutorial you will be guided through the necessary steps to set-up the Eclipse Steady backend services in a Kubernetes cluster using Kustomize version 2.0.3 Kustomize and Kubectl kubectl starting version 1.14 already comes with Kustomize 2.0.3 bundled. As of now Kustomize 3.1.0 is not supported by kubectl so it will also not be supported by Eclipse Steady Pre-requisites \u00b6 git kubectl a Kubernetes cluster Setup \u00b6 Clone locally Eclipse Steady repository and change the directory to Kustomize's folder git clone https://github.com/eclipse/steady.git cd steady/kubernetes/kustomize Make a copy of the files in kubernetes/kustomize/secrets and edit them to match your needs. cp secrets/.env.sample secrets/.env cp secrets/bugs-frontend-credentials.sample secrets/bugs-frontend-credentials # edit the above files Run \u00b6 You are now ready to deploy Eclipse Steady inside your Kubernetes cluster: kubectl apply -k . The above command will create a Namespace called vulnerability-assessment-tool and install all the component on it. To check if everything is starting successfully you can watch the deployments by running the command kubectl -n vulnerability-assessment-tool get pods -w . The deployment will request two PersistentVolumeClaims and a Service type:LoadBalancer which could need some time to be created depending on the provider you are running on. Reaching Eclipse Steady from the Internet Eclipse Steady uses a Service of type LoadBalancer to allow Internet traffic to reach the cluster. This Service will request an external LoadBalancer to your provider and will connect to it. This LoadBalancer will be exposed on the Internet so be careful. The Service type:LoadBalancer should work with most providers such as GKE, Azure. If not, you can follow this ingress-nginx guide Debugging Eclipse Steady from the local network You can avoid listening to the Internet by disabling the Service present in the services/cloud.yml file. To disable the file you can just comment the relative line in the root-level kustomization.yaml file. You can then connect to the main Service by port-forward ing with the command kubectl -n vulnerability-assessment-tool port-forward svc/haproxy-ingress 7000:8080 and then opening your browser at localhost:8080/apps Populate/maintain the vulnerability database \u00b6 In order for the tool to detect vulnerabilities, you need to import and analyze them first so that they are available in the tool's vulnerability database. Large part of CVE's and bugs are open sourced in vulnerability-assessment-kb . Follow the instructions mentioned here , to import and build all the vulnerabilities' knowledge. Get going: Import all the CVEs and bugs in your local database Setup your workspace (if you don't have one) Become familiar with the various analysis goals (first time users) Analyze your Java or Python application (on a regular basis) Assess findings using the apps Web frontend (following every analysis) Further links: Configure the client-side analysis Automate with Jenkins Get help if you run into troubles","title":"Deploy on Kubernetes with Kustomize"},{"location":"admin/tutorials/kustomize/#deploy-on-kubernetes-with-kustomize","text":"In this tutorial you will be guided through the necessary steps to set-up the Eclipse Steady backend services in a Kubernetes cluster using Kustomize version 2.0.3 Kustomize and Kubectl kubectl starting version 1.14 already comes with Kustomize 2.0.3 bundled. As of now Kustomize 3.1.0 is not supported by kubectl so it will also not be supported by Eclipse Steady","title":"Deploy on Kubernetes with Kustomize"},{"location":"admin/tutorials/kustomize/#pre-requisites","text":"git kubectl a Kubernetes cluster","title":"Pre-requisites"},{"location":"admin/tutorials/kustomize/#setup","text":"Clone locally Eclipse Steady repository and change the directory to Kustomize's folder git clone https://github.com/eclipse/steady.git cd steady/kubernetes/kustomize Make a copy of the files in kubernetes/kustomize/secrets and edit them to match your needs. cp secrets/.env.sample secrets/.env cp secrets/bugs-frontend-credentials.sample secrets/bugs-frontend-credentials # edit the above files","title":"Setup"},{"location":"admin/tutorials/kustomize/#run","text":"You are now ready to deploy Eclipse Steady inside your Kubernetes cluster: kubectl apply -k . The above command will create a Namespace called vulnerability-assessment-tool and install all the component on it. To check if everything is starting successfully you can watch the deployments by running the command kubectl -n vulnerability-assessment-tool get pods -w . The deployment will request two PersistentVolumeClaims and a Service type:LoadBalancer which could need some time to be created depending on the provider you are running on. Reaching Eclipse Steady from the Internet Eclipse Steady uses a Service of type LoadBalancer to allow Internet traffic to reach the cluster. This Service will request an external LoadBalancer to your provider and will connect to it. This LoadBalancer will be exposed on the Internet so be careful. The Service type:LoadBalancer should work with most providers such as GKE, Azure. If not, you can follow this ingress-nginx guide Debugging Eclipse Steady from the local network You can avoid listening to the Internet by disabling the Service present in the services/cloud.yml file. To disable the file you can just comment the relative line in the root-level kustomization.yaml file. You can then connect to the main Service by port-forward ing with the command kubectl -n vulnerability-assessment-tool port-forward svc/haproxy-ingress 7000:8080 and then opening your browser at localhost:8080/apps","title":"Run"},{"location":"admin/tutorials/kustomize/#populatemaintain-the-vulnerability-database","text":"In order for the tool to detect vulnerabilities, you need to import and analyze them first so that they are available in the tool's vulnerability database. Large part of CVE's and bugs are open sourced in vulnerability-assessment-kb . Follow the instructions mentioned here , to import and build all the vulnerabilities' knowledge. Get going: Import all the CVEs and bugs in your local database Setup your workspace (if you don't have one) Become familiar with the various analysis goals (first time users) Analyze your Java or Python application (on a regular basis) Assess findings using the apps Web frontend (following every analysis) Further links: Configure the client-side analysis Automate with Jenkins Get help if you run into troubles","title":"Populate/maintain the vulnerability database"},{"location":"admin/tutorials/registry/","text":"Push Docker images on a registry \u00b6 Pre-requisites \u00b6 git bash docker docker-compose Generate Eclipse Steady images \u00b6 In order to generate the Docker images to upload to a local registry, you should generate Eclipse Steady's Java archives. This can be done following Build JAVA archives/Docker images tutorial. To briefly summarize you should build and run an image which will populate your local directories with the Eclipse Steady JARs and WARs. In the end of this preliminary step you should have your images locally, this can be tested with the command docker images | grep steady . # sample output for `docker images` command steady-generator 3 .2.2 a829f93eb9aa 22 hours ago 223MB steady-patch-lib-analyzer 3 .2.2 fbe5ec6de811 22 hours ago 103MB steady-rest-backend 3 .2.2 277217bc35b2 22 hours ago 136MB steady-rest-lib-utils 3 .2.2 53bbb929895d 22 hours ago 127MB steady-frontend-bugs 3 .2.2 fab5925fe785 22 hours ago 316MB steady-frontend-apps 3 .2.2 191ce235c420 22 hours ago 317MB Push the images to a registry \u00b6 A script was created to push the images to a local Docker registry running inside your organization. This script simply tags the images and pushes them towards the registry. To use the script you will need: a registry in your organization (e.g., goharbor/harbor ) a username Eclipse Steady used version Invoke the script with the following positional arguments. docker login [ registry ] bash push-images.sh -r [ registry ] -u [ username ] -v [ steady-version ] Pulling the images from a repository \u00b6 You can use Docker to pull your images from a registry. docker pull [ registry ] / [ username ] /steady-rest-backend: [ steady-version ] Get going: Deploy a Kubernetes cluster on the Internet with the images you just pushed","title":"Push Docker images to a registry"},{"location":"admin/tutorials/registry/#push-docker-images-on-a-registry","text":"","title":"Push Docker images on a registry"},{"location":"admin/tutorials/registry/#pre-requisites","text":"git bash docker docker-compose","title":"Pre-requisites"},{"location":"admin/tutorials/registry/#generate-eclipse-steady-images","text":"In order to generate the Docker images to upload to a local registry, you should generate Eclipse Steady's Java archives. This can be done following Build JAVA archives/Docker images tutorial. To briefly summarize you should build and run an image which will populate your local directories with the Eclipse Steady JARs and WARs. In the end of this preliminary step you should have your images locally, this can be tested with the command docker images | grep steady . # sample output for `docker images` command steady-generator 3 .2.2 a829f93eb9aa 22 hours ago 223MB steady-patch-lib-analyzer 3 .2.2 fbe5ec6de811 22 hours ago 103MB steady-rest-backend 3 .2.2 277217bc35b2 22 hours ago 136MB steady-rest-lib-utils 3 .2.2 53bbb929895d 22 hours ago 127MB steady-frontend-bugs 3 .2.2 fab5925fe785 22 hours ago 316MB steady-frontend-apps 3 .2.2 191ce235c420 22 hours ago 317MB","title":"Generate Eclipse Steady images"},{"location":"admin/tutorials/registry/#push-the-images-to-a-registry","text":"A script was created to push the images to a local Docker registry running inside your organization. This script simply tags the images and pushes them towards the registry. To use the script you will need: a registry in your organization (e.g., goharbor/harbor ) a username Eclipse Steady used version Invoke the script with the following positional arguments. docker login [ registry ] bash push-images.sh -r [ registry ] -u [ username ] -v [ steady-version ]","title":"Push the images to a registry"},{"location":"admin/tutorials/registry/#pulling-the-images-from-a-repository","text":"You can use Docker to pull your images from a registry. docker pull [ registry ] / [ username ] /steady-rest-backend: [ steady-version ] Get going: Deploy a Kubernetes cluster on the Internet with the images you just pushed","title":"Pulling the images from a repository"},{"location":"blog/2018/","text":"","title":"Home"},{"location":"contributor/","text":"Contribute \u00b6 Our aim is to build a lively community, hence, we welcome any exchange and collaboration with individuals and organizations interested in the use, support and extension of Eclipse Steady. To contribute, read on to learn about your options: Contribute to the Vulnerability Knowledge Base Help Others on Stack Overflow Report Bugs as GitHub issues Analyze Bugs Contribute Code (fixes and features) Contribute to the Vulnerability Knowledge Base \u00b6 Please refer to the project \"KB\" documentation . Help Others \u00b6 You can help by helping others who use Eclipse Steady and need support. Find them on Stack Overflow . Report Bugs \u00b6 If you find a bug - a behavior of the code contradicting its specification - you are welcome to report it. We can only handle well-reported, actual bugs, so please follow the guidelines below and use forums like Stack Overflow for support questions or when in doubt whether the issue is an actual bug. Once you have familiarized with the guidelines, you can go to the GitHub issue tracker to report the issue. Quick Checklist for Bug Reports \u00b6 Issue report checklist: Real, current bug No duplicate Reproducible Good summary Well-documented Minimal example Use the template Requirements for a bug report \u00b6 These eight requirements are the mandatory base of a good bug report: Only real bugs : please do your best to make sure to only report real bugs! Do not report: issues caused by application code or any code outside Eclipse Steady. something that behaves just different from what you expected. A bug is when something behaves different than specified. When in doubt, ask in a forum. something you do not get to work properly. Use a support forum like Stack Overflow to request help. feature requests. Well, this is arguable: critical or easy-to-do enhancement suggestions are welcome, but we do not want to use the issue tracker as wishlist. No duplicate: you have searched the issue tracker to make sure the bug has not yet been reported Good summary: the summary should be specific to the issue Current bug: the bug can be reproduced in the most current version (state the tested version!) Reproducible bug: there are clear steps to reproduce given. This includes, where possible: a URL to access the example any required user/password information (do not reveal any credentials that could be mis-used!) detailed and complete step-by-step instructions to reproduce the bug Precise description: precisely state the expected and the actual behavior give information about the used browser/device and its version, if possible also the behavior in other browsers/devices if the bug is about wrong UI appearance, attach a screenshot and mark what is wrong generally give as much additional information as possible. (But find the right balance: do not invest hours for a very obvious and easy to solve issue. When in doubt, give more information.) Minimal example: it is highly encouraged to provide a minimal example to reproduce in e.g. jsbin: isolate the application code which triggers the issue and strip it down as much as possible as long as the issue still occurs. If several files are required, you can create a gist. This may not always be possible and sometimes be overkill, but it always helps analyzing a bug. Only one bug per report: open different tickets for different issues You are encouraged to use this template . Please report bugs in English, so all users can understand them. If the bug appears to be a regression introduced in a new version of Eclipse Steady, try to find the closest versions between which it was introduced. Issue handling process \u00b6 When an issue is reported, a committer will look at it and either confirm it as a real issue (by giving the \"approved\" label), close it if it is not an issue, or ask for more details. Approved issues are then either assigned to a committer in GitHub, reported in our internal issue handling system, or left open as \"contribution welcome\" for easy or not urgent fixes. An issue that is about a real bug is closed as soon as the fix is committed. The closing comment explains which patch version(s) will contain the fix. Reporting Security Issues \u00b6 If you find a security issue, please act responsibly and do NOT report it in the public issue tracker. Instead, open a ticket in the Eclipse Bugzilla instance. More information about Eclipse's vulnerability reporting guidelines can be found in the Eclipse Project Handbook . Usage of Labels \u00b6 Github offers labels to categorize issues. We defined the following labels so far: Labels for issue categories: bug: this issue is a bug in the code documentation: this issue is about wrong documentation enhancement: this is not a bug report, but an enhancement request Status of open issues: unconfirmed: this report needs confirmation whether it is really a bug (no label; this is the default status) approved: this issue is confirmed to be a bug author action: the author is required to provide information contribution welcome: this fix/enhancement is approved and you are invited to contribute it Status/resolution of closed issues: fixed: a fix for the issue was provided duplicate: the issue is also reported in a different ticket and is handled there invalid: for some reason or another this issue report will not be handled further (maybe lack of information or issue does not apply anymore) works: not reproducible or working as expected wontfix: while acknowledged to be an issue, a fix cannot or will not be provided The labels can only be set and modified by committers. Issue Reporting Disclaimer \u00b6 We want to improve the quality of Eclipse Steady and good bug reports are welcome! But our capacity is limited, so we cannot handle questions or consultation requests and we cannot afford to ask for required details. So we reserve the right to close or to not process insufficient bug reports in favor of those which are very cleanly documented and easy to reproduce. Even though we would like to solve each well-documented issue, there is always the chance that it won't happen - remember: Eclipse Steady is Open Source and comes without warranty. Analyze Bugs \u00b6 Analyzing issue reports can be a lot of effort. Any help is welcome! Go to the Github issue tracker and find an open issue which needs additional work or a bugfix. Additional work may be further information, or a minimized jsbin example or gist, or it might be a hint that helps understanding the issue. Maybe you can even find and contribute a bugfix? Contribute Code \u00b6 You are welcome to contribute code in order to fix bugs or to implement new features. There are three important things to know: You must be aware of the Apache License (which describes contributions) and agree to the Eclipse Contributor Agreement (see below). There are several requirements regarding code style, quality, and product standards which need to be met (we also have to follow them). The respective section below gives more details on the coding guidelines. Not all proposed contributions can be accepted . Some features may e.g. just fit a third-party add-on better. The code must fit the overall direction of the open-source vulnerability assessment tool and really improve it, so there should be some \"bang for the byte\". For most bug fixes this is a given, but major feature implementation first need to be discussed with one of the Eclipse Steady committers , possibly one who touched the related code recently. The more effort you invest, the better you should clarify in advance whether the contribution fits: the best way would be to just open an enhancement ticket in the issue tracker to discuss the feature you plan to implement (make it clear you intend to contribute). We will then forward the proposal to the respective code owner, this avoids disappointment. Eclipse Contributor Agreement (ECA) \u00b6 Due to legal reasons, contributors will be asked to accept the ECA before they submit the first pull request to this projects, this happens in an automated fashion during the submission process. Please see the Eclipse Contributor Agreement for more information. Contribution Content Guidelines \u00b6 Contributed content can be accepted if it: is useful to improve Eclipse Steady (explained above) follows the applicable guidelines and standards The second requirement could be described in entire books and would still lack a 100%-clear definition, so you will get a committer's feedback if something is not right. These are some of the most important rules to give you an initial impression: Check your Java code with Spotbugs by running mvn -Dspotbugs.excludeFilterFile=findbugs-exclude.xml -Dspotbugs.includeFilterFile=findbugs-include.xml -Dspotbugs.failOnError=true clean compile com.github.spotbugs:spotbugs-maven-plugin:4.0.4:check . Code with MEDIUM or HIGH priority findings in one of the following categories will be rejected (see findbugs-include.xml ): PERFORMANCE, SECURITY, CORRECTNESS, MALICIOUS_CODE, MT_CORRECTNESS Strictly follow Google's Java Style Guide , e.g., by installing the respective plugin for your IDE or by using the script .travis/check_code_style.sh . Contributions will be automatically checked using google-java-format , and rejected if they do not comply. Use variable naming conventions like in the other files you are seeing (e.g. hungarian notation) No System.out.println Only access public APIs of other entities (there are exceptions, but this is the rule) Comment your code where it gets non-trivial Keep an eye on performance and memory consumption Write a unit test Do not do any incompatible changes, especially do not modify the name or behavior of public API methods or properties Always consider the developer who USES your control/code! Think about what code and how much code he/she will need to write to use your feature Think about what she/he expects your control/feature to do If this list sounds lengthy and hard to achieve - well, that's what WE have to comply with as well, and it's by far not complete\u2026 How to contribute - the Process \u00b6 Make sure the change would be welcome (e.g. a bugfix or a useful feature); best do so by proposing it in a GitHub issue Create a branch forking Eclipse Steady repository and do your change Commit and push your changes on that branch When you have several commits, squash them into one (see this explanation ) - this also needs to be done when additional changes are required after the code review Provide a meaningful commit message incl. links to the respective issue If your change fixes an issue reported at GitHub, add the following line to the commit message: Fixes https://github.com/eclipse/steady/issues/(issueNumber) Do NOT add a colon after \"Fixes\" - this prevents automatic closing. When your pull request number is known (e.g. because you enhance a pull request after a code review), you can also add the line Closes https://github.com/eclipse/steady/pull/(pullRequestNumber) Create a Pull Request to https://github.com/eclipse/steady If necessary, sign the Eclipse Contributor Agreement Wait for our code review and approval, possibly enhancing your change on request Note that Eclipse Steady developers also have their regular duties, so depending on the required effort for reviewing, testing and clarification this may take a while Once the change has been approved we will inform you in a comment Your pull request cannot be merged directly into the branch (internal SAP processes), but will be merged internally and immediately appear in the public repository as well. Pull requests for non-code branches (like \"gh-pages\" for the website) can be directly merged. We will close the pull request, feel free to delete the now obsolete branch","title":"Contribute"},{"location":"contributor/#contribute","text":"Our aim is to build a lively community, hence, we welcome any exchange and collaboration with individuals and organizations interested in the use, support and extension of Eclipse Steady. To contribute, read on to learn about your options: Contribute to the Vulnerability Knowledge Base Help Others on Stack Overflow Report Bugs as GitHub issues Analyze Bugs Contribute Code (fixes and features)","title":"Contribute"},{"location":"contributor/#contribute-to-the-vulnerability-knowledge-base","text":"Please refer to the project \"KB\" documentation .","title":"Contribute to the Vulnerability Knowledge Base"},{"location":"contributor/#help-others","text":"You can help by helping others who use Eclipse Steady and need support. Find them on Stack Overflow .","title":"Help Others"},{"location":"contributor/#report-bugs","text":"If you find a bug - a behavior of the code contradicting its specification - you are welcome to report it. We can only handle well-reported, actual bugs, so please follow the guidelines below and use forums like Stack Overflow for support questions or when in doubt whether the issue is an actual bug. Once you have familiarized with the guidelines, you can go to the GitHub issue tracker to report the issue.","title":"Report Bugs"},{"location":"contributor/#quick-checklist-for-bug-reports","text":"Issue report checklist: Real, current bug No duplicate Reproducible Good summary Well-documented Minimal example Use the template","title":"Quick Checklist for Bug Reports"},{"location":"contributor/#requirements-for-a-bug-report","text":"These eight requirements are the mandatory base of a good bug report: Only real bugs : please do your best to make sure to only report real bugs! Do not report: issues caused by application code or any code outside Eclipse Steady. something that behaves just different from what you expected. A bug is when something behaves different than specified. When in doubt, ask in a forum. something you do not get to work properly. Use a support forum like Stack Overflow to request help. feature requests. Well, this is arguable: critical or easy-to-do enhancement suggestions are welcome, but we do not want to use the issue tracker as wishlist. No duplicate: you have searched the issue tracker to make sure the bug has not yet been reported Good summary: the summary should be specific to the issue Current bug: the bug can be reproduced in the most current version (state the tested version!) Reproducible bug: there are clear steps to reproduce given. This includes, where possible: a URL to access the example any required user/password information (do not reveal any credentials that could be mis-used!) detailed and complete step-by-step instructions to reproduce the bug Precise description: precisely state the expected and the actual behavior give information about the used browser/device and its version, if possible also the behavior in other browsers/devices if the bug is about wrong UI appearance, attach a screenshot and mark what is wrong generally give as much additional information as possible. (But find the right balance: do not invest hours for a very obvious and easy to solve issue. When in doubt, give more information.) Minimal example: it is highly encouraged to provide a minimal example to reproduce in e.g. jsbin: isolate the application code which triggers the issue and strip it down as much as possible as long as the issue still occurs. If several files are required, you can create a gist. This may not always be possible and sometimes be overkill, but it always helps analyzing a bug. Only one bug per report: open different tickets for different issues You are encouraged to use this template . Please report bugs in English, so all users can understand them. If the bug appears to be a regression introduced in a new version of Eclipse Steady, try to find the closest versions between which it was introduced.","title":"Requirements for a bug report"},{"location":"contributor/#issue-handling-process","text":"When an issue is reported, a committer will look at it and either confirm it as a real issue (by giving the \"approved\" label), close it if it is not an issue, or ask for more details. Approved issues are then either assigned to a committer in GitHub, reported in our internal issue handling system, or left open as \"contribution welcome\" for easy or not urgent fixes. An issue that is about a real bug is closed as soon as the fix is committed. The closing comment explains which patch version(s) will contain the fix.","title":"Issue handling process"},{"location":"contributor/#reporting-security-issues","text":"If you find a security issue, please act responsibly and do NOT report it in the public issue tracker. Instead, open a ticket in the Eclipse Bugzilla instance. More information about Eclipse's vulnerability reporting guidelines can be found in the Eclipse Project Handbook .","title":"Reporting Security Issues"},{"location":"contributor/#usage-of-labels","text":"Github offers labels to categorize issues. We defined the following labels so far: Labels for issue categories: bug: this issue is a bug in the code documentation: this issue is about wrong documentation enhancement: this is not a bug report, but an enhancement request Status of open issues: unconfirmed: this report needs confirmation whether it is really a bug (no label; this is the default status) approved: this issue is confirmed to be a bug author action: the author is required to provide information contribution welcome: this fix/enhancement is approved and you are invited to contribute it Status/resolution of closed issues: fixed: a fix for the issue was provided duplicate: the issue is also reported in a different ticket and is handled there invalid: for some reason or another this issue report will not be handled further (maybe lack of information or issue does not apply anymore) works: not reproducible or working as expected wontfix: while acknowledged to be an issue, a fix cannot or will not be provided The labels can only be set and modified by committers.","title":"Usage of Labels"},{"location":"contributor/#issue-reporting-disclaimer","text":"We want to improve the quality of Eclipse Steady and good bug reports are welcome! But our capacity is limited, so we cannot handle questions or consultation requests and we cannot afford to ask for required details. So we reserve the right to close or to not process insufficient bug reports in favor of those which are very cleanly documented and easy to reproduce. Even though we would like to solve each well-documented issue, there is always the chance that it won't happen - remember: Eclipse Steady is Open Source and comes without warranty.","title":"Issue Reporting Disclaimer"},{"location":"contributor/#analyze-bugs","text":"Analyzing issue reports can be a lot of effort. Any help is welcome! Go to the Github issue tracker and find an open issue which needs additional work or a bugfix. Additional work may be further information, or a minimized jsbin example or gist, or it might be a hint that helps understanding the issue. Maybe you can even find and contribute a bugfix?","title":"Analyze Bugs"},{"location":"contributor/#contribute-code","text":"You are welcome to contribute code in order to fix bugs or to implement new features. There are three important things to know: You must be aware of the Apache License (which describes contributions) and agree to the Eclipse Contributor Agreement (see below). There are several requirements regarding code style, quality, and product standards which need to be met (we also have to follow them). The respective section below gives more details on the coding guidelines. Not all proposed contributions can be accepted . Some features may e.g. just fit a third-party add-on better. The code must fit the overall direction of the open-source vulnerability assessment tool and really improve it, so there should be some \"bang for the byte\". For most bug fixes this is a given, but major feature implementation first need to be discussed with one of the Eclipse Steady committers , possibly one who touched the related code recently. The more effort you invest, the better you should clarify in advance whether the contribution fits: the best way would be to just open an enhancement ticket in the issue tracker to discuss the feature you plan to implement (make it clear you intend to contribute). We will then forward the proposal to the respective code owner, this avoids disappointment.","title":"Contribute Code"},{"location":"contributor/#eclipse-contributor-agreement-eca","text":"Due to legal reasons, contributors will be asked to accept the ECA before they submit the first pull request to this projects, this happens in an automated fashion during the submission process. Please see the Eclipse Contributor Agreement for more information.","title":"Eclipse Contributor Agreement (ECA)"},{"location":"contributor/#contribution-content-guidelines","text":"Contributed content can be accepted if it: is useful to improve Eclipse Steady (explained above) follows the applicable guidelines and standards The second requirement could be described in entire books and would still lack a 100%-clear definition, so you will get a committer's feedback if something is not right. These are some of the most important rules to give you an initial impression: Check your Java code with Spotbugs by running mvn -Dspotbugs.excludeFilterFile=findbugs-exclude.xml -Dspotbugs.includeFilterFile=findbugs-include.xml -Dspotbugs.failOnError=true clean compile com.github.spotbugs:spotbugs-maven-plugin:4.0.4:check . Code with MEDIUM or HIGH priority findings in one of the following categories will be rejected (see findbugs-include.xml ): PERFORMANCE, SECURITY, CORRECTNESS, MALICIOUS_CODE, MT_CORRECTNESS Strictly follow Google's Java Style Guide , e.g., by installing the respective plugin for your IDE or by using the script .travis/check_code_style.sh . Contributions will be automatically checked using google-java-format , and rejected if they do not comply. Use variable naming conventions like in the other files you are seeing (e.g. hungarian notation) No System.out.println Only access public APIs of other entities (there are exceptions, but this is the rule) Comment your code where it gets non-trivial Keep an eye on performance and memory consumption Write a unit test Do not do any incompatible changes, especially do not modify the name or behavior of public API methods or properties Always consider the developer who USES your control/code! Think about what code and how much code he/she will need to write to use your feature Think about what she/he expects your control/feature to do If this list sounds lengthy and hard to achieve - well, that's what WE have to comply with as well, and it's by far not complete\u2026","title":"Contribution Content Guidelines"},{"location":"contributor/#how-to-contribute-the-process","text":"Make sure the change would be welcome (e.g. a bugfix or a useful feature); best do so by proposing it in a GitHub issue Create a branch forking Eclipse Steady repository and do your change Commit and push your changes on that branch When you have several commits, squash them into one (see this explanation ) - this also needs to be done when additional changes are required after the code review Provide a meaningful commit message incl. links to the respective issue If your change fixes an issue reported at GitHub, add the following line to the commit message: Fixes https://github.com/eclipse/steady/issues/(issueNumber) Do NOT add a colon after \"Fixes\" - this prevents automatic closing. When your pull request number is known (e.g. because you enhance a pull request after a code review), you can also add the line Closes https://github.com/eclipse/steady/pull/(pullRequestNumber) Create a Pull Request to https://github.com/eclipse/steady If necessary, sign the Eclipse Contributor Agreement Wait for our code review and approval, possibly enhancing your change on request Note that Eclipse Steady developers also have their regular duties, so depending on the required effort for reviewing, testing and clarification this may take a while Once the change has been approved we will inform you in a comment Your pull request cannot be merged directly into the branch (internal SAP processes), but will be merged internally and immediately appear in the public repository as well. Pull requests for non-code branches (like \"gh-pages\" for the website) can be directly merged. We will close the pull request, feel free to delete the now obsolete branch","title":"How to contribute - the Process"},{"location":"contributor/manuals/","text":"","title":"Home"},{"location":"contributor/manuals/languages/","text":"ANTLR grammar \u00b6 Eclipse Steady uses ANTLR to parse Java and Python source code. Grammars are downloaded from https://github.com/antlr/grammars-v4 and put into directory src/main/antlr4 (in subdirectories matching the target Java package namespace of the generated parsers, e.g., org/eclipse/steady/java/antlr for Java). The actual Java classes are generated by the ANTLR plugin org.antlr:antlr4-maven-plugin . Python \u00b6 Grammars https://github.com/antlr/grammars-v4/tree/master/ ... and https://github.com/antlr/grammars-v4/tree/master/python3 are put into the modules lang-python , folder src/main/antlr4/org/eclipse/steady/python/antlr/python3 and python355 . The default parser has been generated from the Python 3.3.5 grammar, including for Python 2 source code. Which parser is taken at runtime depends on the presence of language features specific to Python 2 (e.g., raw_input ) and Python 3.5 (e.g., async ), see Java class PythonFileAnalyzer in module lang-python .","title":"ANTLR grammar"},{"location":"contributor/manuals/languages/#antlr-grammar","text":"Eclipse Steady uses ANTLR to parse Java and Python source code. Grammars are downloaded from https://github.com/antlr/grammars-v4 and put into directory src/main/antlr4 (in subdirectories matching the target Java package namespace of the generated parsers, e.g., org/eclipse/steady/java/antlr for Java). The actual Java classes are generated by the ANTLR plugin org.antlr:antlr4-maven-plugin .","title":"ANTLR grammar"},{"location":"contributor/manuals/languages/#python","text":"Grammars https://github.com/antlr/grammars-v4/tree/master/ ... and https://github.com/antlr/grammars-v4/tree/master/python3 are put into the modules lang-python , folder src/main/antlr4/org/eclipse/steady/python/antlr/python3 and python355 . The default parser has been generated from the Python 3.3.5 grammar, including for Python 2 source code. Which parser is taken at runtime depends on the presence of language features specific to Python 2 (e.g., raw_input ) and Python 3.5 (e.g., async ), see Java class PythonFileAnalyzer in module lang-python .","title":"Python"},{"location":"contributor/support/faq/","text":"","title":"Faq"},{"location":"contributor/support/getting_help/","text":"Getting help \u00b6","title":"Getting help"},{"location":"contributor/support/getting_help/#getting-help","text":"","title":"Getting help"},{"location":"contributor/tutorials/new_lang/","text":"Support new language \u00b6 Info This tutorial is under construction, the information provided is expected to be incomplete... Extending Eclipse Steady to cover new languages requires the following steps: Extend enumerations comprised in component shared Create a new component lang-xyz that is able to extract all constructs from source and compiled code as well as packages of the respective programming language Add RUNTIME dependencies on lang-xyz to the client-side scan tools and patch-analyzer Extend the enumerations \u00b6 Extend enumeration com.sap.psr.vulas.shared.enums.ProgrammingLanguage to cover the new programming language. Right now, there exist the three values JAVA , PY (Python) and JS (JavaScript). However, even if the enumeration value for JavaScript exists, the other parts have not been implemented yet (see next sections). Create new component lang-xyz \u00b6 Create a new Maven module lang-xyz and add it to the root pom.xml . You can use lang-python as a template. The purpose of the component is to extract all constructs of source and compiled code as well as packaged artifacts (e.g., wheels in Python). ...","title":"Support new language"},{"location":"contributor/tutorials/new_lang/#support-new-language","text":"Info This tutorial is under construction, the information provided is expected to be incomplete... Extending Eclipse Steady to cover new languages requires the following steps: Extend enumerations comprised in component shared Create a new component lang-xyz that is able to extract all constructs from source and compiled code as well as packages of the respective programming language Add RUNTIME dependencies on lang-xyz to the client-side scan tools and patch-analyzer","title":"Support new language"},{"location":"contributor/tutorials/new_lang/#extend-the-enumerations","text":"Extend enumeration com.sap.psr.vulas.shared.enums.ProgrammingLanguage to cover the new programming language. Right now, there exist the three values JAVA , PY (Python) and JS (JavaScript). However, even if the enumeration value for JavaScript exists, the other parts have not been implemented yet (see next sections).","title":"Extend the enumerations"},{"location":"contributor/tutorials/new_lang/#create-new-component-lang-xyz","text":"Create a new Maven module lang-xyz and add it to the root pom.xml . You can use lang-python as a template. The purpose of the component is to extract all constructs of source and compiled code as well as packaged artifacts (e.g., wheels in Python). ...","title":"Create new component lang-xyz"},{"location":"contributor/tutorials/project_structure/","text":"Project structure \u00b6 The following picture shows all of the components (modules) of the Maven project hosted at https://github.com/eclipse/steady . Each component visible in the picture corresponds to a module listed in the pom.xml . The component (module) dependencies shown are of three kinds: Dependencies with Maven scopes COMPILE or RUNTIME and REST calls happening at runtime. The project comprises the following client-side tools to scan Java and Python applications. All of those run on a client, typically a Jenkins build server or a developer work station. plugin-maven scans Java applications developed with Java and Maven (based on the application-specific pom.xml ) plugin-gradle scans Java applications developed with Java and Gradle (based on the application-specific build.gradle ) cli-scanner scans both Java and Python applications (based on code present in the file system) plugin-setuptools scans Python applications (based on the application-specific setup.py ). Important : This component is not yet part of the GitHub repo https://github.com/eclipse/steady . Those client-side tools have just one COMPILE dependency on the language-agnostic component lang , which comprises a number of general functionality related to, for instance, backend connectivity or language-agnostic goals such as clean or report . The client-side tools also have RUNTIME dependencies on language-specific components. The motivation to use RUNTIME dependencies is to keep the client-side tools free of language-specific code. The project comprises the following frontends, all of them developed using OpenUI5 : frontend-apps is used by application developers to check scan results or their application frontend-bugs is used by administrators to check and maintain bug information frontend-patch-analyzer is used by administrators to trigger the analysis of fix commits. Important : This component is outdated, the analysis of fix commits is done using the patch-analyzer command-line tool. The language-specific component comprise all the logic to analyze source and compiled code as well as the various package formats of the respective programming language, e.g., JARs and WARs in case of Java. For Java, there also exist several modules related to the static analysis, namely lang-java-reach , lang-java-reach-wala and lang-java-reach-soot . There exist the following two server-side components, both of them exposing a RESTful interface browsable through Swagger: rest-backend is connected to a PostgreSQL database in order to store and join vulnerability information and application analysis results rest-lib-utils analyses Java archives in order to, for instance, obtain Abstract Syntax Trees for Java methods comprises in given Maven artifacts The remaining components are as follows: repo-client supports interactions with Git and SVN repositories patch-lib-analyzer determines whether open source components comprise the affected (vulnerable) or the fixed version of a given methods shared comprises utilities, model classes used for (de)serialization and other general functionality relevant for all other components patch-analyzer examines the fix commit(s) of a given vulnerability in order to understand which methods have been changed in order to fix the vulnerability","title":"Project structure"},{"location":"contributor/tutorials/project_structure/#project-structure","text":"The following picture shows all of the components (modules) of the Maven project hosted at https://github.com/eclipse/steady . Each component visible in the picture corresponds to a module listed in the pom.xml . The component (module) dependencies shown are of three kinds: Dependencies with Maven scopes COMPILE or RUNTIME and REST calls happening at runtime. The project comprises the following client-side tools to scan Java and Python applications. All of those run on a client, typically a Jenkins build server or a developer work station. plugin-maven scans Java applications developed with Java and Maven (based on the application-specific pom.xml ) plugin-gradle scans Java applications developed with Java and Gradle (based on the application-specific build.gradle ) cli-scanner scans both Java and Python applications (based on code present in the file system) plugin-setuptools scans Python applications (based on the application-specific setup.py ). Important : This component is not yet part of the GitHub repo https://github.com/eclipse/steady . Those client-side tools have just one COMPILE dependency on the language-agnostic component lang , which comprises a number of general functionality related to, for instance, backend connectivity or language-agnostic goals such as clean or report . The client-side tools also have RUNTIME dependencies on language-specific components. The motivation to use RUNTIME dependencies is to keep the client-side tools free of language-specific code. The project comprises the following frontends, all of them developed using OpenUI5 : frontend-apps is used by application developers to check scan results or their application frontend-bugs is used by administrators to check and maintain bug information frontend-patch-analyzer is used by administrators to trigger the analysis of fix commits. Important : This component is outdated, the analysis of fix commits is done using the patch-analyzer command-line tool. The language-specific component comprise all the logic to analyze source and compiled code as well as the various package formats of the respective programming language, e.g., JARs and WARs in case of Java. For Java, there also exist several modules related to the static analysis, namely lang-java-reach , lang-java-reach-wala and lang-java-reach-soot . There exist the following two server-side components, both of them exposing a RESTful interface browsable through Swagger: rest-backend is connected to a PostgreSQL database in order to store and join vulnerability information and application analysis results rest-lib-utils analyses Java archives in order to, for instance, obtain Abstract Syntax Trees for Java methods comprises in given Maven artifacts The remaining components are as follows: repo-client supports interactions with Git and SVN repositories patch-lib-analyzer determines whether open source components comprise the affected (vulnerable) or the fixed version of a given methods shared comprises utilities, model classes used for (de)serialization and other general functionality relevant for all other components patch-analyzer examines the fix commit(s) of a given vulnerability in order to understand which methods have been changed in order to fix the vulnerability","title":"Project structure"},{"location":"user/","text":"User Guide \u00b6 Step by step tutorials Here you can find detailed, hands-on guidance on how to setup and use Eclipse Steady, starting from your very first scan, through the use of the advanced features (such as reachability analysis and mitigation support/. We also have tutorials dedicated to automating Eclipse Steady scans with Jenkins or other continuous integration systems, and more are coming. Go to the Tutorials page User Manual The manual contains a comprehensive description of all aspects of Eclipse Steady from the perspective of users. If you followed the tutorials and still have questions on some specific topic, this is where you will most likely find your answers. Go to the User Manual Getting Help If the tutorials and the manual could not help you with a specific problem you are facing, the support pages are what you should check out next. Go to the User Support page","title":"User Guide"},{"location":"user/#user-guide","text":"Step by step tutorials Here you can find detailed, hands-on guidance on how to setup and use Eclipse Steady, starting from your very first scan, through the use of the advanced features (such as reachability analysis and mitigation support/. We also have tutorials dedicated to automating Eclipse Steady scans with Jenkins or other continuous integration systems, and more are coming. Go to the Tutorials page User Manual The manual contains a comprehensive description of all aspects of Eclipse Steady from the perspective of users. If you followed the tutorials and still have questions on some specific topic, this is where you will most likely find your answers. Go to the User Manual Getting Help If the tutorials and the manual could not help you with a specific problem you are facing, the support pages are what you should check out next. Go to the User Support page","title":"User Guide"},{"location":"user/manuals/","text":"User Manual \u00b6 Configuration \u00b6 This section of the manual explains in detail how to setup Eclipse Steady and how to configure it. Analysis \u00b6 This section covers all the commands (a.k.a, goals ) offered by Eclipse Steady, including those related to the analysis ( app , a2c , t2c , instr , test ) and the data management and reporting ( upload , report , clean , cleanspace ) Frontend \u00b6 Here you will find a detailed description (including annotated screenshots) of all the functionality exposed by the different views of the Eclipse Steady web frontend. Report \u00b6 Coming soon! Impact Assessment and Mitigation \u00b6 This section explains in detail how to assess the findings of Eclipse Steady and how to proceed to mitigate them. Library Assessment \u00b6 This section documents the process to determine whether a given artifact contains the vulnerable or the fixed version of a construct that is known to be related to some vulnerability.","title":"Intro"},{"location":"user/manuals/#user-manual","text":"","title":"User Manual"},{"location":"user/manuals/#configuration","text":"This section of the manual explains in detail how to setup Eclipse Steady and how to configure it.","title":"Configuration"},{"location":"user/manuals/#analysis","text":"This section covers all the commands (a.k.a, goals ) offered by Eclipse Steady, including those related to the analysis ( app , a2c , t2c , instr , test ) and the data management and reporting ( upload , report , clean , cleanspace )","title":"Analysis"},{"location":"user/manuals/#frontend","text":"Here you will find a detailed description (including annotated screenshots) of all the functionality exposed by the different views of the Eclipse Steady web frontend.","title":"Frontend"},{"location":"user/manuals/#report","text":"Coming soon!","title":"Report"},{"location":"user/manuals/#impact-assessment-and-mitigation","text":"This section explains in detail how to assess the findings of Eclipse Steady and how to proceed to mitigate them.","title":"Impact Assessment and Mitigation"},{"location":"user/manuals/#library-assessment","text":"This section documents the process to determine whether a given artifact contains the vulnerable or the fixed version of a construct that is known to be related to some vulnerability.","title":"Library Assessment"},{"location":"user/manuals/analysis/","text":"Analysis Manual \u00b6 Overview \u00b6 The various client-side tools offer so-called goals in order to analyze applications and interact with the backend. The following goals perform some sort of application analysis: app : Creates a method-level bill of material of an application and all its dependencies. a2c : Builds a call graph (starting from app methods) and checks whether vulnerable code is potentially executable (reachable). test : This is not an actual goal implemented by any of the clients, but describes the collection of execution traces by a so-called Java agent that dynamically instruments Java bytecode during JUnit and integration tests. instr : Produces a modified version of Java archives ( static instrumentation ) that can be deployed/executed in order to collect traces of actual method executions. t2c : Builds a call graph (starting from traced methods) and checks whether vulnerable code is potentially reachable from those. checkcode Downloads unconfirmed vulnerabilities from the backend to the client, and checks whether the affected dependencies contain vulnerable of fixed constructs. The following goals are related to data management and reporting: upload : Uploads analysis data previously written to disk to the backend report : Downloads analysis data from the backend to the client, produces a result report (HTML, XML, JSON), and throws a build exception in order to break Jenkins jobs clean : Cleans the analysis data of a single app in the backend cleanspace : Cleans an entire workspace in the backend Which goals are supported by the different clients, and how-to configure and execute them is explained in the following subsections. Note that all goal executions (including configuration settings and statistics) are shown on the \"History\" tab of the respective applications. Important: Make sure to understand the following before proceeding: app has to be executed before all the other analysis goals in order to detect all application dependencies with vulnerable code. Once it has been run, the assessment of findings can already start, each finding of app shown on the \"Vulnerabilities\" tab corresponds to a dependency of an application on a component with a known security vulnerability. The number of findings will not change when running other analysis goals. Instead, a2c , test and t2c try to collect evidence concerning the potential or actual execution of vulnerable code brought up by app . Assess every finding, no matter whether a2c , test and t2c were able to collect evidence or not. Not finding such evidence does not mean that vulnerabilities cannot be exploited. The absence of proof is not a proof of absence (of exploitable vulnerabilities). Prerequisites: A workspace has been created and its token is known Java 7 or later is installed Maven: The plugin is available in the local .m2 repository or in a Nexus repository configured in settings.xml (see here for more information on how to configure Maven) Limitations : The reachability analysis (goals a2c and t2c ) does not work with Java 9, as the underlying analysis frameworks do not support it. Prerequisites A workspace has been created and its token is known Java 7 or later is installed Maven: The Eclipse Steady Maven plugin must be available in the local .m2 repository or in a Nexus repository configured in settings.xml (see here for more information on how to configure Maven) Java 9 support The reachability analysis (goals a2c and t2c ) is not supported with Java 9, due to limitations of the 3 rd -party analysis frameworks that Eclipse Steady relies upon. Bill of material analysis (app) \u00b6 Objective \u00b6 Create a complete bill of material (BOM) of the application and of all its dependencies (direct and transitive). Most importantly, the BOM comprises the signatures of all methods of the application and all dependencies, which is compared with a list of methods known to be vulnerable. Moreover, the BOM also comprises meta-info on archive level, e.g., the manifest file entries or the archive's digest (SHA1 in case of Java archives, MD5 in case of Python). Result \u00b6 In the Eclipse Steady frontend, the table in tab \"Dependencies\" is populated. In case any of the dependencies has vulnerabilities, they are shown in tab \"Vulnerabilities\". The column \"Inclusion of vulnerable code\" indicates whether the version in use is known to be vulnerable or not (see tooltip for more information). Important \u00b6 By default, the Maven plugin searches for application source and compiled code in the folders src/main/java and target/classes . If source or byte code is generated or modified during the build process, and stored in other folders than the ones mentioned, you need to add those directories using the parameter vulas.core.app.sourceDir . Otherwise, the respective code will not be recognized as application code, hence, ignored when performing the reachability analysis. Example: Suppose source code is generated into the folder target/generated-sources . If this code is compiled into the folder target/classes , you do not need to do anything. If it is compiled into a different folder, you would need to add this folder to entries of vulas.core.app.sourceDir . Run as follows \u00b6 CLI java -jar steady-cli-3.2.2-jar-with-dependencies.jar -goal app Maven mvn -Dsteady compile steady:app Gradle ./gradlew assemble vulasApp Configure as follows \u00b6 # Where application source or bytecode and application dependencies (JAR and/or WAR files) are located # Relative or absolute paths, multiple values to be separated by comma vulas.core.app.sourceDir = # Whether or not empty apps (w/o constructs and dependencies) are uploaded to the backend vulas.core.app.uploadEmpty = false # When true, JAR not known to Eclipse Steady Maven central and not already available to the backend are posted to the backend vulas.core.app.uploadLibrary = false # Number of worker threads analyzing the JAR files from which classes are loaded vulas.core.jarAnalysis.poolSize = 4 # Package prefix(es) of application code (multiple values to be separated by comma) # Default: # CLI: - # Note: Ignored when running the Maven plugin. In all other cases it avoids the separation of application and dependency JARs into distinct folders vulas.core.app.appPrefixes = # Regex that identifies JARs with application code (multiple values to be separated by comma) # Default: # CLI: - # Note: Ignored when running the Maven plugin. In all other cases it avoids the separation of application and dependency JARs into distinct folders vulas.core.app.appJarNames = Reachable from app (a2c) \u00b6 Objectives \u00b6 Check whether vulnerable methods are reachable, i.e., whether the application can be run in a way that a vulnerable method is executed. Identify all so-called touch points, which are direct calls from an application method to a library method. Collect all reachable methods for every dependency of the application. The first objective supports the risk assessment for a given vulnerability, while the second and third objectives primarily support the mitigation. Depending on the size of the application, the reachability analysis can consume a considerable amount of resources (time and memory). It is not seldom that it runs for several hours. Limitations \u00b6 Python is not supported Java 9 and later versions are only supported when using Soot as call graph construction framework Result \u00b6 In the Eclipse Steady frontend, tab \"Vulnerabilities\", the column \"Static Analysis\" is populated for all libraries subject to known vulnerabilities. By selecting single row of this table and the one of the detailed page, one can get more information up until the paths of potential executions (if any). How does it work \u00b6 Eclipse Steady uses Wala or Soot , both static analysis frameworks for Java, in order to construct a call graph representing all possible program executions starting from application methods. This graph is traversed in order to see whether and from where methods with known vulnerabilities can be reached. Run as follows \u00b6 CLI java -Xmx8g -Xms2g -jar steady-cli-3.2.2-jar-with-dependencies.jar -goal a2c Maven export MAVEN_OPTS = \"-Xmx8g -Xms2g\" mvn -Dsteady compile steady:a2c Gradle ./gradlew assemble vulasA2C Configure as follows \u00b6 The following configuration options apply to the reachability analysis no matter which call graph construction framework is used. See below for framework-specific configuration options. # Limits the analysis to certain bugs (multiple values separated by comma) # If empty, all relevant bugs retrieved from backend will be considered # Default: empty vulas.reach.bugs = # Analysis framework to be used # Possible values: wala, soot vulas.reach.fwk = soot # Regex to filter entry points (semicolon separated) vulas.reach.constructFilter = # All packages to be excluded from call graph construction, packages # are separated by semicolon e.g. [java/.*;sun/.*]. Defaults for the different # analysis frameworks are provided in the respective configuration files. --> vulas.reach.excludePackages = # All JAR files to be excluded from call graph construction (multiple entries to be separated by comma) # # Default: WebServicesAgent.jar (from Wily Introscope, an app perf monitoring tool that has invalid manifest header fields creating problems for Wala) vulas.reach.excludeJars = WebServicesAgent.jar # Dir to search for app source files (only steady:a2c) # If empty, they will be fetched from backend vulas.reach.sourceDir = # Timeout for reachability analysis (in mins) # Default: 120 mins vulas.reach.timeout = 120 # Max number of paths uploaded for a reachable change list element vulas.reach.maxPathPerChangeListElement = 10 # Whether or not to collect touch points # Default: true vulas.reach.identifyTouchpoints = true # Whether to search for the shortest path(s) from entry points to vulnerable constructs, or to quit after the first path found # Default: true vulas.reach.searchShortest = true Call graph construction framework \u00b6 Behind the scene, a source code analysis framework is used to construct the call graph, either starting from application methods ( a2c ) or from traced methods ( t2c ). Right now, the two frameworks Wala and Soot are supported and can be configured with vulas.reach.fwk . Both offer several configuration options to influence the accuracy of the call graph and its construction time. Once the call graph has been constructed, its size (in terms of nodes and edges) is printed to the console, which is useful for comparing the impact of the different configuration options, e.g. [vulas-reach-1] INFO com.sap.psr.vulas.cg.wala.WalaCallgraphConstructor - Normalized call graph has [167639 nodes] (with distinct ConstructId) and [1279495 edges] WALA \u00b6 The setting vulas.reach.wala.callgraph.algorithm determines the construction algorithm to be used. From RTA (Rapid Type Analysis) to 0-1-ctn-CFA , the call graph becomes more accurate, but the construction takes more time. A more accurate call graph means that it contains less false-positives, i.e., method invocations that cannot happen during actual program execution. As a rule of thumb, a call graph constructed with RTA contains more nodes and edges than one constructed with 0-1-ctn-CFA . Note the following before choosing a more simple algorithm: The increase of nodes and edges resulting from, for instance, the choice of RTA, has a negative impact on the performance of the later analysis phases. As such, it may be worth to spend more time on the graph construction. See here , there and there for more information regarding the difference of call graph construction algorithms. # Possible values: 0-CFA; 0-ctn-CFA; vanilla-0-1-CFA; 0-1-CFA; 0-1-ctn-CFA # Default algorithm: 0-1-CFA vulas.reach.wala.callgraph.algorithm = 0-1-CFA The setting vulas.reach.wala.callgraph.reflection determines the consideration of reflection, which is commonly used to instantiate and invoke classes and methods. See here for more information. # Reflection option to be used for call graph construction # Possible values: FULL; NO_METHOD_INVOKE; NO_STRING_CONSTANTS; APPLICATION_GET_METHOD # Possible values: NONE; NO_FLOW_TO_CASTS; NO_FLOW_TO_CASTS_NO_METHOD_INVOKE; ONE_FLOW_TO_CASTS_NO_METHOD_INVOKE; NO_FLOW_TO_CASTS_APPLICATION_GET_METHOD; ONE_FLOW_TO_CASTS_APPLICATION_GET_METHOD # Default value: NO_FLOW_TO_CASTS_NO_METHOD_INVOKE vulas.reach.wala.callgraph.reflection = NO_FLOW_TO_CASTS_NO_METHOD_INVOKE Soot \u00b6 The subset of Soot configuration options that can be set through Eclipse Steady are as follows. For all other Soot settings, the respective defaults are taken. See here for a complete documentation of Soot configuration options. # Packages that are excluded when building callgraph # Soot option: -exclude ... # https://soot-build.cs.uni-paderborn.de/public/origin/master/soot/soot-master/3.1.0/options/soot_options.htm#section_5 vulas.reach.soot.exclusions = java.awt.*;javax.swing.*;sun.awt.*;sun.swing.*;org.netbeans.*;com.sun.*;org.openide.*;com.ibm.crypto.*;com.ibm.security.*;org.apache.xerces.* # Use or not use \"verbose mode\" when building callgraph # Default: false; Recommended: set it to true when debugging # Soot options: -verbose -debug -debug-resolver # https://soot-build.cs.uni-paderborn.de/public/origin/master/soot/soot-master/3.1.0/options/soot_options.htm#phase_5_2 vulas.reach.soot.verbose = false # Use or not use \"application mode\" when building callgraph # Soot option: -app # https://soot-build.cs.uni-paderborn.de/public/origin/master/soot/soot-master/3.1.0/options/soot_options.htm#section_2 vulas.reach.soot.appMode = false # Allow or not allow phantom references (Recommended: false) # Soot option: -allow-phantom-refs # https://soot-build.cs.uni-paderborn.de/public/origin/master/soot/soot-master/3.1.0/options/soot_options.htm#section_2 vulas.reach.soot.allowPhantom = true # No class body for excluded packages # Soot option: -no-bodies-for-excluded # https://soot-build.cs.uni-paderborn.de/public/origin/master/soot/soot-master/3.1.0/options/soot_options.htm#section_2 vulas.reach.soot.nobodyForX = true # Use soot spark or not; # if yes, three options could be set: spark.otf (default true); spark.vta (default false); spark.rta (default false). # Soot option: -p cg.spark ... # https://soot-build.cs.uni-paderborn.de/public/origin/master/soot/soot-master/3.1.0/options/soot_options.htm#phase_5_2 vulas.reach.soot.spark = true vulas.reach.soot.spark.otf = true vulas.reach.soot.spark.vta = false vulas.reach.soot.spark.rta = false # Whether and how to generate a 'DummyMainMethod' used as an entrypoint for the callgraph construction: # | Option | Consequence | # |-------------------------------------------------------------------- |------------------------------------------------------------------------------------------------------| # | none (default) | no 'DummyMainMethod' is generated (default) | # | soot.jimple.infoflow.entryPointCreators.SequentialEntryPointCreator | a 'DummyMainMethod' that invokes all entrypoints is generated | # | soot.jimple.infoflow.entryPointCreators.DefaultEntryPointCreator | a 'DummyMainMethod' in which all entrypoints are generated (random order) | # | org.eclipse.steady.cg.soot.CustomEntryPointCreator | same as DefaultEntryPointCreated + for abstract classes/interface a dummy implementation is generated | vulas.reach.soot.entrypointGenerator = none Dynamic instrumentation (JUnit) \u00b6 Objective \u00b6 Collect method traces during the execution of JUnit tests. Information about traced methods will be compared with methods subject to known vulnerabilities. Limitations \u00b6 Python is not supported Result \u00b6 In the Eclipse Steady frontend, tab \"Vulnerabilities\", the column \"Dynamic Analysis\" is populated for all libraries subject to known vulnerabilities. By selecting single row of this table and the one of the detailed page, one can get more information up until the paths of actual executions (if any). In the Eclipse Steady frontend, tab \"Test coverage\", the number of traced vs. the number of total methods is shown per Java package of the application. How does it work \u00b6 Eclipse Steady collects runtime information during application execution, most importantly whether a vulnerable method has been called and the corresponding call stack. In order to collect this information, the byte code of the application and all its dependencies has to be changed, which can be achieved either dynamically or statically: In case of dynamic instrumentation , the byte code of a given Java class is changed at the time the class definition is loaded for the first time, e.g., during the execution of JUnit tests or integration tests. Eclipse Steady injects statements in order to save the timestamp of every method invocation as well as stack trace information. Per default, this information is saved in folder target/vulas/upload and uploaded using the goal steady:upload . To that end, Eclipse Steady must be registered using the JVM option -javaagent . In case of JUnit tests, the agent is registered by the Maven goal prepare-agent . In case of static instrumentation , the byte code of classes residing in the file system is changed, e.g., the WAR file of a deployable Web application. This is done with help of the goal steady:instr (see below). Run as follows \u00b6 Maven mvn -Dsteady steady:prepare-agent test steady:upload Configure as follows \u00b6 # Byte code instrumentor(s) to be used (multiple ones to be separated by comma) # # Possible values: # org.eclipse.steady.java.monitor.trace.SingleTraceInstrumentor: Collects exactly one timestamp for every invoked vulnerable method (no call stack) # org.eclipse.steady.java.monitor.trace.SingleStackTraceInstrumentor: Collects at most \"vulas.core.instr.maxStacktraces\" call stack for every invoked vulnerable method # org.eclipse.steady.java.monitor.trace.StackTraceInstrumentor: Collects all call stacks for every invoked vulnerable method # org.eclipse.steady.java.monitor.touch.TouchPointInstrumentor: Collects so-called touch points, i.e., calls from an app method to a library method # org.eclipse.steady.java.monitor.slice.SliceInstrumentor: Modifies executable constructs such that, upon execution, a warning will be printed to stderr. The execution can be entirely prevented using a configuration setting # # Default: org.eclipse.steady.java.monitor.trace.SingleTraceInstrumentor # # Note: # The above list of possible values is ordered ascending after performance impact and memory consumption, # i.e., the SingleTraceInstrumentor has the least impact on performance and memory consumption vulas.core.instr.instrumentorsChoosen = org.eclipse.steady.java.monitor.trace.SingleTraceInstrumentor # Max. number of stacktraces collected per instrumented vulnerable method # Default: 10 # Note: Only applies to SingleStackTraceInstrumentor vulas.core.instr.maxStacktraces = 10 # JARs in the following directories (or its subdirs) will not be instrumented #vulas.core.instr.blacklist.dirs = # Constructs of dependencies having one of the following scope(s) will not be instrumented (multiple ones to be separated by comma) # Default: test, provided # Note: Only applies to Eclipse Steady Maven plugin; in case of Eclipse Steady CLI, all dependencies have scope RUNTIME vulas.core.instr.blacklist.jars.ignoreScopes = test, provided # User-provided blacklist: Constructs of dependencies whose filename matches one of the following regular expressions will not be instrumented (multiple ones to be separated by comma) # Default: - # Note: Those are on top of \"vulas.core.instr.blacklist.jars\" vulas.core.instr.blacklist.jars.custom = # User-provided Java packages whose constructs are not instrumented (multiple ones to be separated by comma) # Default: - # Note: Those are on top of \"vulas.core.instr.blacklist.classes.jre\" and \"vulas.core.instr.blacklist.classes\" vulas.core.instr.blacklist.classes.custom = # If true, bytecode and instrumentation code will be written to tmpDir vulas.core.instr.writeCode = false # JARs for which no traces and no archive information will be uploaded (e.g., from Eclipse Steady itself) # Multiple entries are separated by comma, each entry is a regex vulas.core.monitor.blacklist.jars = lang-java-.*\\.jar,vulas-core-.*\\.jar,surefire-.*\\.jar,junit-.*\\.jar,org.jacoco.agent.*\\.jar # Enables or disables the periodic upload of collected traces to the backend # Default: true # Note: Set to FALSE in case of JUnit tests vulas.core.monitor.periodicUpload.enabled = true # Interval (in millisecs) between periodic uploads # Default: 300000 (5 min) vulas.core.monitor.periodicUpload.interval = 300000 # Max. number of traces uploaded by each periodic upload # Default: 1000 vulas.core.monitor.periodicUpload.batchSize = 1000 # Max number of items (traces, paths, touch points, etc.) collected # Default: -1 (no limit) vulas.core.monitor.maxItems = -1 Dynamic instrumentation (JVM) \u00b6 Objective \u00b6 Collect method traces during the actual execution of the application. Information about traced methods will be compared with methods subject to known vulnerabilities. Limitations \u00b6 Python is not supported Result \u00b6 Same as in previous section How does it work \u00b6 By registering a Java agent at JVM startup, Eclipse Steady changes the bytecode of every Java class loaded at runtime. For example, it injects Java statements in order to save the timestamp of every method invocation as well as stack trace information. This information is periodically uploaded to the Eclipse Steady backend. Run as follows \u00b6 Download the file lang-java-3.2.2-jar-with-dependencies.jar to your computer (CLI users can take it from the folder ./instr ). Add the following arguments to the Java runtime (and replace line breaks by a single space characters). -javaagent:lang-java-3.2.2-jar-with-dependencies.jar -Dvulas.shared.backend.serviceUrl=http://localhost:8033/backend/ -Dvulas.core.backendConnection=READ_WRITE -Dvulas.core.monitor.periodicUpload.enabled=true -Dvulas.core.appContext.group=<GROUP> -Dvulas.core.appContext.artifact=<ARTIFACT> -Dvulas.core.appContext.version=<VERSION> -Dvulas.core.instr.instrumentorsChoosen=org.eclipse.steady.java.monitor.trace.SingleTraceInstrumentor -Dvulas.core.space.token=<WORKSPACE-TOKEN> -noverify Start the application and perform some application-specific tests and workflows. Example \u00b6 In case of Tomcat 8.x, one needs to (1) copy lang-java-3.2.2-jar-with-dependencies.jar into the folder ./bin and (2) specify the variable CATALINA_OPTS as follows in the file ./bin/setenv.bat . Do not forget to specify <GROUP> , <ARTIFACT> , <VERSION> and <WORKSPACE-TOKEN> for the application under analysis. Note: The use of setenv.bat does not work if Tomcat is run as Windows service. CLI set \"CATALINA_OPTS=-javaagent:lang-java-3.2.2-jar-with-dependencies.jar -Dvulas.shared.backend.serviceUrl=http://localhost:8033/backend/-Dvulas.core.backendConnection=READ_WRITE -Dvulas.core.monitor.periodicUpload.enabled=true -Dvulas.core.appContext.group=<GROUP> -Dvulas.core.appContext.artifact=<ARTIFACT> -Dvulas.core.appContext.version=<VERSION> -Dvulas.core.instr.instrumentorsChoosen=org.eclipse.steady.java.monitor.trace.SingleTraceInstrumentor -Dvulas.core.space.token=<WORKSPACE-TOKEN> -noverify\" Static instrumentation (instr) \u00b6 Objective \u00b6 Modify an existing JAR (WAR) created by mvn package so that traces will be collected once the JAR is executed (the WAR is deployed in a Web application container such as Tomcat). Note: In contrast to what is described in the previous section \"Integration Tests\", steady:instr will not result in the collection of traces for Tomcat itself. Prerequisite \u00b6 An application's JAR or WAR, e.g., as created with mvn package in folder target . Limitations \u00b6 Python is not supported Result \u00b6 A new JAR/WAR with suffix -vulas-instr will be created in folder target/vulas/target . How does it work \u00b6 The bytecode of all the Java classes found in the JAR (WAR) will be modified as to collect information about, for instance, method execution and stack traces. This information will be uploaded to the backend if the JAR (WAR) is executed. Note: The modified code in the new JAR with suffix -vulas-instr can be inspected with decompilers such as JD-GUI . Run as follows \u00b6 Maven mvn package mvn -Dsteady steady:instr Troubleshooting \u00b6 The console shows compilation errors, e.g., cannot find javax.servlet.http.HttpServletRequest . The reason is that all application dependencies are re-compiled, and it can happen that some of the classes do have dependency requirements not met by the application. This can be overcome by identifying the respective JAR file and downloading it to the folder target/vulas/lib . Reachable from traces (t2c) \u00b6 Objective \u00b6 Understand whether vulnerable methods can be potentially reached from traced methods. Prerequisite \u00b6 Traces must have been collected during JUnit or integration tests (see above) Limitations \u00b6 Python is not supported Java 9 and later versions are not supported by the underlying frameworks Result \u00b6 In the Eclipse Steady frontend, tab \"Vulnerabilities\", the column \"Static Analysis\" is populated for all libraries subject to known vulnerabilities. By selecting single row of this table and the one of the detailed page, one can get more information up until the paths of potential executions (if any). How does it work \u00b6 In contrast to the goal a2c , the callgraph is built starting from all methods that were previously traced. As such, the call graph construction overcomes weaknesses of static source analysis related to the use of reflection and control inversion. What remains the same is that the resulting graph is traversed in order to see whether and from where methods with known vulnerabilities can be reached. Run as follows \u00b6 CLI java -jar steady-cli-3.2.2-jar-with-dependencies.jar -goal t2c Maven mvn -Dsteady steady:t2c Configure as follows \u00b6 # Limits the analysis to certain bugs (multiple values separated by comma) # If empty, all relevant bugs retrieved from backend will be considered # Default: empty vulas.reach.bugs = # Analysis framework to be used # Possible values: wala, soot vulas.reach.fwk = wala # Regex to filter entry points (semicolon separated) vulas.reach.constructFilter = # All packages to be excluded from call graph construction, packages # are separated by semicolon e.g. [java/.*;sun/.*]. Defaults for the different # analysis frameworks are provided in the respective configuration files. --> vulas.reach.excludePackages = # All JAR files to be excluded from call graph construction (multiple entries to be separated by comma) # # Default: WebServicesAgent.jar (from Wily Introscope, an app perf monitoring tool that has invalid manifest header fields creating problems for Wala) vulas.reach.excludeJars = WebServicesAgent.jar # Dir to search for app source files (only steady:a2c) # If empty, they will be fetched from backend vulas.reach.sourceDir = # Timeout for reachability analysis (in mins) # Default: 120 mins vulas.reach.timeout = 120 # Max number of paths uploaded for a reachable change list element vulas.reach.maxPathPerChangeListElement = 10 # Whether or not to collect touch points # Default: true vulas.reach.identifyTouchpoints = true # Whether to search for the shortest path(s) from entry points to vulnerable constructs, or to quit after the first path found # Default: true vulas.reach.searchShortest = true Analyze unconfirmed vulnerabilities (checkcode) \u00b6 Objective \u00b6 Downloads unconfirmed vulnerable dependencies (appearing as orange hourglasses in the report and application frontend) and analyze each dependency to determine whether they contain the vulnerable or fixed code. This is done by constructing the Abstract Syntax Tree (AST) of the constructs changed to fix the vulnerability, and comparing it with the AST(s) build from the bytecode of artifacts known to be vulnerable or fixed (as a result of other evaluation strategies). Result \u00b6 In case of equalities to either vulnerable/fixed code, affected libraries are uploaded to the backend, thereby resolving the unconfirmed vulnerabilities (orange hourglasses will turn either red or green). Run as follows \u00b6 vulas.shared.cia.serviceUrl must be set. CLI java -jar steady-cli-3.2.2-jar-with-dependencies.jar -goal checkcode Maven mvn -Dsteady steady:checkcode Upload analysis files (upload) \u00b6 Objective \u00b6 Uploads analysis data in folder vulas.core.uploadDir to the backend. Such data is only written if the parameter vulas.core.backendConnection is set to OFFLINE or READ_ONLY . By default, this is only the case for the instrumentation of JUnit or integration tests. Configure as follows \u00b6 # When true, serialized HTTP requests will be deleted after the upload succeeded (incl. the JSON files) # Default: true vulas.core.upload.deleteAfterSuccess = true # Maximum size of *.json files (in bytes) that will be considered for upload. # Default: -1 (no limit) vulas.core.upload.maxSize = -1 Run as follows \u00b6 CLI java -Dvulas.core.appContext.group = <GROUP> -Dvulas.core.appContext.artifact = <ARTIFACT> -Dvulas.core.appContext.version = 3 .2.2 -jar steady-cli-3.2.2-jar-with-dependencies.jar -goal upload Maven mvn -Dsteady steady:upload Create result report (report) \u00b6 Objective \u00b6 Creates result reports in HTML, XML and JSON format (on the basis of analysis results downloaded from the Eclipse Steady backend). Additionally, the Maven and Gradle plugins can be configured to throw a build exception in order break Jenkins jobs and pipelines in case vulnerable code is present (or reachable/executed). The HTML report can be copied into a Jenkins dashboard using the HTML Publisher Plugin (see automation for a configuration example). Multi-module Maven projects \u00b6 The report goal should be called in a separate build step, e.g., mvn -Dsteady steady:report . It must NOT be called together with other goals, e.g., mvn -Dsteady compile steady:app steady:report , because the build may fail before app and other goals are executed for all the modules. Alternatively, you can use the Maven option --fail-at-end (see here for more info). Result \u00b6 A summary report is written to disk (in HTML, XML and JSON format). For Maven, the target directory of the different files is \"target/vulas/report\", for Gradle it is \"build/vulas/report\". For CLI, the exact location is printed to the console. How does it work \u00b6 Identified vulnerabilities including any information gathered during static and dynamic analysis will be downloaded from the backend. Configure as follows \u00b6 # Exempts the given vulnerability from causing a build exception # This can apply to all libraries including the vulnerable code (by omitting `libraries` or explicitely specifying `*`) # or to selected libraries with the given digest(s). # # Default: - vulas.report.exemptBug.<vuln-id>.reason = <reason> vulas.report.exemptBug.<vuln-id>.libraries = [ * | digest [, digest] ] # A vulnerability in exempted scopes will not cause an exception (multiple scopes to be separated by comma) # # Default: test, provided # Note: For CLI, all dependencies are considered as RUNTIME dependencies vulas.report.exemptScope = TEST, PROVIDED # Determines whether un-assessed vulnerabilities (e.g. vulnerabilities marked with an orange hourglass symbol) throw a build exception. Un-assessed vulns are those where # the method signature(s) of a bug appear in an archive, however, it is yet unclear whether the methods # exist in the fixed or vulnerable version. Those findings are marked with a question mark in the frontend. # # Possible values: # all: All un-assessed vulns will be ignored # known: Only un-assessed vulns in archives known to Maven Central will be ignored # off: Never ignore # # Default: all vulas.report.exceptionExcludeUnassessed = all # Specifies whether a build exception is thrown when vulnerable code is included, potentially # reachable, actually reached or not at all # Possible values: noException < dependsOn < potentiallyExecutes < actuallyExecutes # noException : no build exception even if vulnerable code is included # dependsOn : exception raised when vulnerable code is included # potentiallyExecutes : exception raised when vulnerable code is potentially executed (result of static analyse) # actuallyExecutes : exception raised when vulnerable code is executed (result of dynamic analyse) # # Default: dependsOn vulas.report.exceptionThreshold = dependsOn # Directory to where the reports (JSON, XML, HTML) will be written to # Default: # CLI: - # MVN: ${project.build.directory}/vulas/report vulas.report.reportDir = # If true, a CURL command will be printed to the console for all exempted findings in order to permanently mark # a given library as non-vulnerable, independent of the specific application. # Default: false # Note: The scope of this assessment is beyond a specific application, hence, the CURL command requires a security token. vulas.report.createLibraryAssessments = Run as follows \u00b6 CLI java -Dvulas.core.appContext.group = <GROUP> -Dvulas.core.appContext.artifact = <ARTIFACT> -Dvulas.core.appContext.version = <VERSION> -jar steady-cli-3.2.2-jar-with-dependencies.jar -goal report Maven mvn -Dsteady steady:report Gradle ./gradlew vulasReport Exemptions \u00b6 The setting vulas.report.exemptBug.<vuln-id>.reason can be used to capture the results of an audit or assessment by developers in regards to whether a vulnerability is problematic in a given application context. Exempted bugs do not result in build exceptions, but are still shown in both the report and the apps Web frontend. Build exceptions \u00b6 Other settings to fine-tune the threshold for build exceptions are as follows: vulas.report.exemptScope can be used to exclude certain Maven scopes (default: test) vulas.report.exceptionThreshold can be used to specify whether a build exception is thrown when vulnerable code is included, potentially reachable, actually reached or not at all (values: noException , dependsOn , potentiallyExecutes , actuallyExecutes ; default: actuallyExecutes ) Clean and delete apps (clean) \u00b6 Objective \u00b6 Deletes application-specific data in the backend, e.g., traces collected during JUnit tests, application constructs and dependencies collected through the app goal. Right after executing clean for a given application, the apps Web frontend will be empty for the respective application. Run as follows to clean the current version , e.g., the version specified in pom.xml (Maven) or steady-custom.properties (CLI): CLI java -jar steady-cli-3.2.2-jar-with-dependencies.jar -goal clean Maven mvn -Dsteady steady:clean Configure as follows \u00b6 The following options can be used to delete multiple versions . Important: In this case, only the creation date of application versions (in the backend) is considered to select the versions to be deleted. Versions specified in pom.xml , steady-custom.properties etc. are not considered at all. # When true, all but the latest X app versions will be deleted (latest according to the application creation date). # The value of X is configured with the option 'vulas.core.clean.purgeVersions.keepLast', see below. # Default: false vulas.core.clean.purgeVersions = false # Specifies X, i.e., the number of application versions to be kept if purgeVersions is set to true. # Set this to 0 to delete all versions. # Default: 3 vulas.core.clean.purgeVersions.keepLast = 3 # When true, the history of past goal executions will be deleted (NOTE: this does not delete the scan results themselves! # you may want to use the two directives above to purge scan results.) # The default value is recommended, in normal scenarios you should leave this to false. # Default: false vulas.core.clean.goalHistory = false Run as follows to delete all versions : CLI java -Dvulas.core.clean.purgeVersions = true -Dvulas.core.clean.purgeVersions.keepLast = 0 -jar steady-cli-3.2.2-jar-with-dependencies.jar -goal clean Maven mvn -Dsteady -Dvulas.core.clean.purgeVersions = true -Dvulas.core.clean.purgeVersions.keepLast = 0 steady:clean Troubleshooting \u00b6 The Maven plugin will fail to delete an application if a corresponding <module> does not exit any longer in the pom.xml . The CLI must be used in these cases and the Maven coordinates (GAV) of the item to be cleaned shall be provided as system properties when calling the CLI. For example, if you want to delete an application with GAV myGroup:myArtifact:myVersion , the following command line can be used java -Dvulas.core.appContext.group = myGroup -Dvulas.core.appContext.artifact = myArtifact -Dvulas.core.appContext.version = myVersion -jar steady-cli-3.2.2-jar-with-dependencies.jar -goal clean Clean workspaces (cleanspace) \u00b6 Objective \u00b6 Deletes all applications of the given space. Run as follows \u00b6 CLI java -jar steady-cli-3.2.2-jar-with-dependencies.jar -goal cleanSpace Maven mvn -Dsteady steady:cleanSpace","title":"Analysis"},{"location":"user/manuals/analysis/#analysis-manual","text":"","title":"Analysis Manual"},{"location":"user/manuals/analysis/#overview","text":"The various client-side tools offer so-called goals in order to analyze applications and interact with the backend. The following goals perform some sort of application analysis: app : Creates a method-level bill of material of an application and all its dependencies. a2c : Builds a call graph (starting from app methods) and checks whether vulnerable code is potentially executable (reachable). test : This is not an actual goal implemented by any of the clients, but describes the collection of execution traces by a so-called Java agent that dynamically instruments Java bytecode during JUnit and integration tests. instr : Produces a modified version of Java archives ( static instrumentation ) that can be deployed/executed in order to collect traces of actual method executions. t2c : Builds a call graph (starting from traced methods) and checks whether vulnerable code is potentially reachable from those. checkcode Downloads unconfirmed vulnerabilities from the backend to the client, and checks whether the affected dependencies contain vulnerable of fixed constructs. The following goals are related to data management and reporting: upload : Uploads analysis data previously written to disk to the backend report : Downloads analysis data from the backend to the client, produces a result report (HTML, XML, JSON), and throws a build exception in order to break Jenkins jobs clean : Cleans the analysis data of a single app in the backend cleanspace : Cleans an entire workspace in the backend Which goals are supported by the different clients, and how-to configure and execute them is explained in the following subsections. Note that all goal executions (including configuration settings and statistics) are shown on the \"History\" tab of the respective applications. Important: Make sure to understand the following before proceeding: app has to be executed before all the other analysis goals in order to detect all application dependencies with vulnerable code. Once it has been run, the assessment of findings can already start, each finding of app shown on the \"Vulnerabilities\" tab corresponds to a dependency of an application on a component with a known security vulnerability. The number of findings will not change when running other analysis goals. Instead, a2c , test and t2c try to collect evidence concerning the potential or actual execution of vulnerable code brought up by app . Assess every finding, no matter whether a2c , test and t2c were able to collect evidence or not. Not finding such evidence does not mean that vulnerabilities cannot be exploited. The absence of proof is not a proof of absence (of exploitable vulnerabilities). Prerequisites: A workspace has been created and its token is known Java 7 or later is installed Maven: The plugin is available in the local .m2 repository or in a Nexus repository configured in settings.xml (see here for more information on how to configure Maven) Limitations : The reachability analysis (goals a2c and t2c ) does not work with Java 9, as the underlying analysis frameworks do not support it. Prerequisites A workspace has been created and its token is known Java 7 or later is installed Maven: The Eclipse Steady Maven plugin must be available in the local .m2 repository or in a Nexus repository configured in settings.xml (see here for more information on how to configure Maven) Java 9 support The reachability analysis (goals a2c and t2c ) is not supported with Java 9, due to limitations of the 3 rd -party analysis frameworks that Eclipse Steady relies upon.","title":"Overview"},{"location":"user/manuals/analysis/#bill-of-material-analysis-app","text":"","title":"Bill of material analysis (app)"},{"location":"user/manuals/analysis/#reachable-from-app-a2c","text":"","title":"Reachable from app (a2c)"},{"location":"user/manuals/analysis/#dynamic-instrumentation-junit","text":"","title":"Dynamic instrumentation (JUnit)"},{"location":"user/manuals/analysis/#dynamic-instrumentation-jvm","text":"","title":"Dynamic instrumentation (JVM)"},{"location":"user/manuals/analysis/#static-instrumentation-instr","text":"","title":"Static instrumentation (instr)"},{"location":"user/manuals/analysis/#reachable-from-traces-t2c","text":"","title":"Reachable from traces (t2c)"},{"location":"user/manuals/analysis/#analyze-unconfirmed-vulnerabilities-checkcode","text":"","title":"Analyze unconfirmed vulnerabilities (checkcode)"},{"location":"user/manuals/analysis/#upload-analysis-files-upload","text":"","title":"Upload analysis files (upload)"},{"location":"user/manuals/analysis/#create-result-report-report","text":"","title":"Create result report (report)"},{"location":"user/manuals/analysis/#clean-and-delete-apps-clean","text":"","title":"Clean and delete apps (clean)"},{"location":"user/manuals/analysis/#clean-workspaces-cleanspace","text":"","title":"Clean workspaces (cleanspace)"},{"location":"user/manuals/assess_and_mitigate/","text":"Impact Assessment and Mitigation \u00b6 The presence of vulnerable open-source code must be assessed . If the vulnerability IS NOT considered exploitable, it can be exempted . If it IS considered exploitable, it has to be mitigated . Assess \u00b6 You can start to assess Eclipse Steady findings as soon as you ran the app analysis goal. Assessing means to clarify whether the respective vulnerability is exploitable in the given application context. The other analysis goals provide further evidence in regards to whether vulnerable code is executable, which is a prerequisite for being exploitable, but they do not bring up new findings. A finding (table row) in the Vulnerabilities tab represents a tuple (library, vulnerability). Depending on whether the library contains the vulnerable or the fixed code , the column Inclusion of vulnerable code contains one of the following icons: Green exclamation mark : The library version in use contains the fixed code for the respective vulnerability, hence, is not affected. Such historical vulnerabilities do not need to be assessed and mitigated. Red exclamation mark : The library version in use contains the vulnerable code, hence, is affected by the respective vulnerability, and the finding requires assessment. A findings should be mitigated if considered exploitable (see below). A finding can be exempted if it is not considered exploitable. Orange Hourglass : It is unclear whether the library version in use contains the vulnerable or the fixed code. Hourglasses may be resolved with the checkcode goal . Otherwise they are resolved by the Eclipse Steady operations team (automatically or manually) by comparing the source or byte code of the library in question with the vulnerable and fixed code. Depending on whether the source or byte code of the library is available, e.g., in Maven Central or PyPi, this can take more or less time. Static and Dynamic Analysis \u00b6 The columns Static Analysis and Dynamic Analysis provide information whether vulnerable code can be potentially executed (according to static call graph construction and analysis), or whether its execution has been observed during the execution of tests. Warning You cannot simply ignore a vulnerability just because no red icon is shown. In other words: We suggest to always look at all vulnerabilities, regardless of whether there are indicators in those two columns. The main reasons are: Deserialization vulnerabilities , whose exploitation does not require that vulnerable code is executed during normal program execution, and the fact that both static and dynamic analyses can also be subject to false-positives and false-negatives. Dependency scope \u00b6 Make sure to understand this important Maven concept, refer to the official documentation for details. Typically, TEST and PROVIDED dependencies are not bundled with your application. In other words, when you or your customers deploy the application, libraries in scope TEST and PROVIDED are not included, therefore, vulnerabilities in these dependencies are less critical for you than those in other scopes (the party operating the platform should address them). Direct vs. transitive dependencies \u00b6 You need to assess vulnerabilities regardless of whether they concern direct or transitive dependencies. The reason is that the exploitability of a vulnerability is independent of this aspect. CVSS score \u00b6 All vulnerabilities shall be assessed, no matter the CVSS score. The severity of open-source vulnerabilities significantly depends on the application-specific context (in which the open-source component is used). Thus, the actual severity can differ significantly from the (context-independent) CVSS base score provided by 3 rd parties such as the Mitre/NVD. Exempt \u00b6 If vulnerable code is NOT considered exploitable in a given application context, the respective finding (or an entire scope) can be exempted. This can be done by specifying additional configuration settings, preferably in a dedicated properties file (e.g., steady-exemptions.properties ). Keeping exemptions in a dedicated file avoids the risk of making accidental changes to other settings. Storing such a dedicated file in the source code repository of the application under analysis, thus making the file subject to version control, has the advantage of tracking modifications in terms of date and author. The settings required to create exemptions are described in the section report goal . Mitigate \u00b6 If vulnerable code is considered exploitable in a given application context, there are several ways to fix the dependency on the vulnerable open-source component: Remove dependency (ideal) \u00b6 If possible, removing a dependency from your application is the ideal solution. It will not only avoid the dependency on a given library with known vulnerabilities but also reduce (a) the size of your application's deployable artifact and (b) the application's attack surface. The analysis goals a2c , test and t2c can support you in assessing whether or not the removal is possible at all. Running those goals will populate the 2 right-most columns of the table in the Dependencies tab, hence, you will see whether library constructs are potentially executable or actually executed. Direct dependencies can be removed by deleting the respective <dependency> section. Transitive dependencies can be removed by adding an <exclusions> section to the respective direct <dependency> (s), cf. Dependency Exclusions for more details. Update dependency (default) \u00b6 An update is the default solution for fixing a dependency with known-vulnerabilities. It is possible for the majority of vulnerabilities in the Eclipse Steady Vulnerability Database. Direct dependencies can be updated by declaring a non-vulnerable version in the respective <dependency> section. Transitive dependencies can be updated by two means: Preferably, by updating the direct <dependency> that is responsible for pulling the vulnerable transitive dependency into your project. Use mvn dependency:tree or the IDE of your choice to identify this to-be-updated direct dependency (cf. screenshot, where the transitive dependency ognl:3.0.6 is pulled in through the direct dependency struts2-core:2.3.24 into the application vulas-testapp-webapp:2.3.8). If there's no updated version of the direct dependency available that solves the problem, you need to declare a direct <dependency> on a non-vulnerable version. This will override the version resulting from the use of the direct dependency. However, as this solution breaks the transparency of the dependency resolution mechanism, it is advisable to add a corresponding comment to your pom.xml or build.gradle and revisit the dependency every now and then. Sometimes, the vulnerable dependency is pulled into your project through a component developed by colleagues. In this case, please ask your colleagues to provide a fixed version that avoids pulling in vulnerable open-source. Like this, every other user of the respective component will be able to solve the problem by a simple update. Fixing the library (exceptional) \u00b6 Best practice This should only be done if the removal or update of the dependency is not possible. Fixing the library means to create a fix for the vulnerability within the source code of the open-source library, which requires a deep understanding of the respective library and vulnerability. If you take that road, make sure to create a pull request so that the original open-source developers check and integrate the fix in the standard. If not, you will need to maintain your fix in the forked version of the library, and any further enhancements of the library will need to be merged into this fork. Special case: Uber JARs So-called Uber JARs are one example where the removal or update of a vulnerable dependency is not easily possible. Such Java archives do not only contain the Java classes of the respective component, but also contain (rebundle) the Java classes of its dependencies. Uber JARs enable the distribution of self-contained \"all-in-one\" Java archives. In order to fix such Uber JARs, one has to clone the source code repository of the respective open source component, fix the version of the dependency whose classes will be included in the Uber JAR, and build the component in order to produce a new, fixed Uber JAR of the component containing the non-vulnerable classes of its dependency. Example: The Java component org.springframework.cloud:spring-cloud-cloudfoundry-connector rebundles jackson-databind . In case the latest version of spring-cloud-cloudfoundry-connector contains a vulnerable version of jackson-databind , one has to clone https://github.com/spring-cloud/spring-cloud-connectors/tree/master/spring-cloud-cloudfoundry-connector , edit build.gradle in order to update the version of jackson-databind , and build a fixed Uber JAR to be used by the application. Important : If you create a fix yourself, make sure to contribute such fixes to the original open source project. Fixing the application (exceptional) \u00b6 Best practice This should only be done if the removal or update of the dependency is not possible. Fixing the applications means to introduce a security control in the application that mitigates a problem in a vulnerable library, which requires a deep understanding of the respective vulnerability. Example: Suppose the library in question is vulnerable to XXE processing . If the developers of the respective library do not (cannot) provide a fix, you could introduce a corresponding sanity check in your application, just before XML documents are handed-over to the library. The analysis goals a2c , test and t2c can support you in identifying the application methods that require a safeguard. Ideally, you can see (a subset of) the execution paths that lead from application code to vulnerable library code. See here to learn about the configuration options of the reachability analyses a2c and t2c .","title":"Impact Assessment and Mitigation"},{"location":"user/manuals/assess_and_mitigate/#impact-assessment-and-mitigation","text":"The presence of vulnerable open-source code must be assessed . If the vulnerability IS NOT considered exploitable, it can be exempted . If it IS considered exploitable, it has to be mitigated .","title":"Impact Assessment and Mitigation"},{"location":"user/manuals/assess_and_mitigate/#assess","text":"You can start to assess Eclipse Steady findings as soon as you ran the app analysis goal. Assessing means to clarify whether the respective vulnerability is exploitable in the given application context. The other analysis goals provide further evidence in regards to whether vulnerable code is executable, which is a prerequisite for being exploitable, but they do not bring up new findings. A finding (table row) in the Vulnerabilities tab represents a tuple (library, vulnerability). Depending on whether the library contains the vulnerable or the fixed code , the column Inclusion of vulnerable code contains one of the following icons: Green exclamation mark : The library version in use contains the fixed code for the respective vulnerability, hence, is not affected. Such historical vulnerabilities do not need to be assessed and mitigated. Red exclamation mark : The library version in use contains the vulnerable code, hence, is affected by the respective vulnerability, and the finding requires assessment. A findings should be mitigated if considered exploitable (see below). A finding can be exempted if it is not considered exploitable. Orange Hourglass : It is unclear whether the library version in use contains the vulnerable or the fixed code. Hourglasses may be resolved with the checkcode goal . Otherwise they are resolved by the Eclipse Steady operations team (automatically or manually) by comparing the source or byte code of the library in question with the vulnerable and fixed code. Depending on whether the source or byte code of the library is available, e.g., in Maven Central or PyPi, this can take more or less time.","title":"Assess"},{"location":"user/manuals/assess_and_mitigate/#static-and-dynamic-analysis","text":"The columns Static Analysis and Dynamic Analysis provide information whether vulnerable code can be potentially executed (according to static call graph construction and analysis), or whether its execution has been observed during the execution of tests. Warning You cannot simply ignore a vulnerability just because no red icon is shown. In other words: We suggest to always look at all vulnerabilities, regardless of whether there are indicators in those two columns. The main reasons are: Deserialization vulnerabilities , whose exploitation does not require that vulnerable code is executed during normal program execution, and the fact that both static and dynamic analyses can also be subject to false-positives and false-negatives.","title":"Static and Dynamic Analysis"},{"location":"user/manuals/assess_and_mitigate/#dependency-scope","text":"Make sure to understand this important Maven concept, refer to the official documentation for details. Typically, TEST and PROVIDED dependencies are not bundled with your application. In other words, when you or your customers deploy the application, libraries in scope TEST and PROVIDED are not included, therefore, vulnerabilities in these dependencies are less critical for you than those in other scopes (the party operating the platform should address them).","title":"Dependency scope"},{"location":"user/manuals/assess_and_mitigate/#direct-vs-transitive-dependencies","text":"You need to assess vulnerabilities regardless of whether they concern direct or transitive dependencies. The reason is that the exploitability of a vulnerability is independent of this aspect.","title":"Direct vs. transitive dependencies"},{"location":"user/manuals/assess_and_mitigate/#cvss-score","text":"All vulnerabilities shall be assessed, no matter the CVSS score. The severity of open-source vulnerabilities significantly depends on the application-specific context (in which the open-source component is used). Thus, the actual severity can differ significantly from the (context-independent) CVSS base score provided by 3 rd parties such as the Mitre/NVD.","title":"CVSS score"},{"location":"user/manuals/assess_and_mitigate/#exempt","text":"If vulnerable code is NOT considered exploitable in a given application context, the respective finding (or an entire scope) can be exempted. This can be done by specifying additional configuration settings, preferably in a dedicated properties file (e.g., steady-exemptions.properties ). Keeping exemptions in a dedicated file avoids the risk of making accidental changes to other settings. Storing such a dedicated file in the source code repository of the application under analysis, thus making the file subject to version control, has the advantage of tracking modifications in terms of date and author. The settings required to create exemptions are described in the section report goal .","title":"Exempt"},{"location":"user/manuals/assess_and_mitigate/#mitigate","text":"If vulnerable code is considered exploitable in a given application context, there are several ways to fix the dependency on the vulnerable open-source component:","title":"Mitigate"},{"location":"user/manuals/assess_and_mitigate/#remove-dependency-ideal","text":"If possible, removing a dependency from your application is the ideal solution. It will not only avoid the dependency on a given library with known vulnerabilities but also reduce (a) the size of your application's deployable artifact and (b) the application's attack surface. The analysis goals a2c , test and t2c can support you in assessing whether or not the removal is possible at all. Running those goals will populate the 2 right-most columns of the table in the Dependencies tab, hence, you will see whether library constructs are potentially executable or actually executed. Direct dependencies can be removed by deleting the respective <dependency> section. Transitive dependencies can be removed by adding an <exclusions> section to the respective direct <dependency> (s), cf. Dependency Exclusions for more details.","title":"Remove dependency (ideal)"},{"location":"user/manuals/assess_and_mitigate/#update-dependency-default","text":"An update is the default solution for fixing a dependency with known-vulnerabilities. It is possible for the majority of vulnerabilities in the Eclipse Steady Vulnerability Database. Direct dependencies can be updated by declaring a non-vulnerable version in the respective <dependency> section. Transitive dependencies can be updated by two means: Preferably, by updating the direct <dependency> that is responsible for pulling the vulnerable transitive dependency into your project. Use mvn dependency:tree or the IDE of your choice to identify this to-be-updated direct dependency (cf. screenshot, where the transitive dependency ognl:3.0.6 is pulled in through the direct dependency struts2-core:2.3.24 into the application vulas-testapp-webapp:2.3.8). If there's no updated version of the direct dependency available that solves the problem, you need to declare a direct <dependency> on a non-vulnerable version. This will override the version resulting from the use of the direct dependency. However, as this solution breaks the transparency of the dependency resolution mechanism, it is advisable to add a corresponding comment to your pom.xml or build.gradle and revisit the dependency every now and then. Sometimes, the vulnerable dependency is pulled into your project through a component developed by colleagues. In this case, please ask your colleagues to provide a fixed version that avoids pulling in vulnerable open-source. Like this, every other user of the respective component will be able to solve the problem by a simple update.","title":"Update dependency (default)"},{"location":"user/manuals/assess_and_mitigate/#fixing-the-library-exceptional","text":"Best practice This should only be done if the removal or update of the dependency is not possible. Fixing the library means to create a fix for the vulnerability within the source code of the open-source library, which requires a deep understanding of the respective library and vulnerability. If you take that road, make sure to create a pull request so that the original open-source developers check and integrate the fix in the standard. If not, you will need to maintain your fix in the forked version of the library, and any further enhancements of the library will need to be merged into this fork. Special case: Uber JARs So-called Uber JARs are one example where the removal or update of a vulnerable dependency is not easily possible. Such Java archives do not only contain the Java classes of the respective component, but also contain (rebundle) the Java classes of its dependencies. Uber JARs enable the distribution of self-contained \"all-in-one\" Java archives. In order to fix such Uber JARs, one has to clone the source code repository of the respective open source component, fix the version of the dependency whose classes will be included in the Uber JAR, and build the component in order to produce a new, fixed Uber JAR of the component containing the non-vulnerable classes of its dependency. Example: The Java component org.springframework.cloud:spring-cloud-cloudfoundry-connector rebundles jackson-databind . In case the latest version of spring-cloud-cloudfoundry-connector contains a vulnerable version of jackson-databind , one has to clone https://github.com/spring-cloud/spring-cloud-connectors/tree/master/spring-cloud-cloudfoundry-connector , edit build.gradle in order to update the version of jackson-databind , and build a fixed Uber JAR to be used by the application. Important : If you create a fix yourself, make sure to contribute such fixes to the original open source project.","title":"Fixing the library (exceptional)"},{"location":"user/manuals/assess_and_mitigate/#fixing-the-application-exceptional","text":"Best practice This should only be done if the removal or update of the dependency is not possible. Fixing the applications means to introduce a security control in the application that mitigates a problem in a vulnerable library, which requires a deep understanding of the respective vulnerability. Example: Suppose the library in question is vulnerable to XXE processing . If the developers of the respective library do not (cannot) provide a fix, you could introduce a corresponding sanity check in your application, just before XML documents are handed-over to the library. The analysis goals a2c , test and t2c can support you in identifying the application methods that require a safeguard. Ideally, you can see (a subset of) the execution paths that lead from application code to vulnerable library code. See here to learn about the configuration options of the reachability analyses a2c and t2c .","title":"Fixing the application (exceptional)"},{"location":"user/manuals/frontend/","text":"Frontend Manual \u00b6 This guide describe the different views of the apps Web frontend. The sections describing each view can be reached by following the ? icon in the top-right corner of the frontend view itself. Start page \u00b6 The start page is displayed when opening the URL of the Eclipse Steady Web Frontend (usually following a link looking like http://localhost:8033/apps ) in the browser: The table displayed on the left contains a subset of the applications analyzed by Eclipse Steady. Each application is identified by a triple (group, artifact, version), but only artifact and version are shown in the table. When selecting an application, the analysis results will be displayed on the right. In case your application is not shown, use the search field on top of the table. It can be used for filtering all applications whose group, artifact or version match the provided search string. Other UI controls highlighted in the screenshot are as follows: Control Description 1 Home Reloads the entire application, no application will be shown on the right 2 Redo Search Re-applies the search criterion 3 Information Information messages to the attention of the user 4 Workspace Identifier of the current workspace - Displayed with Gray background if default workspace and with red background otherwise 5 About Provides information about the application such as version, authors, etc. 6 Help Opens this Wiki page 7 Documentation Provides a link to the Documentation 8 Workspace Creation Tools to create a new workspace 9 Settings Provides the possibility to connect to another backend for loading application analyses (expert user only) and to select a workspace to display 10 Reload Reloads all the applications (use if you want to see the analysis results of an application that did not exist before) Vulnerabilities \u00b6 Objective of view: Provide an overview about vulnerable Open-Source dependencies of an application, together with the information whether vulnerable code of such dependencies (e.g. methods) are potentially or actually executable in the context of the application. UI controls highlighted in the screenshot are as follows: 1 Reset table Removes filters and groups from the table 2 Reload data Reloads the app-specific analysis results from the database (use if you executed Eclipse Steady goals and want to see its analysis results in the frontend). 3 Toggle historical vulnerabilities Shows and hides the display of historical vulnerabilities, e.g., vulnerabilities that existed in a previous version of the archive. Note: Historical vulnerabilities do not require any action as they do not represent a threat to application security. Note: This option is taken into account after pressing the \"Reload Data\" button (see 2) 4 Toggle unconfirmed vulnerabilities Shows and hides the display of unconfirmed vulnerabilities, i.e. vulnerabilities which have not yet been confirmed by Eclipse Steady. Note: This option is taken into account after pressing the \"Reload Data\" button (see 2) 5 Help Link to the frontend vulnerabilities help page (e.g. this page) 6 Reload application data Objective of table: same as objective of view Data shown: Each row corresponds to a vulnerability in a dependency, e.g., multiple vulnerabilities in the same dependency appear in separate table rows. The three columns to the right show whether vulnerable code is included, whether it is potentially reachable or if it was actually reached (executed) at application runtime. Click on a row in order to open the vulnerability details view Data collected by goal(s): steady:app (to populate the table rows), steady:a2c and steady:t2c to populate the column 'Static Analysis', JUnit and Integration tests to populate the column 'Dynamic Analysis' Empty if: An application has no vulnerable dependencies or no dependencies at all Column Description Dependency Scope (Direct / Transitive) When using the Eclipse Steady Maven plugin, the scope corresponds to the Maven scope (see here for more information). Dependencies that are declared in the application's POM appear as 'direct' dependency, all others appear as \"transitive\". When using the Eclipse Steady CLI, the scope is always 'Runtime' and the dependency always appears as 'direct', since the CLI cannot derive this information from the JARs found in the file system. Archive Filename (SHA1) The filename of the library as found in the file system on which the analysis was run. The SHA1 is the unique identifier of libraries. It can happen that an application has multiple dependencies with the same filename but different SHA1. Vulnerability The identifier of the vulnerability, typically a CVE identifier as used in the NVD. The CVSS score is shown for all vulnerabilities present in the NVD (note that only CVSS v2 is supported), n/a for all others. Inclusion of vulnerable Code Indicates whether the dependency contains vulnerable code. The library version is confirmed to contain vulnerable code The library version is confirmed to contain fixed code (a so-called \"historical vulnerability\") It is unknown whether the library version contains the vulnerable or the fixed code. Note: The Eclipse Steady admin team will be automatically notified about such cases in order to take a decision Static Analysis: Potential execution of vulnerable code Indicates whether vulnerable code (e.g., methods) are potentially reachable (executable) according to the results of the static source code analysis (performed during steady:a2c and steady:t2c). Vulnerable code is potentially reachable, i.e., the application can be executed in such a way that the vulnerable code is reached. Note: In few cases, the vulnerable code of a given bug is not known. In those cases, this icon appears as soon as any code of the library is found reachable. Library code is reachable, i.e., part of the call graph, but none of the vulnerable code. No library reachable or reachability analysis not performed Dynamic Analysis: Actual execution of vulnerable Code Vulnerable code is executed Note: In few cases, the vulnerable code of a given bug is not known. In those cases, this icon appears as soon as any code of the library is executed. Library code is executed, but none of the vulnerable code No library code executed or no tests have been performed Vulnerabilities Details \u00b6 Objective of Page: Provide detailed information about the vulnerability, the source code repository of the Open-Source project and the constructs (e.g., methods) that have been touched by the Open-Source developers in order to fix the vulnerability. UI controls highlighted in the screenshot are as follows: Control Description 1 Help Link to the documentation page for Vulnerabilities Details (e.g. this page) 2 Exploit database Opens the search page of the Exploit Database in a new browser window, in order to let you search for exploits for the given vulnerability . Note: You need to manually complete the Captcha in order to start the search. 3 NVD (National Vulnerability Database) Opens a link with more vulnerability information in a new browser window. In most of the cases, it is a page from the NVD. 4 Google Trends Shows whether the given vulnerability was a popular Google search term (thus, received a lot of public interest) over the course of the last 30 days (click to see other time ranges). Objective of table: Provide information whether individual vulnerable constructs (methods or constructors) are contained in the respective library, and whether they are potentially or actually reachable. Data shown: All constructs (methods or constructors) that have been added, modified or deleted by the developers of the Open-Source library in order to fix the respective vulnerability. Data collected by goal(s): Table rows are taken from the bug database, which is maintained by the Eclipse Steady admin team. The three columns to the right are populated by steady:app (column 'Contained'), steady:a2c and steady:t2c (column 'Reachable'), as well as through the execution of tests (column 'Traced') Empty if: Vulnerabilities that have no known fix or whose fix concerns non-Java files, e.g., XML configuration files. The two right-most columns are empty if the goals steady:a2c or steady:t2c have not been executed, or if no tests have been performed Column Description Change Indicates whether the given construct has been ADDed, MODified or DELeted as part of the respective commit (revision) Revision Commit identifier Type Class or Constructor Qualified construct Name (Path) The fully qualified name of the construct, i.e., including package name, class name(s) and parameter types Example: com.acme.Foo$Bar.go(String) , whereby com.acme is a package, Foo and Bar classes and go(String) a method name including a String parameter Contained Indicates whether the respective construct is part of the Java archive or not Note: Very often, the commits of the Open-Source developers also contain changes to their JUnit test classes. Those classes are typically not contained in the released Java archive Reachable Indicates whether the respective construct is part of the call graph built during the Eclipse Steady goals a2c and t2c Click on the icon in order to see the actual call graph leading to the respective vulnerable code It is part of the call graph It is not part of the call graph (but others constructs of the archive are) No construct of the respective archive is part of the call graph Traced Indicates whether the respective construct has been executed during JUnit or integration tests Click on the icon in order to see the actual call graph leading to the respective vulnerable code It has been executed. In this case, the tooltip contains information about the timestamp of the execution, the number of calls and the goal identifier It has not been executed (but others constructs of the archive have been) No construct of the respective archive has been executed Vulnerable Code Call Graph \u00b6 Objective of graph: Provide information on paths leading to vulnerable methods Data shown: The vulnerable methods are shown as red nodes, while methods part of the application are shown as green nodes. Black edges result from the static source code analysis, while red edges have been collected during test execution. The fully qualified name of methods and constructors as well as archive information is shown when hovering over nodes. Data collected by goal(s): a2c and t2c (black edges), JUnit and integration tests (red edges) Empty if: No paths to vulnerable methods were found UI controls highlighted in the screenshot are as follows: Control Description 1 Collapse graph on library level Collapses all nodes representing methods of the same library into one node. 2 Collapse graph on package level Collapses all nodes representing methods of the same package into one node. 3 Collapse graph on class level Collapses all nodes representing methods of the same class into one node. 4 Expand all Shows the original graph. 5 Collapse nodes Collapses all nodes 6 Help/Documentation Opens the documentation to this page 7 NVD (National vulnerability Database) Opens the NVD for the respective vulnerability in a new browser window. Dependencies \u00b6 Objective of view: Provide an overview about all dependencies of the application, no matter whether they contain vulnerabilities or not Objective of table: Same as objective of view Data shown: All dependencies of the application. Click on a dependency's filename in order to open the dependencies details view Data collected by goal(s): steady:app and test Empty if: An application has no dependencies at all The content of the table can be detailed as follow: Details Description Archive Filename (SHA1) The filename of the library as found in the file system on which the analysis was run. The SHA1 is the unique identifier of libraries. It can happen that an application has multiple dependencies with the same filename but different SHA1. Dependency Scope When using the Eclipse Steady Maven plugin, the scope corresponds to the Maven scope (see here for more information). When using the Eclipse Steady CLI, the scope is always 'Runtime'. Direct / Transitive Direct dependencies are declared/required by the application itself, e.g., because the application makes use of a dependency's API. Transitive dependencies are declared/required not by the application but by its dependencies, e.g., because a dependency makes use of another dependency's API. When using the Eclipse Steady Maven plugin, dependencies that are declared in the application's POM appear as 'direct' dependency, all others appear as 'transitive'. When using the Eclipse Steady CLI, the dependency always appears as 'direct', since the CLI cannot derive this information from the JARs found in the file system. SHA1 known to Maven Central true if the SHA1 of the JAR is known to Maven Central , false if not. Dependency declared in POM true if the dependency information was read from the application's POM file using the Eclipse Steady Maven plugin, false if not. Library constructs potentially executable Number of library constructs potentially reachable (executable), according to the results of the static source code analysis (Eclipse Steady goals a2c and t2c). This screen provides several additional controls: Control Description 1 Help/Documentation Opens the documentation to this page 2 Reload App Data Reloads the content of the page The following information are displayed on the top of the main table: Name Description Archives Total The total number of archives/files which are dependencies of the application. Archives Traced The number of archives which were traced during the execution of the test goal Total Number of Traces The total number of traces which were generated during the execution of the test goal Dependencies Details \u00b6 Objective of Page: Provide detailed information about a given dependency, including information about the application-specific use and update possibilities. UI controls highlighted in the screenshot are as follows: Control Description 1 Maven Central Shows all versions of the given artifact in Maven Central Example: If the dependency shown is (commons-collections, commons-collections, 3.2.1), all versions of (commons-collections, commons-collections) known to Maven Central will be shown. 2 Help/Documentation Opens the documentation to this page At the top of the view, the following information are provided: Name Description Digest The unique id of the library (for example its SHA1) Digest verified true if the library id could be verified against the library repository, false if not. Dependency Path The path to the dependency. The view contains the following four section: Calls from application to Archive Library size and application-specific use Finding non-vulnerable library versions Archive Properties Calls from application to Archive \u00b6 This section shows direct call interactions between an application and the dependency (independent of any vulnerabilities). This information is useful when deciding about the update of a dependency, e.g., to a more recent version. It is divided into two parts. On the top, a picture presents an overview of these interactions: Name Description Distinct callers The number of distinct constructs in the application which are calling constructs of the library. Distinct callees The number of distinct constructs of the library which are called by constructs of the application. Calls The number of calls from the application to the library Below this picture, details of these interactions are described in a table. Objective of Table:: Shows the details of the interactions between an application and the dependency. Data shown:: Calls of a library method by an application method or vice versa. Data collected by goal(s):: steady:a2c , steady:t2c and test . Empty if: Application and library do not directly interact, e.g., as in case of transitive dependencies. None of the goals have been executed. Column Description Caller Fully-qualified name of the calling construct. Caller type **METH**od or **CONS**tructor. Callee Fully-qualified name the called construct. Potential True if the call has been found by static source analysis, false otherwise. Note: If the call has not been found by static analyses but has been observed during tests, the false is highlighted in red . This can happen if either the static analysis goals steady:a2c and steady:2tc were not executed or the analysis failed to identify the call. Traced True if the call has been observed during tests, false otherwise. Library size and application-specific use \u00b6 Objective of Table: Show the degree of actual and potential use that the application makes of the dependency (independent of any vulnerabilities). Data shown: The absolute number of constructs contains in the library (methods, constructors, etc.) and the number of constructs potentially or actually executable. Data collected by goal(s): steady:a2c , steady:t2c and test . Empty if: The dependency is not at all used in the scope of an application or none of the goals have been executed. Column Description Construct Type INIT: Static class initializer CONS: Constructor METH: Method CLASS: Class ENUM: Enumeration PACK: Package countExecutable: INIT + CONS + METH Count Total Absolute number contained in the JAR Count Reachable Number of constructs found reachable during static source code analysis. Count Traced Number of observed constructs during tests Finding non-vulnerable library versions \u00b6 Objective of Table: Support the selection of a more recent, non-vulnerable library version. Data shown: All library versions known to Maven Central, together with the number of vulnerabilities known to Eclipse Steady. Moreover, the table displays four update metrics computed over the library version currently in use and the respective alternative. Click on a row in order to see details about the removed callees (if any) in the view Calls from application to archive to be modified . Data collected by goal(s): Empty if: Neither the SHA1 nor the Maven identifier (group, artifact, version) of the dependency is known to Maven Central. In this case it is not possible to retrieve alternative versions. Column Description Library Id The Maven identifier in the format group : artifact : version. Count vulnerabilities The number of vulnerabilities known by Eclipse Steady. Callee stability The share of library callees that exist with the same signature (cf. table 'Calls from application to archive'). Example: If the application directly calls two methods in the current archive and one of those is not any longer present, the callee stability would be '1 out of 2 ( 50% )'. Note: Can be 0 if there are no direct calls between application and library. Dev. effort (calls to modify) The share of application calls that require a modification due to missing callees (cf. table 'Calls from application to archive'). Example: If the application calls a given library method from two of its methods and the library method is no longer present, the development effort would be '2 out of 2 ( 100% )'. Note: Can be 0 if there are no direct calls between application and library (or the respective goals were not run). Reachable body stability The number of reachable constructs in the current library version that exists as-is, i.e., with identical signature and identical byte code, in the alternative library (cf. table 'Library size and application-specific use'). Note: Can be 0 if none of the library constructs is reachable from the application (or the respective goals were not run). Overall body stability The number of constructs in the current library version that exists as-is, i.e., with identical signature and identical byte code, in the alternative library. Note: This metric is independent of the application-specific use of the library. Archive Properties \u00b6 Objective of Table:: Provide meta-information about the dependency, e.g., its version. Data shown:: All entries of the Manifest file ('META-INF/MANIFEST.MF' in the JAR). Data collected by goal(s):: steady:app . Empty if: The dependency has no MANIFEST.MF file or it does not contain any entries. Column Description Property Name The name of the Manifest file entry, e.g., 'Built-By'. Property Value The value of the Manifest file entry, e.g., 'Foo'. Callers to be modified \u00b6 Objective of page: Support the developer in updating a dependency to a more recent release by showing him all application methods that require modification. Data shown: All application calls that require a modification because of the fact that a callee method is no more available in the selected library version. Data collected by goal(s): steady:a2c , steady:t2c and tests Empty if: Either because there exist no direct method invocations from application to library or all of the callee methods still exist in the selected library version. On the top of the screen some metrics are provided: Name Description Calls to modify The number of calls to be modified in order to use this library version. Distinct callers to modify The number of constructors be modified/updated in the application in order to use this library version. Callees deleted The number of constructs of currently used library (by the application) which no longer exist in this new version of the library. These information are followed by a table providing the details: Name Description Caller the name of the construct of the application calling the library. Callee type The type of the called construct in the library. Callee The name of the called construct in the library. Potential True if the call has been found by static source analysis, false otherwise. Note: If the call has not been found by static analyses but has been observed during tests, the false is highlighted in red . This can happen if either the static analysis goals steady:a2c and steady:2tc were not executed or the analysis failed to identify the call. Traced True if the call has been observed during tests, false otherwise. Application Statistics \u00b6 Objective of page: Provide an overview about : the application and its dependencies, the application test coverage. Two tables are presented in this page: Dependencies \u00b6 Objective of table: Show statistics about the constructs of the application and its dependencies (methods, functions, packages, classes...). Please notice that these information are excluding the dependencies in the scopes TEST and PROVIDED . In the header of the table user can see the total number of dependencies which were considered. Column Description Construct Type The Types of analyzed constructs. Application The number of constructs (of type defined in column \"Construct Type\") in the application. Total (App + Dependencies) The total number of constructs (of type defined in column \"Construct Type\") of all the project, e.g. application code + dependencies Percentage (app/total) The percentage of code of the application compared to the total code of the project (application + dependencies). Application \u00b6 The second section of this page presents 2 metrics and a table: Name Description Executable application constructs (total) The total number of executable constructs of the application. Executable application constructs (traced) The number of executable constructs of the application which have been traced. Objective of table: Same as objective of view. Data shown: The number of traced constructs per application package. Data collected by goal(s): JUnit and integration tests. Empty if: No tests have been run. Column Description Application Packages Java package of the application. Constructors (traced / total) Number of constructors of classes in the respective package that were traced during tests. Total number of constructors of classes in the respective package. Note: The application constructs are typically collected from the compiled application code, hence, also comprise default constructors or constructors with synthetic parameters Methods (traced / total) Number of methods of classes in the respective package that were traced during tests. Total number of methods of classes in the respective package. Note: The application constructs are typically collected from the compiled application code, hence, also comprise synthetic methods such as access methods. Functions (traced/total) Number of functions in the respective package that were traced during tests. Total number of functions in the respective package. Note: The application constructs are typically collected from the compiled application code, hence, also comprise synthetic functions such as access functions. Static Initializers (traced/total) Number of static analyzers in the respective package that were traced during tests. Total number of static analyzers in the respective package. Note: The application constructs are typically collected from the compiled application code, hence, also comprise synthetic functions such as access functions. Test Coverage Percentage of traced constructs (methods, constructors, modules, functions, static initializers). History \u00b6 Objective of view: Provide an overview about goal executions for a given application. Objective of table: Same as objective of view. Data shown: Each row corresponds to one Eclipse Steady goal execution, click on a row in order to see detailed goal information. Data collected by goal(s): All. Empty if: No goals have been executed. Column Description Status Empty on success, error message in case of failures Goal Goal executed, see here for the list of all goals Started at Start date and time of the goal execution Runtime Total duration of the goal execution in minutes JVM Max.Memory (MB) Max. memory available for the JVM Max. Memory used (MB) Max. memory used by the JVM AVG. Memory used (MB) Average memory used by the JVM Eclipse Steady Release Release of Eclipse Steady used By clicking on one item of the list, user will then be able to see the details of the goal execution . History Details \u00b6 Objective of view: Provide detailed information about a given Eclipse Steady goal execution, mainly for root cause analysis of problems. This view presents the following metrics: Name Description Goal Execution ID Unique ID associated to the goal execution. Started At The date/time when this goal was executed on the client. The view also contains the following three tables: Goal statistics Goal configuration System information Goal statistics \u00b6 Data shown: Statistics collected at goal runtime. Data collected by goal(s): All. Empty if: Should never be empty. Column >Description Property Name Name of the metric. Property Value Value of the metric. Goal configuration \u00b6 Data shown: Configuration settings used for the goal execution. Data collected by goal(s): All. Empty if: Should never be empty. Column Description Property Name Name of the configuration setting. Property Value Value of the configuration setting. System information \u00b6 Data shown: Java system properties and environment variables collected on the client during the goal execution. The configuration settings vulas.shared.sys and vulas.shared.env determine which information is collected: # Comma-separated list of environment variables gathered during goal execution and transferred to the backend # A given environment variable is considered if its name equals one of the values (case-insensitive) # # Default: 18 variables vulas.shared.env = PROCESSOR_IDENTIFIER, NUMBER_OF_PROCESSORS, PROCESSOR_LEVEL, PROCESSOR_ARCHITECTURE, PROCESSOR_REVISION, \\ JAVA_HOME, COMPUTERNAME, \\ MAVEN_PROJECTBASEDIR, MAVEN_HOME, MAVEN_CONFIG, MAVEN_OPTS, \\ BUILD_URL, BUILD_TAG, BUILD_TIMESTAMP, BUILD_DISPLAY_NAME, BUILD_ID, BUILD_NUMBER, BUILD_VERSION # Extension of the above list # Default: - #vulas.shared.env.custom # Comma-separated list of system property namespaces gathered during goal execution and transferred to the backend # A given system property is considered if it starts with one of those namespaces (case-insensitive) # # Default: 6 patterns vulas.shared.sys = user., os., java., runtime., maven., sun. # Extension of the above list # Default: - #vulas.shared.sys.custom Data collected by goal(s): All. Empty if: Should never be empty. Column >Description Property Name Name of the system/environment setting. Property Value Value of the system/environment setting. Search \u00b6 Objective of view: Search for constructs in application dependencies. Objective of table: Same as objective of view. Data shown: Archives that contain one or more constructs (methods, classes, packages, etc.) that match the search expression. Data collected by goal(s): N/a. Empty if: If the search did not yield a result. Mitigation \u00b6 Objective of view: Get an overview about vulnerable archives that require a fix. Objective of table: Same as objective of view. Data shown: Archives that have one or more known vulnerabilities, click on a row in order to see update proposals and metrics in the dependencies details view . Data collected by goal(s): steady:app . Empty if: An application has no vulnerable dependencies. Column Description Dependency scope (Direct/Transitive) When using the Eclipse Steady Maven plugin, the scope corresponds to the Maven scope (see here for more information). Dependencies that are declared in the application's POM appear as 'direct' dependency, all others appear as 'transitive'. When using the Eclipse Steady CLI, the scope is always 'Runtime' and the dependency always appears as 'direct', since the CLI cannot derive this information from the JARs found in the file system. Archive Filename (SHA1) The filename of the library as found in the file system on which the analysis was run. The SHA1 is the unique identifier of libraries. It can happen that an application has multiple dependencies with the same filename but different SHA1. Vulnerability # Number of known vulnerabilities of a dependency.","title":"Frontend"},{"location":"user/manuals/frontend/#frontend-manual","text":"This guide describe the different views of the apps Web frontend. The sections describing each view can be reached by following the ? icon in the top-right corner of the frontend view itself.","title":"Frontend Manual"},{"location":"user/manuals/frontend/#start-page","text":"The start page is displayed when opening the URL of the Eclipse Steady Web Frontend (usually following a link looking like http://localhost:8033/apps ) in the browser: The table displayed on the left contains a subset of the applications analyzed by Eclipse Steady. Each application is identified by a triple (group, artifact, version), but only artifact and version are shown in the table. When selecting an application, the analysis results will be displayed on the right. In case your application is not shown, use the search field on top of the table. It can be used for filtering all applications whose group, artifact or version match the provided search string. Other UI controls highlighted in the screenshot are as follows: Control Description 1 Home Reloads the entire application, no application will be shown on the right 2 Redo Search Re-applies the search criterion 3 Information Information messages to the attention of the user 4 Workspace Identifier of the current workspace - Displayed with Gray background if default workspace and with red background otherwise 5 About Provides information about the application such as version, authors, etc. 6 Help Opens this Wiki page 7 Documentation Provides a link to the Documentation 8 Workspace Creation Tools to create a new workspace 9 Settings Provides the possibility to connect to another backend for loading application analyses (expert user only) and to select a workspace to display 10 Reload Reloads all the applications (use if you want to see the analysis results of an application that did not exist before)","title":"Start page"},{"location":"user/manuals/frontend/#vulnerabilities","text":"Objective of view: Provide an overview about vulnerable Open-Source dependencies of an application, together with the information whether vulnerable code of such dependencies (e.g. methods) are potentially or actually executable in the context of the application. UI controls highlighted in the screenshot are as follows: 1 Reset table Removes filters and groups from the table 2 Reload data Reloads the app-specific analysis results from the database (use if you executed Eclipse Steady goals and want to see its analysis results in the frontend). 3 Toggle historical vulnerabilities Shows and hides the display of historical vulnerabilities, e.g., vulnerabilities that existed in a previous version of the archive. Note: Historical vulnerabilities do not require any action as they do not represent a threat to application security. Note: This option is taken into account after pressing the \"Reload Data\" button (see 2) 4 Toggle unconfirmed vulnerabilities Shows and hides the display of unconfirmed vulnerabilities, i.e. vulnerabilities which have not yet been confirmed by Eclipse Steady. Note: This option is taken into account after pressing the \"Reload Data\" button (see 2) 5 Help Link to the frontend vulnerabilities help page (e.g. this page) 6 Reload application data Objective of table: same as objective of view Data shown: Each row corresponds to a vulnerability in a dependency, e.g., multiple vulnerabilities in the same dependency appear in separate table rows. The three columns to the right show whether vulnerable code is included, whether it is potentially reachable or if it was actually reached (executed) at application runtime. Click on a row in order to open the vulnerability details view Data collected by goal(s): steady:app (to populate the table rows), steady:a2c and steady:t2c to populate the column 'Static Analysis', JUnit and Integration tests to populate the column 'Dynamic Analysis' Empty if: An application has no vulnerable dependencies or no dependencies at all Column Description Dependency Scope (Direct / Transitive) When using the Eclipse Steady Maven plugin, the scope corresponds to the Maven scope (see here for more information). Dependencies that are declared in the application's POM appear as 'direct' dependency, all others appear as \"transitive\". When using the Eclipse Steady CLI, the scope is always 'Runtime' and the dependency always appears as 'direct', since the CLI cannot derive this information from the JARs found in the file system. Archive Filename (SHA1) The filename of the library as found in the file system on which the analysis was run. The SHA1 is the unique identifier of libraries. It can happen that an application has multiple dependencies with the same filename but different SHA1. Vulnerability The identifier of the vulnerability, typically a CVE identifier as used in the NVD. The CVSS score is shown for all vulnerabilities present in the NVD (note that only CVSS v2 is supported), n/a for all others. Inclusion of vulnerable Code Indicates whether the dependency contains vulnerable code. The library version is confirmed to contain vulnerable code The library version is confirmed to contain fixed code (a so-called \"historical vulnerability\") It is unknown whether the library version contains the vulnerable or the fixed code. Note: The Eclipse Steady admin team will be automatically notified about such cases in order to take a decision Static Analysis: Potential execution of vulnerable code Indicates whether vulnerable code (e.g., methods) are potentially reachable (executable) according to the results of the static source code analysis (performed during steady:a2c and steady:t2c). Vulnerable code is potentially reachable, i.e., the application can be executed in such a way that the vulnerable code is reached. Note: In few cases, the vulnerable code of a given bug is not known. In those cases, this icon appears as soon as any code of the library is found reachable. Library code is reachable, i.e., part of the call graph, but none of the vulnerable code. No library reachable or reachability analysis not performed Dynamic Analysis: Actual execution of vulnerable Code Vulnerable code is executed Note: In few cases, the vulnerable code of a given bug is not known. In those cases, this icon appears as soon as any code of the library is executed. Library code is executed, but none of the vulnerable code No library code executed or no tests have been performed","title":"Vulnerabilities"},{"location":"user/manuals/frontend/#vulnerabilities-details","text":"Objective of Page: Provide detailed information about the vulnerability, the source code repository of the Open-Source project and the constructs (e.g., methods) that have been touched by the Open-Source developers in order to fix the vulnerability. UI controls highlighted in the screenshot are as follows: Control Description 1 Help Link to the documentation page for Vulnerabilities Details (e.g. this page) 2 Exploit database Opens the search page of the Exploit Database in a new browser window, in order to let you search for exploits for the given vulnerability . Note: You need to manually complete the Captcha in order to start the search. 3 NVD (National Vulnerability Database) Opens a link with more vulnerability information in a new browser window. In most of the cases, it is a page from the NVD. 4 Google Trends Shows whether the given vulnerability was a popular Google search term (thus, received a lot of public interest) over the course of the last 30 days (click to see other time ranges). Objective of table: Provide information whether individual vulnerable constructs (methods or constructors) are contained in the respective library, and whether they are potentially or actually reachable. Data shown: All constructs (methods or constructors) that have been added, modified or deleted by the developers of the Open-Source library in order to fix the respective vulnerability. Data collected by goal(s): Table rows are taken from the bug database, which is maintained by the Eclipse Steady admin team. The three columns to the right are populated by steady:app (column 'Contained'), steady:a2c and steady:t2c (column 'Reachable'), as well as through the execution of tests (column 'Traced') Empty if: Vulnerabilities that have no known fix or whose fix concerns non-Java files, e.g., XML configuration files. The two right-most columns are empty if the goals steady:a2c or steady:t2c have not been executed, or if no tests have been performed Column Description Change Indicates whether the given construct has been ADDed, MODified or DELeted as part of the respective commit (revision) Revision Commit identifier Type Class or Constructor Qualified construct Name (Path) The fully qualified name of the construct, i.e., including package name, class name(s) and parameter types Example: com.acme.Foo$Bar.go(String) , whereby com.acme is a package, Foo and Bar classes and go(String) a method name including a String parameter Contained Indicates whether the respective construct is part of the Java archive or not Note: Very often, the commits of the Open-Source developers also contain changes to their JUnit test classes. Those classes are typically not contained in the released Java archive Reachable Indicates whether the respective construct is part of the call graph built during the Eclipse Steady goals a2c and t2c Click on the icon in order to see the actual call graph leading to the respective vulnerable code It is part of the call graph It is not part of the call graph (but others constructs of the archive are) No construct of the respective archive is part of the call graph Traced Indicates whether the respective construct has been executed during JUnit or integration tests Click on the icon in order to see the actual call graph leading to the respective vulnerable code It has been executed. In this case, the tooltip contains information about the timestamp of the execution, the number of calls and the goal identifier It has not been executed (but others constructs of the archive have been) No construct of the respective archive has been executed","title":"Vulnerabilities Details"},{"location":"user/manuals/frontend/#vulnerable-code-call-graph","text":"Objective of graph: Provide information on paths leading to vulnerable methods Data shown: The vulnerable methods are shown as red nodes, while methods part of the application are shown as green nodes. Black edges result from the static source code analysis, while red edges have been collected during test execution. The fully qualified name of methods and constructors as well as archive information is shown when hovering over nodes. Data collected by goal(s): a2c and t2c (black edges), JUnit and integration tests (red edges) Empty if: No paths to vulnerable methods were found UI controls highlighted in the screenshot are as follows: Control Description 1 Collapse graph on library level Collapses all nodes representing methods of the same library into one node. 2 Collapse graph on package level Collapses all nodes representing methods of the same package into one node. 3 Collapse graph on class level Collapses all nodes representing methods of the same class into one node. 4 Expand all Shows the original graph. 5 Collapse nodes Collapses all nodes 6 Help/Documentation Opens the documentation to this page 7 NVD (National vulnerability Database) Opens the NVD for the respective vulnerability in a new browser window.","title":"Vulnerable Code Call Graph"},{"location":"user/manuals/frontend/#dependencies","text":"Objective of view: Provide an overview about all dependencies of the application, no matter whether they contain vulnerabilities or not Objective of table: Same as objective of view Data shown: All dependencies of the application. Click on a dependency's filename in order to open the dependencies details view Data collected by goal(s): steady:app and test Empty if: An application has no dependencies at all The content of the table can be detailed as follow: Details Description Archive Filename (SHA1) The filename of the library as found in the file system on which the analysis was run. The SHA1 is the unique identifier of libraries. It can happen that an application has multiple dependencies with the same filename but different SHA1. Dependency Scope When using the Eclipse Steady Maven plugin, the scope corresponds to the Maven scope (see here for more information). When using the Eclipse Steady CLI, the scope is always 'Runtime'. Direct / Transitive Direct dependencies are declared/required by the application itself, e.g., because the application makes use of a dependency's API. Transitive dependencies are declared/required not by the application but by its dependencies, e.g., because a dependency makes use of another dependency's API. When using the Eclipse Steady Maven plugin, dependencies that are declared in the application's POM appear as 'direct' dependency, all others appear as 'transitive'. When using the Eclipse Steady CLI, the dependency always appears as 'direct', since the CLI cannot derive this information from the JARs found in the file system. SHA1 known to Maven Central true if the SHA1 of the JAR is known to Maven Central , false if not. Dependency declared in POM true if the dependency information was read from the application's POM file using the Eclipse Steady Maven plugin, false if not. Library constructs potentially executable Number of library constructs potentially reachable (executable), according to the results of the static source code analysis (Eclipse Steady goals a2c and t2c). This screen provides several additional controls: Control Description 1 Help/Documentation Opens the documentation to this page 2 Reload App Data Reloads the content of the page The following information are displayed on the top of the main table: Name Description Archives Total The total number of archives/files which are dependencies of the application. Archives Traced The number of archives which were traced during the execution of the test goal Total Number of Traces The total number of traces which were generated during the execution of the test goal","title":"Dependencies"},{"location":"user/manuals/frontend/#dependencies-details","text":"Objective of Page: Provide detailed information about a given dependency, including information about the application-specific use and update possibilities. UI controls highlighted in the screenshot are as follows: Control Description 1 Maven Central Shows all versions of the given artifact in Maven Central Example: If the dependency shown is (commons-collections, commons-collections, 3.2.1), all versions of (commons-collections, commons-collections) known to Maven Central will be shown. 2 Help/Documentation Opens the documentation to this page At the top of the view, the following information are provided: Name Description Digest The unique id of the library (for example its SHA1) Digest verified true if the library id could be verified against the library repository, false if not. Dependency Path The path to the dependency. The view contains the following four section: Calls from application to Archive Library size and application-specific use Finding non-vulnerable library versions Archive Properties","title":"Dependencies Details"},{"location":"user/manuals/frontend/#calls-from-application-to-archive","text":"This section shows direct call interactions between an application and the dependency (independent of any vulnerabilities). This information is useful when deciding about the update of a dependency, e.g., to a more recent version. It is divided into two parts. On the top, a picture presents an overview of these interactions: Name Description Distinct callers The number of distinct constructs in the application which are calling constructs of the library. Distinct callees The number of distinct constructs of the library which are called by constructs of the application. Calls The number of calls from the application to the library Below this picture, details of these interactions are described in a table. Objective of Table:: Shows the details of the interactions between an application and the dependency. Data shown:: Calls of a library method by an application method or vice versa. Data collected by goal(s):: steady:a2c , steady:t2c and test . Empty if: Application and library do not directly interact, e.g., as in case of transitive dependencies. None of the goals have been executed. Column Description Caller Fully-qualified name of the calling construct. Caller type **METH**od or **CONS**tructor. Callee Fully-qualified name the called construct. Potential True if the call has been found by static source analysis, false otherwise. Note: If the call has not been found by static analyses but has been observed during tests, the false is highlighted in red . This can happen if either the static analysis goals steady:a2c and steady:2tc were not executed or the analysis failed to identify the call. Traced True if the call has been observed during tests, false otherwise.","title":"Calls from application to Archive"},{"location":"user/manuals/frontend/#library-size-and-application-specific-use","text":"Objective of Table: Show the degree of actual and potential use that the application makes of the dependency (independent of any vulnerabilities). Data shown: The absolute number of constructs contains in the library (methods, constructors, etc.) and the number of constructs potentially or actually executable. Data collected by goal(s): steady:a2c , steady:t2c and test . Empty if: The dependency is not at all used in the scope of an application or none of the goals have been executed. Column Description Construct Type INIT: Static class initializer CONS: Constructor METH: Method CLASS: Class ENUM: Enumeration PACK: Package countExecutable: INIT + CONS + METH Count Total Absolute number contained in the JAR Count Reachable Number of constructs found reachable during static source code analysis. Count Traced Number of observed constructs during tests","title":"Library size and application-specific use"},{"location":"user/manuals/frontend/#finding-non-vulnerable-library-versions","text":"Objective of Table: Support the selection of a more recent, non-vulnerable library version. Data shown: All library versions known to Maven Central, together with the number of vulnerabilities known to Eclipse Steady. Moreover, the table displays four update metrics computed over the library version currently in use and the respective alternative. Click on a row in order to see details about the removed callees (if any) in the view Calls from application to archive to be modified . Data collected by goal(s): Empty if: Neither the SHA1 nor the Maven identifier (group, artifact, version) of the dependency is known to Maven Central. In this case it is not possible to retrieve alternative versions. Column Description Library Id The Maven identifier in the format group : artifact : version. Count vulnerabilities The number of vulnerabilities known by Eclipse Steady. Callee stability The share of library callees that exist with the same signature (cf. table 'Calls from application to archive'). Example: If the application directly calls two methods in the current archive and one of those is not any longer present, the callee stability would be '1 out of 2 ( 50% )'. Note: Can be 0 if there are no direct calls between application and library. Dev. effort (calls to modify) The share of application calls that require a modification due to missing callees (cf. table 'Calls from application to archive'). Example: If the application calls a given library method from two of its methods and the library method is no longer present, the development effort would be '2 out of 2 ( 100% )'. Note: Can be 0 if there are no direct calls between application and library (or the respective goals were not run). Reachable body stability The number of reachable constructs in the current library version that exists as-is, i.e., with identical signature and identical byte code, in the alternative library (cf. table 'Library size and application-specific use'). Note: Can be 0 if none of the library constructs is reachable from the application (or the respective goals were not run). Overall body stability The number of constructs in the current library version that exists as-is, i.e., with identical signature and identical byte code, in the alternative library. Note: This metric is independent of the application-specific use of the library.","title":"Finding non-vulnerable library versions"},{"location":"user/manuals/frontend/#archive-properties","text":"Objective of Table:: Provide meta-information about the dependency, e.g., its version. Data shown:: All entries of the Manifest file ('META-INF/MANIFEST.MF' in the JAR). Data collected by goal(s):: steady:app . Empty if: The dependency has no MANIFEST.MF file or it does not contain any entries. Column Description Property Name The name of the Manifest file entry, e.g., 'Built-By'. Property Value The value of the Manifest file entry, e.g., 'Foo'.","title":"Archive Properties"},{"location":"user/manuals/frontend/#callers-to-be-modified","text":"Objective of page: Support the developer in updating a dependency to a more recent release by showing him all application methods that require modification. Data shown: All application calls that require a modification because of the fact that a callee method is no more available in the selected library version. Data collected by goal(s): steady:a2c , steady:t2c and tests Empty if: Either because there exist no direct method invocations from application to library or all of the callee methods still exist in the selected library version. On the top of the screen some metrics are provided: Name Description Calls to modify The number of calls to be modified in order to use this library version. Distinct callers to modify The number of constructors be modified/updated in the application in order to use this library version. Callees deleted The number of constructs of currently used library (by the application) which no longer exist in this new version of the library. These information are followed by a table providing the details: Name Description Caller the name of the construct of the application calling the library. Callee type The type of the called construct in the library. Callee The name of the called construct in the library. Potential True if the call has been found by static source analysis, false otherwise. Note: If the call has not been found by static analyses but has been observed during tests, the false is highlighted in red . This can happen if either the static analysis goals steady:a2c and steady:2tc were not executed or the analysis failed to identify the call. Traced True if the call has been observed during tests, false otherwise.","title":"Callers to be modified"},{"location":"user/manuals/frontend/#application-statistics","text":"Objective of page: Provide an overview about : the application and its dependencies, the application test coverage. Two tables are presented in this page:","title":"Application Statistics"},{"location":"user/manuals/frontend/#history","text":"Objective of view: Provide an overview about goal executions for a given application. Objective of table: Same as objective of view. Data shown: Each row corresponds to one Eclipse Steady goal execution, click on a row in order to see detailed goal information. Data collected by goal(s): All. Empty if: No goals have been executed. Column Description Status Empty on success, error message in case of failures Goal Goal executed, see here for the list of all goals Started at Start date and time of the goal execution Runtime Total duration of the goal execution in minutes JVM Max.Memory (MB) Max. memory available for the JVM Max. Memory used (MB) Max. memory used by the JVM AVG. Memory used (MB) Average memory used by the JVM Eclipse Steady Release Release of Eclipse Steady used By clicking on one item of the list, user will then be able to see the details of the goal execution .","title":"History"},{"location":"user/manuals/frontend/#history-details","text":"Objective of view: Provide detailed information about a given Eclipse Steady goal execution, mainly for root cause analysis of problems. This view presents the following metrics: Name Description Goal Execution ID Unique ID associated to the goal execution. Started At The date/time when this goal was executed on the client. The view also contains the following three tables: Goal statistics Goal configuration System information","title":"History Details"},{"location":"user/manuals/frontend/#search","text":"Objective of view: Search for constructs in application dependencies. Objective of table: Same as objective of view. Data shown: Archives that contain one or more constructs (methods, classes, packages, etc.) that match the search expression. Data collected by goal(s): N/a. Empty if: If the search did not yield a result.","title":"Search"},{"location":"user/manuals/frontend/#mitigation","text":"Objective of view: Get an overview about vulnerable archives that require a fix. Objective of table: Same as objective of view. Data shown: Archives that have one or more known vulnerabilities, click on a row in order to see update proposals and metrics in the dependencies details view . Data collected by goal(s): steady:app . Empty if: An application has no vulnerable dependencies. Column Description Dependency scope (Direct/Transitive) When using the Eclipse Steady Maven plugin, the scope corresponds to the Maven scope (see here for more information). Dependencies that are declared in the application's POM appear as 'direct' dependency, all others appear as 'transitive'. When using the Eclipse Steady CLI, the scope is always 'Runtime' and the dependency always appears as 'direct', since the CLI cannot derive this information from the JARs found in the file system. Archive Filename (SHA1) The filename of the library as found in the file system on which the analysis was run. The SHA1 is the unique identifier of libraries. It can happen that an application has multiple dependencies with the same filename but different SHA1. Vulnerability # Number of known vulnerabilities of a dependency.","title":"Mitigation"},{"location":"user/manuals/library_assessment/","text":"Library Assessment \u00b6 The notion of \"library assessment\" refers to the process that establishes whether a library contains a construct modified to fix a vulnerability (aka changed-construct) in its vulnerable or fixed version. Eclipse Steady performs this process automatically, but in some cases manual intervention is required (or desirable, e.g., to override the automated assessment). Automated Library Assessment \u00b6 The process of library assessment is automated in Eclipse Steady through patch library analyzer , a Java application that compares the abstract syntax tree (AST) of the body of the changed-construct contained in a library with the AST of its vulnerable and fixed version. Unfortunately, vulnerability fixes are applied on source code whereas library releases imported within applications are binaries and this represents a significant technical challenge. The patch lib analyzer addresses it by retrieving the source code of binaries (if available) from Maven repositories (e.g. Maven Central or organization's specific Nexus repositories). Warning The current implementation only assesses libraries having a GAV ( group-artifact-version identifier) known to Maven Central or configured Nexus repositories. The assessment of python artifacts available in PyPI is not supported at this time. If the sources of a given library are available, the patch lib analyzer compares the ASTs of the changed-constructs with the AST of their vulnerable and fixed version. Once equalities are found in source code, they are also used to conclude--wherever possible--for cases where the source code is not available or equalities are not found. The patch lib analyzer may conclude that a library is fixed or vulnerable based on the following criteria: AST EQUALITY vulnerable: if the abstract syntax tree (AST) of at least one construct of the library, is equal to the AST of a construct before it was modified to fix the vulnerability (and none is equal to the fixed version) fixed: if the abstract syntax tree (AST) of at least one construct of the library, is equal to the AST of a construct after it was modified to fix the vulnerability (and none is equal to the vulnerable version) MINOR EQUALITY : The library version is minor of another one in the same minor release (i.e., both starting with x.y.) which has an AST equality to vulnerable MAJOR EQUALITY : The library version is major of another one in the same minor release (i.e., both starting with x.y.) which has an AST equality to fixed INTERSECTION vulnerable: if the abstract syntax tree (AST) of all construct of the library, are \"closer\" (i.e., requires a smaller amount of changes) to the AST of a construct before it was modified to fix the vulnerability than to the one after the change fixed: if the abstract syntax tree (AST) of all construct of the library, are \"closer\" (i.e., requires a smaller amount of changes) to the AST of a construct after it was modified to fix the vulnerability than to the one before the change GREATER RELEASE : the library is in a minor release which was released after the most recent fix of the vulnerability. E.g., 3.4.0 release on Jan 2017 is a greater release for bug CVE-2016-1234 if its latest fix was applied on release 3.3.y before 2016, Dec 31 st . Even in cases where the automated approach cannot conclude, the data computed over the libraries are stored in the Eclipse Steady backend under the source TO_REVIEW . The key data used to assess the libraries and always available for review are: sourceAvailable : whether the sources for the library are available in external repositories construct in jar : whether a construct changed to fix a vulnerability is part of the library archive (Jar) dTv (distance to vulnerable): the number of changes to be applied to the AST of a construct in the library, to become equal to the AST of the construct before the fix (computer with ChangeDistiller) dTf (distance to fixed): the number of changes to be applied to the AST of a construct in the library, to become equal to the AST of the construct after the fix (computer with ChangeDistiller) The results are visible in the column \"Patch eval\" of the bugs frontend. Clicking on the cell, all the information computed (based on which the assessment result was taken - if any) are available. Usage \u00b6 The patch lib analyzer can be run as a periodic job or a single run. Configuration: j (-jib) : Run patch Eval as cron job (optional) h (-hour) <arg> : Delay for starting the job (hours) (optional, only relevant if -job is specified, Default: 0 ) p (-period) <arg> : The period between successive executions (in hours) (optional, only relevant if -job is specified, Default: 6) bug (-bug) : Comma separated list of bugs to analyze (optional, all bugs analyzed if config not provided) f (-toFile) : Save JSON results to file; otherwise upload to backend (optional, default: false) o (-overrideResults) : Delete all existing results before upload; otherwise only upload results for AffectedLibraries not already existing in the backend (optional, default: false) Other useful/required configurations: vulas.shared.cia.serviceUrl : url of the deployed rest-lib-util service (Mandatory) vulas.shared.backend.serviceUrl : Url of the deployed rest-backend service (Mandatory) vulas.patchEval.uploadResults : whether to upload the results to vulas.shared.backend.serviceUrl or save the JSON to file (equivalent to -file ) vulas.patchEval.onlyAddNewResults : only upload results for AffectedLibraries not already existing in the backend; otherwise all existing results are deleted before the upload (equivalent to -overrideResults ) vulas.patchEval.basefolder : filesystem path where to save and look for the csv files with the computed data per library vulas.patchEval.bugId : comma separated list of bug identifiers to analyze (equivalent to -bug ) Run as cron job java -Dvulas.patchEval.uploadResults = true -Dvulas.patchEval.onlyAddNewResults = true -Dvulas.patchEval.basefolder = <csv_folder> -j -p 6 -Dvulas.shared.cia.serviceUrl = http://localhost:8033/cia -Dvulas.shared.backend.serviceUrl = http://localhost:8033/backend/-Xmx6G -Xms6G -jar patch-lib-analyzer-3.2.2-jar-with-dependencies.jar Run for all bugs java -Dvulas.patchEval.uploadResults = true -Dvulas.patchEval.onlyAddNewResults = true -Dvulas.patchEval.basefolder = <csv_folder> -Dvulas.patchEval.bugId = <comma_separated_list_of_bugs> -Dvulas.shared.cia.serviceUrl = http://localhost:8033/cia -Dvulas.shared.backend.serviceUrl = http://localhost:8033/backend/-Xmx6G -Xms6G -jar patch-lib-analyzer-3.2.2-jar-with-dependencies.jar Run for CVE-2018-1111,CVE-2018-2222 java -Dvulas.patchEval.uploadResults = true -Dvulas.patchEval.onlyAddNewResults = true -Dvulas.patchEval.basefolder = <csv_folder> -Dvulas.patchEval.bugId = CVE-2018-1111,CVE-2018-2222 -Dvulas.shared.cia.serviceUrl = http://localhost:8033/cia -Dvulas.shared.backend.serviceUrl = http://localhost:8033/backend/-Xmx6G -Xms6G -jar patch-lib-analyzer-3.2.2-jar-with-dependencies.jar Manual Library Assessment \u00b6 The manual assessment can be done from the bugs frontend http://localhost:8033/bugs , by setting the assessment to the appropriate value in the \"Assessment (Manual)\" column and clicking the \"Save\" button. Our recommendation is to always rely on code (manually inspecting it in the worst case) in order to take a decision. The versions indicated in the vulnerability's description were proved wrong in multiple cases. The column \"Patch eval\" shows information about the results (if any) of the patch lib analyzer. By clicking on the cell the results obtained by code comparison for each elements of the bug change list are shown. If available, it is recommended to use them in order to take a decision about the vulnerability of the corresponding library version. What do the 'Orange Hourglass' icons mean? Whenever an application library contains the signature of a construct that was changed to fix a vulnerability, but the patch lib analyzer didn't yet (or could not) establish whether it contains the vulnerable or fixed version of the construct, then the tool reports the vulnerability in the web frontend with an ORANGE hourglass in the column \"Inclusion of vulnerable code\". To resolve orange hourglasses the tool needs to know whether the library contains the vulnerable or fixed version of the construct changed in the vulnerability fix, which can be determined manually or automatically .","title":"Library Assessment"},{"location":"user/manuals/library_assessment/#library-assessment","text":"The notion of \"library assessment\" refers to the process that establishes whether a library contains a construct modified to fix a vulnerability (aka changed-construct) in its vulnerable or fixed version. Eclipse Steady performs this process automatically, but in some cases manual intervention is required (or desirable, e.g., to override the automated assessment).","title":"Library Assessment"},{"location":"user/manuals/library_assessment/#automated-library-assessment","text":"The process of library assessment is automated in Eclipse Steady through patch library analyzer , a Java application that compares the abstract syntax tree (AST) of the body of the changed-construct contained in a library with the AST of its vulnerable and fixed version. Unfortunately, vulnerability fixes are applied on source code whereas library releases imported within applications are binaries and this represents a significant technical challenge. The patch lib analyzer addresses it by retrieving the source code of binaries (if available) from Maven repositories (e.g. Maven Central or organization's specific Nexus repositories). Warning The current implementation only assesses libraries having a GAV ( group-artifact-version identifier) known to Maven Central or configured Nexus repositories. The assessment of python artifacts available in PyPI is not supported at this time. If the sources of a given library are available, the patch lib analyzer compares the ASTs of the changed-constructs with the AST of their vulnerable and fixed version. Once equalities are found in source code, they are also used to conclude--wherever possible--for cases where the source code is not available or equalities are not found. The patch lib analyzer may conclude that a library is fixed or vulnerable based on the following criteria: AST EQUALITY vulnerable: if the abstract syntax tree (AST) of at least one construct of the library, is equal to the AST of a construct before it was modified to fix the vulnerability (and none is equal to the fixed version) fixed: if the abstract syntax tree (AST) of at least one construct of the library, is equal to the AST of a construct after it was modified to fix the vulnerability (and none is equal to the vulnerable version) MINOR EQUALITY : The library version is minor of another one in the same minor release (i.e., both starting with x.y.) which has an AST equality to vulnerable MAJOR EQUALITY : The library version is major of another one in the same minor release (i.e., both starting with x.y.) which has an AST equality to fixed INTERSECTION vulnerable: if the abstract syntax tree (AST) of all construct of the library, are \"closer\" (i.e., requires a smaller amount of changes) to the AST of a construct before it was modified to fix the vulnerability than to the one after the change fixed: if the abstract syntax tree (AST) of all construct of the library, are \"closer\" (i.e., requires a smaller amount of changes) to the AST of a construct after it was modified to fix the vulnerability than to the one before the change GREATER RELEASE : the library is in a minor release which was released after the most recent fix of the vulnerability. E.g., 3.4.0 release on Jan 2017 is a greater release for bug CVE-2016-1234 if its latest fix was applied on release 3.3.y before 2016, Dec 31 st . Even in cases where the automated approach cannot conclude, the data computed over the libraries are stored in the Eclipse Steady backend under the source TO_REVIEW . The key data used to assess the libraries and always available for review are: sourceAvailable : whether the sources for the library are available in external repositories construct in jar : whether a construct changed to fix a vulnerability is part of the library archive (Jar) dTv (distance to vulnerable): the number of changes to be applied to the AST of a construct in the library, to become equal to the AST of the construct before the fix (computer with ChangeDistiller) dTf (distance to fixed): the number of changes to be applied to the AST of a construct in the library, to become equal to the AST of the construct after the fix (computer with ChangeDistiller) The results are visible in the column \"Patch eval\" of the bugs frontend. Clicking on the cell, all the information computed (based on which the assessment result was taken - if any) are available.","title":"Automated Library Assessment"},{"location":"user/manuals/library_assessment/#usage","text":"The patch lib analyzer can be run as a periodic job or a single run. Configuration: j (-jib) : Run patch Eval as cron job (optional) h (-hour) <arg> : Delay for starting the job (hours) (optional, only relevant if -job is specified, Default: 0 ) p (-period) <arg> : The period between successive executions (in hours) (optional, only relevant if -job is specified, Default: 6) bug (-bug) : Comma separated list of bugs to analyze (optional, all bugs analyzed if config not provided) f (-toFile) : Save JSON results to file; otherwise upload to backend (optional, default: false) o (-overrideResults) : Delete all existing results before upload; otherwise only upload results for AffectedLibraries not already existing in the backend (optional, default: false) Other useful/required configurations: vulas.shared.cia.serviceUrl : url of the deployed rest-lib-util service (Mandatory) vulas.shared.backend.serviceUrl : Url of the deployed rest-backend service (Mandatory) vulas.patchEval.uploadResults : whether to upload the results to vulas.shared.backend.serviceUrl or save the JSON to file (equivalent to -file ) vulas.patchEval.onlyAddNewResults : only upload results for AffectedLibraries not already existing in the backend; otherwise all existing results are deleted before the upload (equivalent to -overrideResults ) vulas.patchEval.basefolder : filesystem path where to save and look for the csv files with the computed data per library vulas.patchEval.bugId : comma separated list of bug identifiers to analyze (equivalent to -bug ) Run as cron job java -Dvulas.patchEval.uploadResults = true -Dvulas.patchEval.onlyAddNewResults = true -Dvulas.patchEval.basefolder = <csv_folder> -j -p 6 -Dvulas.shared.cia.serviceUrl = http://localhost:8033/cia -Dvulas.shared.backend.serviceUrl = http://localhost:8033/backend/-Xmx6G -Xms6G -jar patch-lib-analyzer-3.2.2-jar-with-dependencies.jar Run for all bugs java -Dvulas.patchEval.uploadResults = true -Dvulas.patchEval.onlyAddNewResults = true -Dvulas.patchEval.basefolder = <csv_folder> -Dvulas.patchEval.bugId = <comma_separated_list_of_bugs> -Dvulas.shared.cia.serviceUrl = http://localhost:8033/cia -Dvulas.shared.backend.serviceUrl = http://localhost:8033/backend/-Xmx6G -Xms6G -jar patch-lib-analyzer-3.2.2-jar-with-dependencies.jar Run for CVE-2018-1111,CVE-2018-2222 java -Dvulas.patchEval.uploadResults = true -Dvulas.patchEval.onlyAddNewResults = true -Dvulas.patchEval.basefolder = <csv_folder> -Dvulas.patchEval.bugId = CVE-2018-1111,CVE-2018-2222 -Dvulas.shared.cia.serviceUrl = http://localhost:8033/cia -Dvulas.shared.backend.serviceUrl = http://localhost:8033/backend/-Xmx6G -Xms6G -jar patch-lib-analyzer-3.2.2-jar-with-dependencies.jar","title":"Usage"},{"location":"user/manuals/library_assessment/#manual-library-assessment","text":"The manual assessment can be done from the bugs frontend http://localhost:8033/bugs , by setting the assessment to the appropriate value in the \"Assessment (Manual)\" column and clicking the \"Save\" button. Our recommendation is to always rely on code (manually inspecting it in the worst case) in order to take a decision. The versions indicated in the vulnerability's description were proved wrong in multiple cases. The column \"Patch eval\" shows information about the results (if any) of the patch lib analyzer. By clicking on the cell the results obtained by code comparison for each elements of the bug change list are shown. If available, it is recommended to use them in order to take a decision about the vulnerability of the corresponding library version. What do the 'Orange Hourglass' icons mean? Whenever an application library contains the signature of a construct that was changed to fix a vulnerability, but the patch lib analyzer didn't yet (or could not) establish whether it contains the vulnerable or fixed version of the construct, then the tool reports the vulnerability in the web frontend with an ORANGE hourglass in the column \"Inclusion of vulnerable code\". To resolve orange hourglasses the tool needs to know whether the library contains the vulnerable or fixed version of the construct changed in the vulnerability fix, which can be determined manually or automatically .","title":"Manual Library Assessment"},{"location":"user/manuals/report/","text":"Report Manual \u00b6 Introduction \u00b6 Result reports are generated through the execution of the report goal, more information on how to run and configure the goal can be found here . They are generated in three different formats (JSON, XML and HTML), but the remainder of this page will focus on the HTML report. For Maven reactor projects, a big advantage of reports is that they aggregate the findings for all modules. Report Header \u00b6 The report header contains general information about the scanned application or Maven modules. It provides: Date and time of the report creation. Information if the report is an aggregated report or not (incl. the list of considered modules). The conclusion of the report goal, displayed in red if vulnerabilities were found and an exception is thrown, green otherwise. Important configuration settings used when running the report goal (exemptions and exception threshold). Report Body \u00b6 The report body contains two lists of findings: Those below the header \"Vulnerabilities\" are relevant findings resulting in a build exception, those below the header \"Exempted Vulnerabilities\" have been exempted according to the configuration settings mentioned in the report header. The color code on the left of each item reflects the CVSS score of the respective vulnerability, it is grey in case no CVSS score is present. The table below each item contains a subset of those applications/modules having a dependency on the respective vulnerable archive. You can reach the Web frontend of each application/project by clicking on its name. Moreover, each application/module comes with a tooltip showing the complete GAV coordindates, the nature of its dependency on the respective archive (scope and transitivity), and the exemption reason (in case of exempted vulnerabilities). The three columns indicate whether the vulnerable code is present, whether it is potentially executable or actually executed.","title":"Report"},{"location":"user/manuals/report/#report-manual","text":"","title":"Report Manual"},{"location":"user/manuals/report/#introduction","text":"Result reports are generated through the execution of the report goal, more information on how to run and configure the goal can be found here . They are generated in three different formats (JSON, XML and HTML), but the remainder of this page will focus on the HTML report. For Maven reactor projects, a big advantage of reports is that they aggregate the findings for all modules.","title":"Introduction"},{"location":"user/manuals/report/#report-header","text":"The report header contains general information about the scanned application or Maven modules. It provides: Date and time of the report creation. Information if the report is an aggregated report or not (incl. the list of considered modules). The conclusion of the report goal, displayed in red if vulnerabilities were found and an exception is thrown, green otherwise. Important configuration settings used when running the report goal (exemptions and exception threshold).","title":"Report Header"},{"location":"user/manuals/report/#report-body","text":"The report body contains two lists of findings: Those below the header \"Vulnerabilities\" are relevant findings resulting in a build exception, those below the header \"Exempted Vulnerabilities\" have been exempted according to the configuration settings mentioned in the report header. The color code on the left of each item reflects the CVSS score of the respective vulnerability, it is grey in case no CVSS score is present. The table below each item contains a subset of those applications/modules having a dependency on the respective vulnerable archive. You can reach the Web frontend of each application/project by clicking on its name. Moreover, each application/module comes with a tooltip showing the complete GAV coordindates, the nature of its dependency on the respective archive (scope and transitivity), and the exemption reason (in case of exempted vulnerabilities). The three columns indicate whether the vulnerable code is present, whether it is potentially executable or actually executed.","title":"Report Body"},{"location":"user/manuals/setup/","text":"Setup and Configuration Manual \u00b6 Workspace \u00b6 A workspace acts as a container to group the results of several application analyses. In that context, please note that each module of a multi-module Maven project appears as a separate application in the Eclipse Steady Web frontend. Before using workspaces, you need to create one using the Eclipse Steady Web frontend (see below); you will obtain a token that you will need to pass as a configuration parameter when performing scans. Create workspace(s) (once) \u00b6 You need to create a workspace once using the Eclipse Steady Web frontend. Use the \"create workspace\" icon in the lower-left corner toolbar of the apps Web frontend to do so. A workspace has the following properties: Name : Must be provided. Note that the name is not unique, thus, there can be several workspaces having the same name. Description : Must be provided. Contact : Please provide the email address of a distribution list (DL). Export results : AGGREGATED : Findings are aggregated on workspace-level, one item for the entire workspace will be exported DETAILED : Findings are aggregated on application-level, one item for every application of the workspace will be exported OFF : No export of findings Public : A public workspace appears in the drop-down box of the apps Web frontend, a private one does not Once the fields have been filled, press the \"Save\" button. The system then returns with a pop-up containing the random token generated upon workspace creation. Do not forget to note down this token, it will be needed later on for each scan of your application(s). Use the generated token (during application analysis) \u00b6 The workspace token generated at previous step has to be used as value for the configuration setting vulas.core.space.token . This information is mandatory during the scans as it allows the user's data to be uploaded to the correct place/workspace in the Eclipse Steady backend. See here for more information regarding the configuration of Eclipse Steady clients. Choose a workspace (in the apps Web frontend) \u00b6 Use the configuration icon in the lower-left corner in order to select a workspace. You can search for public workspaces by typing their name in the \"Space\" field. You can copy&paste the token of a private workspace into the input field in order to select it. Additional fields \"Backend URL\" and \"Artifact Analyzer URL\" can be used to connect the frontend to another backend (than the default running on the same host). Generally, this must not be changed by the users. Once you have selected a workspace, press \"Save\" button. The list of applications of that workspace will be automatically loaded on the left list menu of the frontend. Edit a workspace (in the apps Web frontend) \u00b6 In order to edit a workspace, press the same button as to choose a workspace and perform the following steps: Enter the name/token id of the workspace to edit in the \"Space\" field and eventually select one of the entries provided in the drop down list. press the \"Edit Space\" button at the bottom. Once this button is clicked, all the editable property-fields of the workspace are displayed. update/change the data of your workspace as per your expectations. Press the \"Save\" button to save your modifications, press the \"close\" button to revert your changes. Export Analysis Results \u00b6 The following REST API can be used to export findings (information about vulnerable dependencies) to JSON, either for entire workspaces or for single applications. For aggregated workspaces, call HTTP GET http://localhost:8033/backend/hubIntegration/apps/<workspace-name>%20(<workspace-token>)/vulndeps . For single applications, call HTTP GET http://localhost:8033/backend/hubIntegration/apps/<workspace-name>%20(<workspace-token>)%20<group>:<artifact>:<version>/vulndeps The API returns an array of JSON elements having the following data model: Property Description Possible Values projectId Identifies the affected application and dependency ( <app-GAV> > <dep-filename> ) type Identifier of vulnerability in Eclipse Steady knowledge base scope Scope of the dependency see official Maven documentation priority Priority of the finding 3 in case of dependencies with scope TEST and PROVIDED, 1 otherwise exemptionReason Assessment description (if any), see report goal for more information on how-to assess and exempt findings state Assessment result (if any) 1 (secure-by-design) in case of dependencies with scope TEST and PROVIDED, 4 (mitigated) in case the bug has been exempted, 2 (true-positive) otherwise status Indicates whether the finding has been assessed 1 (audited) in case state is 1 or 4, -1 (non-audited) otherwise count Number of findings of type type in project Always 1 snapshotDate Date of most recent goal execution of the application (any goal) Setup \u00b6 Maven \u00b6 The plugin for Maven can be used with or without adding a <profile> section to the pom.xml . With profile , the execution of goals is more concise (readable), e.g., mvn -Dsteady compile steady:app . A sample profile can be found here , just copy&paste it into the <profiles> section of your pom.xml . In case of aggregated, multi-module Maven projects with modules inheriting from their parent, it is sufficient to include the profile in the top-level (parent) pom.xml . If a module does not inherit from the parent, the profile has to be added to its POM file. Once added, run mvn -Dsteady versions:display-property-updates every now and then to check whether there are new plugin versions available. If so, manually update the property vulas.version in the Eclipse Steady profile. Without profile , the execution of goals requires the use of the plugin's fully qualified name, e.g., mvn compile org.eclipse.steady:plugin-maven:3.2.2:app . Moreover, you need to specify the following mandatory configuration settings. As described here , there are several ways of doing so, however, a file as follows is very common: steady-custom.properties vulas.core.space.token = <YOUR WORKSPACE TOKEN> vulas.shared.backend.serviceUrl = http://localhost:8033/backend/ It is possible to include/exclude modules of a multi-module Maven project using the following configuration parameters: # Options to include and exclude Maven artifacts (modules) during the processing of an aggregator project. # If includes is provided, the other parameters are ignored. In other words, excludes and ignorePoms will # only be evaluated if includes is empty. # # Important: Those options are ignored in case of the report goal, thus, report will be run on all modules. # In particular, running report on a module with packaging POM will create an aggregated report for all its # submodules. # # One has to provide the artifactId (not the module name), and multiple values for includes and excludes must # be separated by comma. # # Defaults: # includes = - # excludes = - # ignorePoms = false vulas.maven.includes = vulas.maven.excludes = vulas.maven.ignorePoms = false Gradle \u00b6 The plugin for Gradle requires changes of the following files: build.gradle buildscript { repositories { maven { url '<PACKAGE-REPO>' } mavenCentral() } dependencies { classpath('org.eclipse.steady:plugin-gradle:3.2.2') { changing = true } } } allprojects { apply plugin: \"steady\" } gradle.properties // Used to identify the scan in the apps Web frontend group = ### group - EDIT THIS ### version = ### version - EDIT THIS ### // Replace token of test space vulas.core.space.token = ### workspace token - EDIT THIS ### vulas.shared.backend.serviceUrl = http://localhost:8033/backend/ Note: Rather than adding configuration settings to gradle.properties , they can also be passed as project properties in the command line, e.g., -Pvulas.report.exceptionThreshold=noException . The use of -D system properties for changing configuration settings is discouraged (because of the cache of the Gradle daemon). The configuration is correct if the analysis goals vulasApp , vulasA2C etc. are listed among \"Other tasks\" when running the following command: ./gradlew tasks -all The Gradle plugin only works with later releases of Gradle. How to upgrade is described here . Command-line interface \u00b6 Create a new folder, download the latest ZIP archive steady-cli-3.2.2.zip from Releases and extract it into the newly created folder. This folder will then contain the following items: Folder/File Description ./app/ Put the application code (java, class or JAR files) and all application dependencies (JAR files) into this folder. It will be searched recursively, thus, it is possible to just copy the entire installation directory of an application into the folder. Important : (1) Single java and class files are always considered as application code, no matter the package prefix configured with vulas.core.app.appPrefixes . (2) JARs are always considered as application dependency unless they only contain methods starting with the configured package prefix. (3) Nested JARs must be extracted, WARs can stay as-is. ./steady-cli-3.2.2-jar-with-dependencies.jar An executable JAR used to run the different Eclipse Steady goals. ./instr/lang-java-3.2.2-jar-with-dependencies.jar Used to instrument Java runtimes. ./steady-custom.properties.sample Configuration settings for Eclipse Steady. Important : (1) Rename the file to steady-custom.properties . (2) Specify <GROUP> , <ARTIFACT> and <VERSION> of the application to be analyzed. (3) Specify how Eclipse Steady identifies your application code (either using vulas.core.app.appPrefixes or vulas.core.app.appJarNames , see below for more information). (4) Specify the workspace token vulas.core.space.token . Identification of application code : You can use vulas.core.app.appPrefixes or vulas.core.app.appJarNames to tell Eclipse Steady how to identify the code of your application, which is important for the call graph construction during the a2c reachability analysis. This analysis is not complete if not all the relevant application methods are used as entry points for the call graph construction. As such, the potential execution of vulnerable open-source methods may be missed. A good indicator to see whether specification is correct is to see whether there are items in the Dependencies tab that are created by you (or your organization), or whether there are open-source packages mentioned in the table on the Statistics tab. # Package prefix(es) of application code (multiple values to be separated by comma), only relevant for CLI vulas.core.app.appPrefixes = # Regex that identifies JARs with application code (multiple values to be separated by comma), only relevant for CLI vulas.core.app.appJarNames = Configuration \u00b6 Layered configuration principle \u00b6 The client-side analysis tools can be configured in different ways. At runtime, the following layers are combined in order to establish the effective configuration (which is printed to console upon goal execution). Java system properties : Can be specified when running java or mvn , each setting must be prefixed with -D Property files in file system : Can be specified by adding property file(s) in the folder where Eclipse Steady is executed (or any of its subfolders). The file name must adhere to the format steady-*.properties , and its entries must be specified according to the Java spec Plugin configuration : Maven: Can be specified in the <layeredConfiguration> section of the Maven plugin Gradle: todo Environment variables : Can be specified using export (nix) and set (Windows) Property files in JAR files : Default values for many settings are set within Eclipse Steady JAR files General settings \u00b6 The following settings, however, have to be present for every goal execution: vulas.core.space.token : The token of the workspace to be used for the analysis vulas.core.appContext.group , vulas.core.appContext.artifact and vulas.core.appContext.version : Altogether, they uniquely identify an application within a space. Depending on the client used, one or more of them are automatically inferred, e.g., using data from pom.xml or build.gradle . vulas.shared.backend.serviceUrl : The URL of the backend service to which clients upload analysis results. Log level \u00b6 The default Log4j log level is INFO , it can be adjusted with help of system property vulas.log4j.threshold , e.g., -Dvulas.log4j.threshold=WARN . Check setup \u00b6 Proceed as follows to check whether the Eclipse Steady setup and goal execution works: On the client , after executing a specific Eclipse Steady goal on your application, a log entry similar to the one below should be printed to the console. It is used to upload goal-related information to the Eclipse Steady backend, e.g., the Eclipse Steady version used or the average memory consumption. In this example, information related to a goal execution for an application with GAV com.acme.foo:vulas-testapp-webapp:3.0.9-MVN was uploaded to http://localhost:8033/backend/ , workspace 123456789 . The successful upload is indicated by the HTTP response code 201 . [main] INFO com.sap.psr.vulas.backend.requests.BasicHttpRequest - HTTP POST [uri=http://localhost:8033/backend/apps/com.acme.foo/vulas-testapp-webapp/3.0.9-MVN/goals, size=23,50 KB, tenant=123456789, space=123456789] [main] INFO com.sap.psr.vulas.backend.requests.BasicHttpRequest - HTTP POST completed with response code [201] in [03.019 ms] (proxy=false) In the apps Web frontend at http://localhost:8033/apps , there are several tabs to be checked: On the Dependencies tab, one should see all application dependencies. In particular, there should be no archives belonging to the application under analysis (which can happen if the CLI is not configured to properly separate application code and dependency code, see here for more information). On the Statistics tab, one should see all packages belonging to the application. In particular, there should be no packages belonging to 3 rd party / open-source libraries (which can happen if the CLI is not configured to properly separate application code and dependency code, see here for more information). On the History tab, one should see table entries for all goal executions that happened on the client.","title":"Configuration"},{"location":"user/manuals/setup/#setup-and-configuration-manual","text":"","title":"Setup and Configuration Manual"},{"location":"user/manuals/setup/#workspace","text":"A workspace acts as a container to group the results of several application analyses. In that context, please note that each module of a multi-module Maven project appears as a separate application in the Eclipse Steady Web frontend. Before using workspaces, you need to create one using the Eclipse Steady Web frontend (see below); you will obtain a token that you will need to pass as a configuration parameter when performing scans.","title":"Workspace"},{"location":"user/manuals/setup/#create-workspaces-once","text":"You need to create a workspace once using the Eclipse Steady Web frontend. Use the \"create workspace\" icon in the lower-left corner toolbar of the apps Web frontend to do so. A workspace has the following properties: Name : Must be provided. Note that the name is not unique, thus, there can be several workspaces having the same name. Description : Must be provided. Contact : Please provide the email address of a distribution list (DL). Export results : AGGREGATED : Findings are aggregated on workspace-level, one item for the entire workspace will be exported DETAILED : Findings are aggregated on application-level, one item for every application of the workspace will be exported OFF : No export of findings Public : A public workspace appears in the drop-down box of the apps Web frontend, a private one does not Once the fields have been filled, press the \"Save\" button. The system then returns with a pop-up containing the random token generated upon workspace creation. Do not forget to note down this token, it will be needed later on for each scan of your application(s).","title":"Create workspace(s) (once)"},{"location":"user/manuals/setup/#use-the-generated-token-during-application-analysis","text":"The workspace token generated at previous step has to be used as value for the configuration setting vulas.core.space.token . This information is mandatory during the scans as it allows the user's data to be uploaded to the correct place/workspace in the Eclipse Steady backend. See here for more information regarding the configuration of Eclipse Steady clients.","title":"Use the generated token (during application analysis)"},{"location":"user/manuals/setup/#choose-a-workspace-in-the-apps-web-frontend","text":"Use the configuration icon in the lower-left corner in order to select a workspace. You can search for public workspaces by typing their name in the \"Space\" field. You can copy&paste the token of a private workspace into the input field in order to select it. Additional fields \"Backend URL\" and \"Artifact Analyzer URL\" can be used to connect the frontend to another backend (than the default running on the same host). Generally, this must not be changed by the users. Once you have selected a workspace, press \"Save\" button. The list of applications of that workspace will be automatically loaded on the left list menu of the frontend.","title":"Choose a workspace (in the apps Web frontend)"},{"location":"user/manuals/setup/#edit-a-workspace-in-the-apps-web-frontend","text":"In order to edit a workspace, press the same button as to choose a workspace and perform the following steps: Enter the name/token id of the workspace to edit in the \"Space\" field and eventually select one of the entries provided in the drop down list. press the \"Edit Space\" button at the bottom. Once this button is clicked, all the editable property-fields of the workspace are displayed. update/change the data of your workspace as per your expectations. Press the \"Save\" button to save your modifications, press the \"close\" button to revert your changes.","title":"Edit a workspace (in the apps Web frontend)"},{"location":"user/manuals/setup/#export-analysis-results","text":"The following REST API can be used to export findings (information about vulnerable dependencies) to JSON, either for entire workspaces or for single applications. For aggregated workspaces, call HTTP GET http://localhost:8033/backend/hubIntegration/apps/<workspace-name>%20(<workspace-token>)/vulndeps . For single applications, call HTTP GET http://localhost:8033/backend/hubIntegration/apps/<workspace-name>%20(<workspace-token>)%20<group>:<artifact>:<version>/vulndeps The API returns an array of JSON elements having the following data model: Property Description Possible Values projectId Identifies the affected application and dependency ( <app-GAV> > <dep-filename> ) type Identifier of vulnerability in Eclipse Steady knowledge base scope Scope of the dependency see official Maven documentation priority Priority of the finding 3 in case of dependencies with scope TEST and PROVIDED, 1 otherwise exemptionReason Assessment description (if any), see report goal for more information on how-to assess and exempt findings state Assessment result (if any) 1 (secure-by-design) in case of dependencies with scope TEST and PROVIDED, 4 (mitigated) in case the bug has been exempted, 2 (true-positive) otherwise status Indicates whether the finding has been assessed 1 (audited) in case state is 1 or 4, -1 (non-audited) otherwise count Number of findings of type type in project Always 1 snapshotDate Date of most recent goal execution of the application (any goal)","title":"Export Analysis Results"},{"location":"user/manuals/setup/#setup","text":"","title":"Setup"},{"location":"user/manuals/setup/#maven","text":"The plugin for Maven can be used with or without adding a <profile> section to the pom.xml . With profile , the execution of goals is more concise (readable), e.g., mvn -Dsteady compile steady:app . A sample profile can be found here , just copy&paste it into the <profiles> section of your pom.xml . In case of aggregated, multi-module Maven projects with modules inheriting from their parent, it is sufficient to include the profile in the top-level (parent) pom.xml . If a module does not inherit from the parent, the profile has to be added to its POM file. Once added, run mvn -Dsteady versions:display-property-updates every now and then to check whether there are new plugin versions available. If so, manually update the property vulas.version in the Eclipse Steady profile. Without profile , the execution of goals requires the use of the plugin's fully qualified name, e.g., mvn compile org.eclipse.steady:plugin-maven:3.2.2:app . Moreover, you need to specify the following mandatory configuration settings. As described here , there are several ways of doing so, however, a file as follows is very common: steady-custom.properties vulas.core.space.token = <YOUR WORKSPACE TOKEN> vulas.shared.backend.serviceUrl = http://localhost:8033/backend/ It is possible to include/exclude modules of a multi-module Maven project using the following configuration parameters: # Options to include and exclude Maven artifacts (modules) during the processing of an aggregator project. # If includes is provided, the other parameters are ignored. In other words, excludes and ignorePoms will # only be evaluated if includes is empty. # # Important: Those options are ignored in case of the report goal, thus, report will be run on all modules. # In particular, running report on a module with packaging POM will create an aggregated report for all its # submodules. # # One has to provide the artifactId (not the module name), and multiple values for includes and excludes must # be separated by comma. # # Defaults: # includes = - # excludes = - # ignorePoms = false vulas.maven.includes = vulas.maven.excludes = vulas.maven.ignorePoms = false","title":"Maven"},{"location":"user/manuals/setup/#gradle","text":"The plugin for Gradle requires changes of the following files: build.gradle buildscript { repositories { maven { url '<PACKAGE-REPO>' } mavenCentral() } dependencies { classpath('org.eclipse.steady:plugin-gradle:3.2.2') { changing = true } } } allprojects { apply plugin: \"steady\" } gradle.properties // Used to identify the scan in the apps Web frontend group = ### group - EDIT THIS ### version = ### version - EDIT THIS ### // Replace token of test space vulas.core.space.token = ### workspace token - EDIT THIS ### vulas.shared.backend.serviceUrl = http://localhost:8033/backend/ Note: Rather than adding configuration settings to gradle.properties , they can also be passed as project properties in the command line, e.g., -Pvulas.report.exceptionThreshold=noException . The use of -D system properties for changing configuration settings is discouraged (because of the cache of the Gradle daemon). The configuration is correct if the analysis goals vulasApp , vulasA2C etc. are listed among \"Other tasks\" when running the following command: ./gradlew tasks -all The Gradle plugin only works with later releases of Gradle. How to upgrade is described here .","title":"Gradle"},{"location":"user/manuals/setup/#command-line-interface","text":"Create a new folder, download the latest ZIP archive steady-cli-3.2.2.zip from Releases and extract it into the newly created folder. This folder will then contain the following items: Folder/File Description ./app/ Put the application code (java, class or JAR files) and all application dependencies (JAR files) into this folder. It will be searched recursively, thus, it is possible to just copy the entire installation directory of an application into the folder. Important : (1) Single java and class files are always considered as application code, no matter the package prefix configured with vulas.core.app.appPrefixes . (2) JARs are always considered as application dependency unless they only contain methods starting with the configured package prefix. (3) Nested JARs must be extracted, WARs can stay as-is. ./steady-cli-3.2.2-jar-with-dependencies.jar An executable JAR used to run the different Eclipse Steady goals. ./instr/lang-java-3.2.2-jar-with-dependencies.jar Used to instrument Java runtimes. ./steady-custom.properties.sample Configuration settings for Eclipse Steady. Important : (1) Rename the file to steady-custom.properties . (2) Specify <GROUP> , <ARTIFACT> and <VERSION> of the application to be analyzed. (3) Specify how Eclipse Steady identifies your application code (either using vulas.core.app.appPrefixes or vulas.core.app.appJarNames , see below for more information). (4) Specify the workspace token vulas.core.space.token . Identification of application code : You can use vulas.core.app.appPrefixes or vulas.core.app.appJarNames to tell Eclipse Steady how to identify the code of your application, which is important for the call graph construction during the a2c reachability analysis. This analysis is not complete if not all the relevant application methods are used as entry points for the call graph construction. As such, the potential execution of vulnerable open-source methods may be missed. A good indicator to see whether specification is correct is to see whether there are items in the Dependencies tab that are created by you (or your organization), or whether there are open-source packages mentioned in the table on the Statistics tab. # Package prefix(es) of application code (multiple values to be separated by comma), only relevant for CLI vulas.core.app.appPrefixes = # Regex that identifies JARs with application code (multiple values to be separated by comma), only relevant for CLI vulas.core.app.appJarNames =","title":"Command-line interface"},{"location":"user/manuals/setup/#configuration","text":"","title":"Configuration"},{"location":"user/manuals/setup/#layered-configuration-principle","text":"The client-side analysis tools can be configured in different ways. At runtime, the following layers are combined in order to establish the effective configuration (which is printed to console upon goal execution). Java system properties : Can be specified when running java or mvn , each setting must be prefixed with -D Property files in file system : Can be specified by adding property file(s) in the folder where Eclipse Steady is executed (or any of its subfolders). The file name must adhere to the format steady-*.properties , and its entries must be specified according to the Java spec Plugin configuration : Maven: Can be specified in the <layeredConfiguration> section of the Maven plugin Gradle: todo Environment variables : Can be specified using export (nix) and set (Windows) Property files in JAR files : Default values for many settings are set within Eclipse Steady JAR files","title":"Layered configuration principle"},{"location":"user/manuals/setup/#general-settings","text":"The following settings, however, have to be present for every goal execution: vulas.core.space.token : The token of the workspace to be used for the analysis vulas.core.appContext.group , vulas.core.appContext.artifact and vulas.core.appContext.version : Altogether, they uniquely identify an application within a space. Depending on the client used, one or more of them are automatically inferred, e.g., using data from pom.xml or build.gradle . vulas.shared.backend.serviceUrl : The URL of the backend service to which clients upload analysis results.","title":"General settings"},{"location":"user/manuals/setup/#log-level","text":"The default Log4j log level is INFO , it can be adjusted with help of system property vulas.log4j.threshold , e.g., -Dvulas.log4j.threshold=WARN .","title":"Log level"},{"location":"user/manuals/setup/#check-setup","text":"Proceed as follows to check whether the Eclipse Steady setup and goal execution works: On the client , after executing a specific Eclipse Steady goal on your application, a log entry similar to the one below should be printed to the console. It is used to upload goal-related information to the Eclipse Steady backend, e.g., the Eclipse Steady version used or the average memory consumption. In this example, information related to a goal execution for an application with GAV com.acme.foo:vulas-testapp-webapp:3.0.9-MVN was uploaded to http://localhost:8033/backend/ , workspace 123456789 . The successful upload is indicated by the HTTP response code 201 . [main] INFO com.sap.psr.vulas.backend.requests.BasicHttpRequest - HTTP POST [uri=http://localhost:8033/backend/apps/com.acme.foo/vulas-testapp-webapp/3.0.9-MVN/goals, size=23,50 KB, tenant=123456789, space=123456789] [main] INFO com.sap.psr.vulas.backend.requests.BasicHttpRequest - HTTP POST completed with response code [201] in [03.019 ms] (proxy=false) In the apps Web frontend at http://localhost:8033/apps , there are several tabs to be checked: On the Dependencies tab, one should see all application dependencies. In particular, there should be no archives belonging to the application under analysis (which can happen if the CLI is not configured to properly separate application code and dependency code, see here for more information). On the Statistics tab, one should see all packages belonging to the application. In particular, there should be no packages belonging to 3 rd party / open-source libraries (which can happen if the CLI is not configured to properly separate application code and dependency code, see here for more information). On the History tab, one should see table entries for all goal executions that happened on the client.","title":"Check setup"},{"location":"user/manuals/updating_vuln_data/","text":"Updating Vulnerability Data \u00b6 The process of importing vulnerability data from Project KB to the backend of Eclipse Steady is realized using two tools in combination: kaybee (from project KB) kb-importer (part of Eclipse Steady). This document describes the overall process but we refer to the documentation of project KB for further details on kaybee . Process overview \u00b6 kaybee is used to download vulnerability data from project KB (and possibly from other user-defined sources) and to produce a script via its export command (the script is called steady.sh in the following). By executing the steady.sh script obtained via the kaybee export command, the vulnerability data are imported to the target backend system (specified a the top of the script -- the user is supposed to edit it before running it). Because kb-importer is invoked from the steady.sh script, in practice you should never have the need to invoke it directly; from the user perspective, the process effectively boils down to: obtaining vulnerability data from project KB using kaybee running the steady.sh script generated by kaybee to send such data to the Eclipse Steady backend (the script, under the hood, uses kb-importer ). Setup \u00b6 Use the following link to setup and configure project KB - installing-the-kaybee-tool . Update the variables in kaybeeconf.yaml configuration file. The variables are USER_TOKEN - Token specified in your Steady .env file. BACKEND_URL - URL of the rest-backend service (Mandatory). CIA_URL - URL of the deployed rest-lib-util service (This is used if you are uploading the affected artifacts). KB_IMPORTER_PATH - Jar path of your kb-importer module. Usage \u00b6 Run kaybee merge to get the vulnerablity information from project KB. Run kaybee export -t steady to produce the shell script steady.sh which is is then run to update all vulnerability data in Steady. To get specific vulnerability information run kaybee export -t steady -f .kaybee/merged/CVE-2019-0191/statement.yaml which outputs a shell script steady.sh which is is then run to update CVE-2019-0191 vulnerability data in Steady. KB-importer: Technical Documentation \u00b6 This information is to know how KB-Importer works in detail. In order for the tool to work, it assumes a particular directory structure and content to be available, as documented below. NOTE: the structure and the files are automatically generated by the shell script obtained by running the kaybee export command as shown above, none of the following is supposed to be created manually! To add a vulnerability manually using KB-Importer the following folder structure and command has to be used: Command Line arguments for KB-Importer: directory (-d) <arg> : A directory containing commits information for a vulnerability. More details regarding the directory structure is shown below. overwrite (-o) : Overwrite the analysis of a vulnerability if it already exists in the backend. upload (-u) : Upload construct changes. Without the -u option, the resulting JSON will be saved to file for you to review (e.g., to check that the list of construct changes is not empty). verbose (-v) : Verbose mode to get more detailed logs. Other useful/required configurations: vulas.shared.backend.serviceUrl : URL of the deployed rest-backend service (Mandatory). vulas.shared.cia.serviceUrl : URL of the deployed rest-lib-util service (This is used if you are uploading the affected artifacts as shown in the below example). Directory structure should be as follows: vulnerability_dir #vulnerability directory specified with option -d. Note: The directory name need not be the same as the vulnerability id \u251c\u2500\u2500 commit1_dir #commit directory. Note: The directory name need not be the same as the commit id \u2502 \u251c\u2500\u2500 before #directory containing the files/folders before the vulnerability fix \u2502 \u251c\u2500\u2500 after #directory containing the files/folders after the vulnerability fix \u2502 \u2514\u2500\u2500 metadata.json #commit metadata file for each commit. More info can be found below \u251c\u2500\u2500 commit2_dir #mutiple commit directories if there are mutiple commits for a vulnerability fix \u2502 \u251c\u2500\u2500 before \u2502 \u251c\u2500\u2500 after \u2502 \u2514\u2500\u2500 metadata.json \u2514\u2500\u2500 metadata.json #vulnerability metadata file Vulnerability metadata.json example: { \"vulnerability_id\" : \"CVE-2016-1000338\" , \"aliases\" : [ \"VULN-1000338\" , \"VULN-0002\" ], \"affected_artifacts\" : [ { \"id\" : \"pkg:maven/org.bouncycastle/bcprov-jdk15on@1.47\" , \"reason\" : \"Manual review\" , \"affected\" : true }, { \"id\" : \"pkg:maven/org.bouncycastle/bcprov-jdk15@1.43\" , \"reason\" : \"Manual review\" , \"affected\" : false } ], \"notes\" : [ { \"links\" : [ \"https://www.bouncycastle.org/releasenotes.html\" , \"https://ubuntu.com/security/notices/USN-3727-1\" ], \"text\" : \"In Bouncy Castle JCE Provider version 1.55 and earlier the DSA does not fully validate ASN.1 encoding of signature on verification. It is possible to inject extra elements in the sequence making up the signature and still have it validate, which in some cases may allow the introduction of 'invisible' data into a signed structure.\" }, { \"links\" : [ \"https://lists.debian.org/debian-lts-announce/2018/07/msg00009.html\" ], \"text\" : \"It was discovered that Bouncy Castle incorrectly handled certain crypto algorithms. A remote attacker could possibly use these issues to obtain sensitive information, including private keys.\" } ] } Information about the fields of vulnerability metadata.json file: vulnerability_id : Vulnerability ID. aliases : Aliases used for the vulnerability id. affected_artifacts : Affected Libraries for the vulnerability. notes : This is an array of links and text . Here, the links array consists of links which provide comprehensive vulnerability information and the text is the vulnerability description. (optional, it must be provided for vulnerabilities not available from the NVD). Commit metadata.json example file: { \"repository\" : \"https://github.com/bcgit/bc-java\" , \"branch\" : \"DEFAULT_BRANCH\" , \"timestamp\" : \"1476490865\" , \"commit_id\" : \"843c2e60f67d71faf81d236f448ebbe56c62c647\" } Information about the fields of commit metadata.json file: repository : URL of the VCS repository hosting the library project. branch : Branch name. timestamp : Timestamp when the commit was made. commit_id : VCS commit id. Example run for kb-importer: java -Dvulas.shared.backend.header.X-Vulas-Client-Token = <token> -Dvulas.shared.cia.serviceUrl = <cia-url> -Dvulas.shared.backend.serviceUrl = <backend-url> -jar kb-importer-3.1.14-SNAPSHOT-jar-with-dependencies.jar -d ./CVEdata/CVE-2016-1000338 -v -u -o Limitation \u00b6 Project KB only supports Java specific vulnerabilities. Python vulnerabilities will be supported once For python, init files are to be checked out is fixed.","title":"Updating Vulnerability Data"},{"location":"user/manuals/updating_vuln_data/#updating-vulnerability-data","text":"The process of importing vulnerability data from Project KB to the backend of Eclipse Steady is realized using two tools in combination: kaybee (from project KB) kb-importer (part of Eclipse Steady). This document describes the overall process but we refer to the documentation of project KB for further details on kaybee .","title":"Updating Vulnerability Data"},{"location":"user/manuals/updating_vuln_data/#process-overview","text":"kaybee is used to download vulnerability data from project KB (and possibly from other user-defined sources) and to produce a script via its export command (the script is called steady.sh in the following). By executing the steady.sh script obtained via the kaybee export command, the vulnerability data are imported to the target backend system (specified a the top of the script -- the user is supposed to edit it before running it). Because kb-importer is invoked from the steady.sh script, in practice you should never have the need to invoke it directly; from the user perspective, the process effectively boils down to: obtaining vulnerability data from project KB using kaybee running the steady.sh script generated by kaybee to send such data to the Eclipse Steady backend (the script, under the hood, uses kb-importer ).","title":"Process overview"},{"location":"user/manuals/updating_vuln_data/#setup","text":"Use the following link to setup and configure project KB - installing-the-kaybee-tool . Update the variables in kaybeeconf.yaml configuration file. The variables are USER_TOKEN - Token specified in your Steady .env file. BACKEND_URL - URL of the rest-backend service (Mandatory). CIA_URL - URL of the deployed rest-lib-util service (This is used if you are uploading the affected artifacts). KB_IMPORTER_PATH - Jar path of your kb-importer module.","title":"Setup"},{"location":"user/manuals/updating_vuln_data/#usage","text":"Run kaybee merge to get the vulnerablity information from project KB. Run kaybee export -t steady to produce the shell script steady.sh which is is then run to update all vulnerability data in Steady. To get specific vulnerability information run kaybee export -t steady -f .kaybee/merged/CVE-2019-0191/statement.yaml which outputs a shell script steady.sh which is is then run to update CVE-2019-0191 vulnerability data in Steady.","title":"Usage"},{"location":"user/manuals/updating_vuln_data/#kb-importer-technical-documentation","text":"This information is to know how KB-Importer works in detail. In order for the tool to work, it assumes a particular directory structure and content to be available, as documented below. NOTE: the structure and the files are automatically generated by the shell script obtained by running the kaybee export command as shown above, none of the following is supposed to be created manually! To add a vulnerability manually using KB-Importer the following folder structure and command has to be used: Command Line arguments for KB-Importer: directory (-d) <arg> : A directory containing commits information for a vulnerability. More details regarding the directory structure is shown below. overwrite (-o) : Overwrite the analysis of a vulnerability if it already exists in the backend. upload (-u) : Upload construct changes. Without the -u option, the resulting JSON will be saved to file for you to review (e.g., to check that the list of construct changes is not empty). verbose (-v) : Verbose mode to get more detailed logs. Other useful/required configurations: vulas.shared.backend.serviceUrl : URL of the deployed rest-backend service (Mandatory). vulas.shared.cia.serviceUrl : URL of the deployed rest-lib-util service (This is used if you are uploading the affected artifacts as shown in the below example). Directory structure should be as follows: vulnerability_dir #vulnerability directory specified with option -d. Note: The directory name need not be the same as the vulnerability id \u251c\u2500\u2500 commit1_dir #commit directory. Note: The directory name need not be the same as the commit id \u2502 \u251c\u2500\u2500 before #directory containing the files/folders before the vulnerability fix \u2502 \u251c\u2500\u2500 after #directory containing the files/folders after the vulnerability fix \u2502 \u2514\u2500\u2500 metadata.json #commit metadata file for each commit. More info can be found below \u251c\u2500\u2500 commit2_dir #mutiple commit directories if there are mutiple commits for a vulnerability fix \u2502 \u251c\u2500\u2500 before \u2502 \u251c\u2500\u2500 after \u2502 \u2514\u2500\u2500 metadata.json \u2514\u2500\u2500 metadata.json #vulnerability metadata file Vulnerability metadata.json example: { \"vulnerability_id\" : \"CVE-2016-1000338\" , \"aliases\" : [ \"VULN-1000338\" , \"VULN-0002\" ], \"affected_artifacts\" : [ { \"id\" : \"pkg:maven/org.bouncycastle/bcprov-jdk15on@1.47\" , \"reason\" : \"Manual review\" , \"affected\" : true }, { \"id\" : \"pkg:maven/org.bouncycastle/bcprov-jdk15@1.43\" , \"reason\" : \"Manual review\" , \"affected\" : false } ], \"notes\" : [ { \"links\" : [ \"https://www.bouncycastle.org/releasenotes.html\" , \"https://ubuntu.com/security/notices/USN-3727-1\" ], \"text\" : \"In Bouncy Castle JCE Provider version 1.55 and earlier the DSA does not fully validate ASN.1 encoding of signature on verification. It is possible to inject extra elements in the sequence making up the signature and still have it validate, which in some cases may allow the introduction of 'invisible' data into a signed structure.\" }, { \"links\" : [ \"https://lists.debian.org/debian-lts-announce/2018/07/msg00009.html\" ], \"text\" : \"It was discovered that Bouncy Castle incorrectly handled certain crypto algorithms. A remote attacker could possibly use these issues to obtain sensitive information, including private keys.\" } ] } Information about the fields of vulnerability metadata.json file: vulnerability_id : Vulnerability ID. aliases : Aliases used for the vulnerability id. affected_artifacts : Affected Libraries for the vulnerability. notes : This is an array of links and text . Here, the links array consists of links which provide comprehensive vulnerability information and the text is the vulnerability description. (optional, it must be provided for vulnerabilities not available from the NVD). Commit metadata.json example file: { \"repository\" : \"https://github.com/bcgit/bc-java\" , \"branch\" : \"DEFAULT_BRANCH\" , \"timestamp\" : \"1476490865\" , \"commit_id\" : \"843c2e60f67d71faf81d236f448ebbe56c62c647\" } Information about the fields of commit metadata.json file: repository : URL of the VCS repository hosting the library project. branch : Branch name. timestamp : Timestamp when the commit was made. commit_id : VCS commit id. Example run for kb-importer: java -Dvulas.shared.backend.header.X-Vulas-Client-Token = <token> -Dvulas.shared.cia.serviceUrl = <cia-url> -Dvulas.shared.backend.serviceUrl = <backend-url> -jar kb-importer-3.1.14-SNAPSHOT-jar-with-dependencies.jar -d ./CVEdata/CVE-2016-1000338 -v -u -o","title":"KB-importer: Technical Documentation"},{"location":"user/manuals/updating_vuln_data/#limitation","text":"Project KB only supports Java specific vulnerabilities. Python vulnerabilities will be supported once For python, init files are to be checked out is fixed.","title":"Limitation"},{"location":"user/support/","text":"Getting help \u00b6 User support \u00b6 If you would like to try Eclipse Steady and you do not know where to start, our Tutorials provides a gentle, step-by-step walkthrough of your first scan. Also, an extensive documentation of the features, options and configuration settings of the tool can be found in User Guide . If you run into troubles, have a look at the list of Frequently Asked Questions . Bug reports \u00b6 If you encounter a bug while using Eclipse Steady, you are welcome to open an issue on GitHub giving a detailed description of what happened so that we can diagnose and resolve the problem (please, do search among the currently open issues to check if someone else has already reported the same problem). Receive news \u00b6 You can subscribe to our newsletter in case you want to receive updates by email: Simply write to vulas-news-request@listserv.sap.com with \"subscribe\" in the body.","title":"Getting help"},{"location":"user/support/#getting-help","text":"","title":"Getting help"},{"location":"user/support/#user-support","text":"If you would like to try Eclipse Steady and you do not know where to start, our Tutorials provides a gentle, step-by-step walkthrough of your first scan. Also, an extensive documentation of the features, options and configuration settings of the tool can be found in User Guide . If you run into troubles, have a look at the list of Frequently Asked Questions .","title":"User support"},{"location":"user/support/#bug-reports","text":"If you encounter a bug while using Eclipse Steady, you are welcome to open an issue on GitHub giving a detailed description of what happened so that we can diagnose and resolve the problem (please, do search among the currently open issues to check if someone else has already reported the same problem).","title":"Bug reports"},{"location":"user/support/#receive-news","text":"You can subscribe to our newsletter in case you want to receive updates by email: Simply write to vulas-news-request@listserv.sap.com with \"subscribe\" in the body.","title":"Receive news"},{"location":"user/support/faq/","text":"Warning This page provides answers and solutions to frequent questions and problems of Eclipse Steady end-users. Please review this material carefully before asking support, filing bug reports, or requesting new features. Only if you cannot find an answer to your questions in this page, please see the help to learn how to get support. LIST OF QUESTIONS General questions Why can't I compile my Maven project anymore after I activate the Eclipse Steady profile? Why does Eclipse Steady backend refuse HTTP connections established by Eclipse Steady Maven plugin? Why do all HTTP connections fail from the Eclipse Steady Maven plugin? Why does my workspace stay empty? What is the cause of the following ERROR: vulas-maven-plugin:3.x.x or one of its dependencies could not be resolved? Why do I get the following message: WARN: App does not exist in backend, goal upload skipped? Why does Eclipse Steady show vulnerabilities that are seemingly related to other components Understanding the results produced by Eclipse Steady Eclipse Steady reported vulnerabilities for which I found no data in NVD. What should I do about them? Why is Eclipse Steady is not detecting all vulnerabilities of my project? Method-level bill of material (goal app) app : NotFoundException when analyzing JAR files? app : The goal execution takes very long app : The goal execution breaks with a 5xx response code received from the backend app : The goal execution breaks with a java.nio.file.InvalidPathException Reachability Analysis (goals a2c and t2c) a2c : java.lang.OutOfMemoryError a2c : Timeout during reachability analysis a2c : java.io.FileNotFoundException? a2c : Invalid byte code in method? Instrumentation and trace collection (goals test and instr) TEST : java.lang.NoSuchMethodError? TEST : Not all Eclipse Steady analysis results are uploaded to the backend TEST : How to run -Dsteady test in projects using Mockito? TEST : Byte code instrumentation fails TEST : The forked VM terminated TEST : Incomplete app context TEST : \"Error injecting: private org.eclipse.aether.spi.log.Logger org.apache.maven.repository.internal.DefaultVersionResolver.logger\" JUnit tests using Powermock fail when using Eclipse Steady Python app goal is slow virtualenv problems Other topics report: The HTML result report is not properly rendered inside Jenkins No log messages of the Eclipse Steady Maven plugin appear on the console. Why? OutOfMemoryError: GC overhead limit exceeded? I get an error saying VerifyError: Inconsistent stackmap frames at branch target. What should I do? General questions \u00b6 Why can't I compile my Maven project anymore after I activate the Eclipse Steady profile? \u00b6 You may want to check whether there are other <profile> sections that declare dependencies. If so, one of those is probably activated by default. In this case, when using the Eclipse Steady profile, those other profiles will not be active, hence, there are dependencies missing, which can lead to compile exceptions. To fix, you should activate multiple profiles at once using the -P option, see here for more information. Why does Eclipse Steady backend refuse HTTP connections established by Eclipse Steady Maven plugin? \u00b6 The Eclipse Steady plugins gathers very detailed information about all Java archives required by an application. For example, it collects the method signatures of all methods contained in every JAR. For every archive, identified by its SHA1, this information must be uploaded to and stored by the Eclipse Steady backend in case it is not yet known. This requirement will cause a lot of uploads when an application is first analyzed, because a lot of dependencies may not be known. Problem: As a result of the above, it can happen that several HTTP POST connection requests are refused by the Eclipse Steady backend during the Eclipse Steady Maven plugin execution, which will result in error messages as follows. Copy&paste from console Solution Eclipse Steady plugin users can simply re-run the Eclipse Steady goal \"app\" multiple times up until the information for all archives has been uploaded. With each run, more and more archives will be successfully uploaded, up until a point where every archive is known. According to our experience, this is the case after a few runs only ( <5 ). Why do all HTTP connections fail from the Eclipse Steady Maven plugin? \u00b6 Problem Not a single HTTP connection can be established, which becomes obvious if even the first connection request hangs for several minutes and eventually fails as follows: [INFO] ------------------------------------------------------------------------ [INFO] Building com.at.example.spring-01 0.0.1-SNAPSHOT [INFO] ------------------------------------------------------------------------ [INFO] [INFO] --- maven-clean-plugin:2.5:clean (default-clean) @ com.at.example.spring-01 --- [INFO] Deleting C:\\My Documents\\com.at.example.spring-01\\target [INFO] [INFO] --- maven-dependency-plugin:2.10:copy (copy-vulas) @ com.at.example.spring-01 --- [INFO] Configured Artifact: org.eclipse.steady:vulas-core:jar-with-dependencies:1.1.0-SNAPSHOT:jar [INFO] Configured Artifact: org.eclipse.steady:vulas-core:jar-with-dependencies:1.1.0-SNAPSHOT:jar [INFO] Copying vulas-core-1.1.0-SNAPSHOT-jar-with-dependencies.jar to C:\\My Documents\\com.at.example.spring-01\\target\\vulas\\lib\\vulas-core-1.1.0-SNAPSHOT-jar-with-dependencies.jar [INFO] Copying vulas-core-1.1.0-SNAPSHOT-jar-with-dependencies.jar to C:\\My Documents\\com.at.example.spring-01\\target\\vulas\\include\\vulas-core-1.1.0-SNAPSHOT-jar-with-dependencies.jar [INFO] [INFO] --- vulas-maven-plugin:1.1.0-SNAPSHOT:clean (vulas-clean) @ com.at.example.spring-01 --- [main] INFO com.sap.psr.vulas.GoalExecution - Eclipse Steady goal execution started [id=CLEAN-1448374577441-14554386, goal=CLEAN, app=(com.at.example:com.at.example.spring-01:jar:0.0.1-SNAPSHOT)] [main] INFO com.sap.psr.vulas.backend.Collector - HTTP request started [url=, user=] [vulas-memo] INFO com.sap.psr.vulas.GoalExecution - Memory consumption (used/avg): [57.75 MB/57.75 MB], JVM (free/total/max): [183.75 MB/241.50 MB/3559.50 MB] [main] ERROR com.sap.psr.vulas.backend.Collector - HTTP request error while calling [], HTTP response written to [C:\\Users\\iXXXXXX\\AppData\\Local\\Temp\\vulas-tmp-8966348801119324800.html] Solution Run the Eclipse Steady Maven plugin with a different proxy than the default proxy specified in the configuration ( none ). You need to change 2 settings: On the command line, run Maven as follows, whereby <proxy> can be custom_proxy or simply proxy mvn -Dhttp.proxyHost = <proxy> -Dsteady steady:app In the Maven Surefire plugin, include the -Dhttp.proxyHost system property for the JVM spawned for JUnit tests: <plugin> <groupId> org.apache.maven.plugins </groupId> <artifactId> maven-surefire-plugin </artifactId> <version> 2.14 </version> <configuration> <argLine> ... -Dhttp.proxyHost=custom_proxy ... </argLine> </configuration> </plugin> Why does my workspace stay empty? \u00b6 When executing a vulas goal, your workspace is not filled with the results of the scan. Instead of this your results are usually uploaded to the PUBLIC workspace of the Eclipse Steady Frontend. You first need to insure that you are using at least version 3.0 of Eclipse Steady. The workspace feature was introduced with Eclipse Steady 3. By default, if you are running Eclipse Steady 2.x (and you should not!) all the data are stored in the \"PUBLIC\" workspace in the Eclipse Steady Frontend. Please notice that the Eclipse Steady plugin name was changed with Eclipse Steady 3: it was changed from vulas-maven-plugin to plugin-maven (click here for more details). It is quite usual that developers working with Jenkins/Piper are pointing to an old version of Eclipse Steady (2.x) because their Jenkins/Piper platform itself points to the old Eclipse Steady plugin name. A simple update there usually solves the issue. You need to insure that you have correctly indicated to Eclipse Steady where to upload the results of your scans (e.g. in your workspace). Please click here and here for details about workspaces and how to use them. What is the cause of the following ERROR: vulas-maven-plugin:3.x.x or one of its dependencies could not be resolved ? \u00b6 You are running the execution of a maven goal and are facing an error similar to the following one: [ERROR] Plugin org.eclipse.steady:vulas-maven-plugin:3.0.8 or one of its dependencies could not be resolved: Could not find artifact org.eclipse.steady:vulas-maven-plugin:jar:3.0.8 in mirror1 (url) -> [Help 1] You most probably updated your settings to use Maven 3.x instead of Maven 2.x. The Eclipse Steady plugin was renamed with Eclipse Steady 3.x: it was changed from vulas-maven-plugin to plugin-maven . You may need to update your settings accordingly (click here for more details on how to update your settings). Why do I get the following message: WARN: App does not exist in backend, goal upload skipped ? \u00b6 Symptom : The console contains a log message as follows: WARN com.sap.psr.vulas.backend.BackendConnector - App [group=com.acme, artifact=parent, version=1-SNAPSHOT, packaging=pom] does not exist in backend, goal upload skipped Explanation : Information related to the execution of a goal, e.g., execution time or memory consumption, cannot be uploaded as the respective application does not exist in the backend. This is not necessarily a problem, hence, the message is issued as warning. Examples where an application does not exist in the backend are as follows: If an application does neither have any dependencies nor source code, e.g., in folder src/main/java , it will not be uploaded to the backend (depending on configuration parameter vulas.core.app.uploadEmpty , which defaults to false ). In this case, the execution of goal execution information cannot be uploaded. Typical examples of empty applications are Maven aggregator projects ( <packaging>pom</packaging> ). If an application version is analyzed for the first time, the initial execution of the clean goal will also result in this warning message. Why does Eclipse Steady show vulnerabilities that are seemingly related to other components \u00b6 Symptom : In the Web frontend or in the report, Eclipse Steady displays findings which seem to be related to others components. Example : In the following screenshot, several CVEs related to jackson-databind are shown for spring-cloud-cloudfoundry-connector . Explanation : Eclipse Steady detects the presence of vulnerable code, no matter the file name or GAV of a dependency. Sometimes, an archive re-bundles code of other open source projects. Sometimes, re-bundled code is even re-packaged, thus, the Java package namespace is altered. Both of those cases are still detected by Eclipse Steady. In the previous example, the file spring-cloud-cloudfoundry-connector-2.0.5.RELEASE.jar contains (re-bundles) vulnerable code of jackson-databind . Understanding the results produced by Eclipse Steady \u00b6 Eclipse Steady reported vulnerabilities for which I found no data in NVD. What should I do about them? \u00b6 For vulnerabilities that do not come from the NVD we do provide reference links. They are listed in the vulnerability details page accessible clicking on the different rows of the vulnerability main table (see example below). Why is Eclipse Steady is not detecting all vulnerabilities of my project? \u00b6 If the vulnerability is included in our knowledge base but it is not detected for your application, you can select the checkbox \u201cInclude historical vulnerabilities\u201d in the Eclipse Steady frontend and hit \u201cReload\u201d button: you will see all CVEs that applied to previous versions of your dependencies. The indicates that a given CVE did apply to earlier versions, but you are currently using a non-vulnerable one. Despite our best efforts to keep the Eclipse Steady vulnerability knowledge base continuously updated, it is possible that a particular vulnerability is not yet covered. Query /backend/bugs to check if a vulnerability is covered or not. Method-level bill of material (goal app) \u00b6 app : NotFoundException when analyzing JAR files? \u00b6 Problem: When analyzing JAR files, error messages similar to the following are printed: ERROR com.sap.psr.vulas.JarAnalyzer - JarAnalyzer[jar/war=org.apache.servicemix.bundles.jaxb-xjc-2.2.4_1.jar, mavenId=(org.apache.servicemix.bundles:org.apache.servicemix.bundles.jaxb-xjc:2.2.4_1), instr=false, instrCtx=(com.acme:foo:pom:1.0-SNAPSHOT)]: NotFoundException while analyzing class [1.0.com.sun.xml.xsom.parser.JAXPParser]: 1.0.com.sun.xml.xsom.parser.JAXPParser Explanation: This can be due to the use of Java identifiers that do not confirm with the Java language specification . In this example, the actual package name of \"1.0.com.sun.xml.xsom.parser.JAXPParser\", as seen in the JAR file, is \"1.0\". Eclipse Steady, however, uses dots for separating package identifiers. Note: As of Java 9, multi-release archives can contain class files in subdirectories. They are not yet supported by Eclipse Steady. Solution: Not yet known. For the time being, clarify who produced the respective JAR file. app : The goal execution takes very long \u00b6 Problem: The execution of the APP goal takes very long. Explanation: Whenever a JAR, identified by its SHA1, is unknown to the backend, all its method signatures are gathered and uploaded. As a result, the first execution(s) of steady:app can take some time, as any yet unknown JAR need to be covered. Future executions will be significantly faster. app : The goal execution breaks with a 5xx response code received from the backend \u00b6 Problem: The goal execution breaks with a 5xx response code received from the backend. Explanation: This can happen if multiple processes (on the same computer or remotely) try to upload the same method signature to the backend. In such cases, one can simply restart at a later time to avoid the clash. app : The goal execution breaks with a java.nio.file.InvalidPathException \u00b6 Problem: The goal execution breaks with a java.nio.file.InvalidPathException: Malformed input or input contains unmappable characters as viewable here below. [ERROR] Failed to execute goal org.eclipse.steady:plugin-maven:3.2.2:app (default-cli) on project xxxxx: java.nio.file.InvalidPathException: Malformed input or input contains unmappable characters: shapeless/$tilde$qmark$greater$?.class Explanation : the exception is often due to an encoding problem. Solution : Try one of the following options. 1/ Add the property <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding> to your pom.xml file. Current property <encoding> only works if added to the configuration section of individual plugins. OR 2/ Force the usage of the UTF-8 encoding using the \"-Dsun.jnu.encoding=UTF-8 -Dfile.encoding=UTF-8\" properties in your command line. Reachability Analysis (goals a2c and t2c) \u00b6 a2c : java.lang.OutOfMemoryError \u00b6 Solutions: Increase the maximum and minimum JVM heap space with -Xmx and -Xms . Prior to Java8, also add -XX:MaxPermSize=2g -XX:+CMSClassUnloadingEnabled . a2c : Timeout during reachability analysis \u00b6 Problem: The execution of the reachability analysis causes a timeout, e.g., [main] WARN com.sap.psr.vulas.cg.ReachabilityAnalyzer - [vulas-reach-7] reached timeout and will be interrupted [main] WARN com.sap.psr.vulas.cg.ReachabilityAnalyzer - com.ibm.wala.util.intset.BitVectorIntSet.<init>(BitVectorIntSet.java:45) [main] WARN com.sap.psr.vulas.cg.ReachabilityAnalyzer - com.ibm.wala.util.intset.BitVectorIntSet.addAllOblivious(BitVectorIntSet.java:126) [main] WARN com.sap.psr.vulas.cg.ReachabilityAnalyzer - com.ibm.wala.util.intset.MutableSharedBitVectorIntSet.makeDenseCopy(MutableSharedBitVectorIntSet.java:984) [main] WARN com.sap.psr.vulas.cg.ReachabilityAnalyzer - com.ibm.wala.util.intset.MutableSharedBitVectorIntSet.addAll(MutableSharedBitVectorIntSet.java:752) [main] WARN com.sap.psr.vulas.cg.ReachabilityAnalyzer - com.ibm.wala.util.intset.MutableSharedBitVectorIntSet.addAllInIntersectionInternal(MutableSharedBitVectorIntSet.java:1067) [main] WARN com.sap.psr.vulas.cg.ReachabilityAnalyzer - com.ibm.wala.util.intset.MutableSharedBitVectorIntSet.addAllInIntersection(MutableSharedBitVectorIntSet.java:1032) [main] WARN com.sap.psr.vulas.cg.ReachabilityAnalyzer - com.ibm.wala.fixpoint.IntSetVariable.addAllInIntersection(IntSetVariable.java:175) [main] WARN com.sap.psr.vulas.cg.ReachabilityAnalyzer - com.ibm.wala.fixpoint.IntSetVariable.addAllInIntersection(IntSetVariable.java:158) [main] WARN com.sap.psr.vulas.cg.ReachabilityAnalyzer - com.ibm.wala.ipa.callgraph.propagation.FilteredPointerKey$SingleClassFilter.addFiltered(FilteredPointerKey.java:65) [main] WARN com.sap.psr.vulas.cg.ReachabilityAnalyzer - com.ibm.wala.ipa.callgraph.propagation.PropagationCallGraphBuilder$FilterOperator.evaluate(PropagationCallGraphBuilder.java:623) [main] WARN com.sap.psr.vulas.cg.ReachabilityAnalyzer - com.ibm.wala.ipa.callgraph.propagation.PropagationCallGraphBuilder$FilterOperator.evaluate(PropagationCallGraphBuilder.java:1) [main] WARN com.sap.psr.vulas.cg.ReachabilityAnalyzer - com.ibm.wala.fixpoint.UnaryStatement.evaluate(UnaryStatement.java:36) [main] WARN com.sap.psr.vulas.cg.ReachabilityAnalyzer - com.ibm.wala.fixedpoint.impl.AbstractFixedPointSolver.solve(AbstractFixedPointSolver.java:150) [main] WARN com.sap.psr.vulas.cg.ReachabilityAnalyzer - com.ibm.wala.ipa.callgraph.propagation.StandardSolver.solve(StandardSolver.java:40) [main] WARN com.sap.psr.vulas.cg.ReachabilityAnalyzer - com.ibm.wala.ipa.callgraph.propagation.PropagationCallGraphBuilder.makeCallGraph(PropagationCallGraphBuilder.java:269) [main] WARN com.sap.psr.vulas.cg.ReachabilityAnalyzer - com.sap.psr.vulas.cg.wala.WalaCallgraphConstructor.buildCallgraph(WalaCallgraphConstructor.java:308) [main] WARN com.sap.psr.vulas.cg.ReachabilityAnalyzer - com.sap.psr.vulas.cg.ReachabilityAnalyzer.run(ReachabilityAnalyzer.java:265) [main] WARN com.sap.psr.vulas.cg.ReachabilityAnalyzer - java.lang.Thread.run(Thread.java:745) [main] ERROR com.sap.psr.vulas.cg.ReachabilityAnalyzer - [vulas-reach-7] terminated w/o success after [ 15,0 min] Solution(s): Increase the timeout by changing the configuration setting vulas.reach.timeout , e.g., mvn -Dvulas.reach.timeout=600 -Dsteady compile steady:a2c Decrease the precision of the call graph construction, e.g., by changing the system property vulas.reach.wala.callgraph.reflection . For instance, run the reachability analysis as follows: mvn -Dsteady steady:a2c -Dcallgraph.reflection=NONE . See manual/analysis#a2c for more configuration options. a2c : java.io.FileNotFoundException? \u00b6 Problem: During a2c , a given JAR cannot be found by Wala, which produces an error message as following: Exception in thread \"vulas-reach-1\" com.ibm.wala.util.debug.UnimplementedError: java.io.FileNotFoundException: .\\InfoView\\dep\\BOE\\WEB-INF\\eclipse\\plugins\\axis2\\lib\\jaxb-api.jar (The system cannot find the file specified) Solution(s): Set the configuration parameter vulas.reach.preprocessDependencies to true Explanation: The problem occurs if the MANIFEST file of a JAR refers to other dependencies using the Class-Path entry. Wala, for instance, will try to resolve those dependencies. The pre-processing will remove the corresponding manifest file entries. a2c : Invalid byte code in method? \u00b6 Problem: During a2c or t2c , the call graph construction by Wala fails with an error message as follows: error: invalid byte code in method org.springframework.asm.ClassReader.readConst(I[C)Ljava/lang/Object; Exception in thread \"vulas-reach-1\" com.ibm.wala.util.debug.UnimplementedError at com.ibm.wala.util.debug.Assertions.UNREACHABLE(Assertions.java:46) at com.ibm.wala.classLoader.ShrikeCTMethod.makeDecoder(ShrikeCTMethod.java:107) Solution: Append the respective package to the configuration setting vulas.reach.wala.callgraph.exclusions , which lists all the Java packages to be ignored by Wala. Note that dots (.) separating package names are replaced by slash (/). Example: In case of the above error message, one has to add the string org/springframework/asm/.* in order to ignore all classes of package asm . The new value of the configuration setting looks as follows: vulas.reach.wala.callgraph.exclusions = java/awt/.*;javax/swing/.*;sun/awt/.*;sun/swing/.*;org/netbeans/.*;com/sun/.*;org/openide/.*;com/ibm/crypto/.*;com/ibm/security/.*;org/apache/xerces/.*;org/springframework/asm/.* Instrumentation and trace collection (goals test and instr) \u00b6 TEST : java.lang.NoSuchMethodError? \u00b6 Problem: The execution of the test phase throws a NoSuchMethodError exception. This can happen if an application makes use (directly or transitively) of an older release of a library that is also required by Eclipse Steady. In the below example, an application used commons-collections v3.0.0, while Eclipse Steady needs commons-collections v3.2.2 (whose classes are actually included in the vulas-with-dependencies.jar). ------------------------------------------------------- T E S T S ------------------------------------------------------- java.lang.reflect.InvocationTargetException at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:497) at sun.instrument.InstrumentationImpl.loadClassAndStartAgent(InstrumentationImpl.java:386) at sun.instrument.InstrumentationImpl.loadClassAndCallPremain(InstrumentationImpl.java:401) Caused by: java.lang.NoSuchMethodError: org.apache.commons.collections.CollectionUtils.isEmpty(Ljava/util/Collection;)Z at org.apache.commons.configuration.XMLConfiguration.constructHierarchy(XMLConfiguration.java:640) at org.apache.commons.configuration.XMLConfiguration.initProperties(XMLConfiguration.java:596) at org.apache.commons.configuration.XMLConfiguration.load(XMLConfiguration.java:1009) at org.apache.commons.configuration.XMLConfiguration.load(XMLConfiguration.java:972) at org.apache.commons.configuration.XMLConfiguration$XMLFileConfigurationDelegate.load(XMLConfiguration.java:1647) at org.apache.commons.configuration.AbstractFileConfiguration.load(AbstractFileConfiguration.java:324) at org.apache.commons.configuration.AbstractFileConfiguration.load(AbstractFileConfiguration.java:261) at org.apache.commons.configuration.AbstractFileConfiguration.load(AbstractFileConfiguration.java:238) at org.apache.commons.configuration.AbstractHierarchicalFileConfiguration.load(AbstractHierarchicalFileConfiguration.java:184) at org.apache.commons.configuration.DefaultConfigurationBuilder.getConfiguration(DefaultConfigurationBuilder.java:608) at org.apache.commons.configuration.DefaultConfigurationBuilder.getConfiguration(DefaultConfigurationBuilder.java:587) at com.sap.psr.vulas.monitor.DynamicTransformer.<init>(DynamicTransformer.java:81) at com.sap.psr.vulas.monitor.DynamicTransformer.getInstance(DynamicTransformer.java:304) at com.sap.psr.vulas.monitor.DynamicTransformer.premain(DynamicTransformer.java:320) ... 6 more FATAL ERROR in native method: processing of -javaagent failed Exception in thread \"main\" Solution: Change the dependency of your application to a more recent release. In the above example, the following XML snippet was added to the application's POM (which transitively depended on it): <dependency> <groupId> commons-collections </groupId> <artifactId> commons-collections </artifactId> <version> 3.2.2 </version> </dependency> TEST : Not all Eclipse Steady analysis results are uploaded to the backend \u00b6 Problem: At the end of the JUnit test case execution ( mvn -Dsteady test ), not all the Eclipse Steady analysis results are uploaded to the the Eclipse Steady backend. The reason is that the Maven Surefire Plugin kills the JVM before Eclipse Steady' shutdown hook uploaded all the data. Solution: Disable the upload by changing the Surefire configuration in the POM file as follows. The analysis results will then be written in the folder target/vulas/upload . Afterwards, run the Eclipse Steady plugin goal \"upload\" in order to upload the JSON analysis results to the backend ( mvn -Dsteady steady:upload ). <argLine> -Dvulas.upload=false TEST : How to run -Dsteady test in projects using Mockito? \u00b6 Problem : when running mvn -Dsteady test , tests fail with an error such as org.mockito.exceptions.misusing.MissingMethodInvocationException Solution : Run your tests as usual: mvn test Then run them again with Eclipse Steady enabled to perform reachability analysis: mvn -Dmaven.test.failure.ignore = true -Dsteady test steady:upload Alternative solutions (when running mvn -Dsteady test ) : disable selectively the failing tests ignore selected jars TEST : Byte code instrumentation fails \u00b6 Problem No traces are collected during the execution of JUnit tests, no matter which instrumentor is used. Moreover, no corresponding error messages or exceptions are printed to the console. A possible indicator of that problem is the appearance of the log message \"Completed instantiation of trace collector\" after the log message \"Tests run: XXX, Failures: XXX, Errors: XXX, Skipped: XXX, Time elapsed: XXX sec\", which signals the termination of the actual JUnit tests. Example: [main] INFO com.sap.psr.vulas.monitor.InstrumentationControl - JAR [C:\\Users\\XXXXXX\\.m2\\repository\\org\\apache\\commons\\commons-lang3\\3.2\\commons-lang3-3.2.jar] is blacklisted: [false] Tests run: 2, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.141 sec - in code.MainTest [vulas-shutdown-trace-upload] INFO com.sap.psr.vulas.backend.requests.BasicHttpRequest - HTTP GET [uri=http://localhost:8033/backend/apps/XXXXXX/XXXXXX/XXXXXX/bugs?historical=false, proxy=false] [vulas-shutdown-trace-upload] INFO com.sap.psr.vulas.backend.requests.BasicHttpRequest - HTTP GET completed with response code [200] in [0,0573 min] [vulas-shutdown-trace-upload] INFO com.sap.psr.vulas.backend.BackendConnector - [53] constructs for [7] bugs received from backend [vulas-shutdown-trace-upload] INFO com.sap.psr.vulas.monitor.trace.TraceCollector - Completed instantiation of trace collector [vulas-shutdown-trace-upload] INFO com.sap.psr.vulas.monitor.trace.TraceCollector - No paths collected [vulas-shutdown-trace-upload] INFO com.sap.psr.vulas.monitor.trace.TraceCollector - No traces collected [vulas-shutdown-trace-upload] INFO com.sap.psr.vulas.GoalExecution - Eclipse Steady goal execution finished [id=TEST-1487175325075-7552264, goal=TEST, app=(XXXXXX:XXXXXX:XXXXXX)] in [0,0877 min] Solution Similar to the above problem, it can happen that an application depends on a previous release of Javassist. As such, methods required by Eclipse Steady are not present at the time Eclipse Steady tries to change the byte code of loaded classes. As for the previous problem, you can add an explicit dependency to the application under test in order to let Maven resolve to a recent release of Javassist. TEST : The forked VM terminated \u00b6 Problem: Tests terminate with a log message as follows: The forked VM terminated without properly saying goodbye. VM crash or System.exit called? Solutions: Increase JVM heap space by adding -Xmx4096M -Xms2048M (or more if possible) to the <argLine> argument of the Maven Surefire plugin Select an instrumentor that consumes less memory by adding, for instance, -Dvulas.core.instr.instrumentorsChoosen=com.sap.psr.vulas.monitor.trace.SingleTraceInstrumentor . TEST : Incomplete app context \u00b6 Problem Tests terminate with the error message App context incomplete: [group=, artifact=, version=] and there exists a white space in any of the parent directories of the Maven project (e.g., C:\\My Documents\\projects\\foo ). Solutions Move the Maven project to a location without whitespaces in the names of any of the parent directories. Open the pom.xml and replace the Maven variable ${project.build.directory} in the <argLine> configuration setting of the maven-surefire-plugi n by the relative path of the respective directory, typically target . Open the POM file and remove the -Dvulas.core.uploadDir and -Dvulas.shared.tmpDir system properties in the <argLine> configuration setting of the maven-surefire-plugin . Create two new system property variables in the configuration section of the maven-surefire-plugin as follows (see here for more information). <systemPropertyVariables> <vulas.core.uploadDir> ${project.build.directory}/vulas/upload </vulas.core.uploadDir> <vulas.shared.tmpDir> ${project.build.directory}/vulas/tmp </vulas.shared.tmpDir> </systemPropertyVariables> TEST : \"Error injecting: private org.eclipse.aether.spi.log.Logger org.apache.maven.repository.internal.DefaultVersionResolver.logger\" \u00b6 Problem When running the Eclipse Steady test goal, you face an error similar to Error injecting: private org.eclipse.aether.spi.log.Logger org.apache.maven.repository.internal.DefaultVersionResolver.logger Solution This error seems to appear with certain versions of Maven. It should disappear with maven 3.5.2 or higher. Please insure which version of maven you are using. If you locally run maven on your machine, please upgrade your local maven version to maven 3.5.2 or higher and run your scan again. If you perform your scans in a CI/CD environment like Jenkins, please check which version of Maven is used there. Then validate that the issue is linked to the current maven version (see previous point). Once you validated that the current Maven version is responsible for the issue, proceed with the update/upgrade to Maven 3.5.2 or higher in your CI/CD environment. As an example in Jenkins environments you can use one of the following alternatives: Make an upgrade request to your Jenkins administrator. Install Maven \"globaly\": in this case you can continue using your former command ex: mvn clean compile steady:clean steady:app install steady:upload -Pvulas -Dskip.integration.tests as it is and Jenkins will use the new version. Install maven as new \"Global Tool\": you can do this in \"Manage Jenkins\" -> \"Global Tool Configuration\". Here you find the entry \"Maven installations\". Add there the new Maven installation \"M360\" (if you like to install maven 3.6.0) with the installer \"Install from Apache\" Version 3.6.0. As a consequence, you will need to change the command in your job/task so that the new Maven version is used instead of the global one (which is still the version including the bug) and your command should like like /var/jenkins_home/tools/hudson.tasks.Maven_MavenInstallation/M360/bin/mvn clean compile steady:clean steady:app install steady:upload -Pvulas -Dskip.integration.tests JUnit tests using Powermock fail when using Eclipse Steady \u00b6 Problem JUnit tests making use of Powermock fail when activating the Eclipse Steady profile. Explanation In order to collect execution traces during test execution, the Eclipse Steady agent has to be registered at the JVM. This is done in the configuration section of the surefire plugin inside the Eclipse Steady profile. The parallel use of Powermock and the Eclipse Steady agent, which modifies all the bytecode of every class loaded by the JVM, fails in certain cases. Solution(s) This problem can be solved in several ways: Ignore all test failures by adding -Dmaven.test.failure.ignore=true (also see other options of the maven-surefire-plugin ) In case of multi-module projects, continue the build of later modules using the options --fail-never or --fail-at-end (see here for more information) Exclude problematic classes from being instrumented by adding their prefixes via -Dvulas.core.instr.blacklist.classes.custom=foo.bar,bar.baz.Class,... Exclude single problematic tests by modifying the <excludes> section of the surefire configuration in the Eclipse Steady profile: <excludes> <exclude> **/doesnotexist.java </exclude> </excludes> Python \u00b6 app goal is slow \u00b6 Dependencies are analyzed by setting up a virtual environment for the respective application. The setup of such a virtualenv can take some time (no matter whether it is done in the context of Eclipse Steady or not). Moreover, whenever a Python library is found that is not yet known to the backend, its bill of material needs to be uploaded. The delay caused by this initial upload will not occur for subsequent scans. virtualenv problems \u00b6 Run virtualenv from the command line to see whether it is properly installed and working. Other topics \u00b6 report: The HTML result report is not properly rendered inside Jenkins \u00b6 Symptom : The HTML report is not properly rendered inside Jenkins (e.g., no images, no color-coding, no JavaScript, see the example screenshot below). Solution : Either (a) download a ZIP of the Eclipse Steady report (the link can be found in the upper-right corner), or (b) adjust the content security policy (CSP) of Jenkins as described here . In the latter case, you should execute the following command in the Jenkins script console (on a single line ): System . setProperty ( \"hudson.model.DirectoryBrowserSupport.CSP\" , \"sandbox allow-scripts; default-src 'none'; img-src 'self' data:; style-src 'self' 'unsafe-inline'; script-src 'unsafe-inline'\" ) No log messages of the Eclipse Steady Maven plugin appear on the console. Why? \u00b6 Symptom Eclipse Steady log messages are not printed to the console (e.g., during the execution of the Maven lifecycle phase \"test\"). Instead, the following error message is printed. ERROR StatusLogger No log4j2 configuration file found. Using default configuration: logging only errors to the console. Explanation The Eclipse Steady Maven plugin makes use of log4j version 1, a corresponding configuration file is included in its JAR file. If, however, the project under analysis makes use of log4j version 2, but does not have a log4j2.xml file in folder src/main/resources , no log message of Eclipse Steady but the above error message is printed. Still, the traces are actually collected and uploaded to the central engine. Solution Create a file src/main/resources/log4j2.xml with the following sample content (copied from here ) and adapt as needed. <?xml version=\"1.0\" encoding=\"UTF-8\"?> <Configuration> <Appenders> <Console name= \"STDOUT\" target= \"SYSTEM_OUT\" > <PatternLayout pattern= \"%d %-5p [%t] %C{2} (%F:%L) - %m%n\" /> </Console> </Appenders> <Loggers> <Logger name= \"org.apache.log4j.xml\" level= \"info\" /> <Root level= \"info\" > <AppenderRef ref= \"STDOUT\" /> </Root> </Loggers> </Configuration> OutOfMemoryError: GC overhead limit exceeded? \u00b6 Use the command line options -Xms and -Xmx to adjust the heap memory available to the JVM. Chose a value for -Xmx that is close to your machine's physical memory. In case of Maven, use the statement export MAVEN_OPTS=\"-Xms4g -Xmx8g\" . For versions before Java 8, you should also add the options -XX:MaxPermSize=2024M -XX:+CMSClassUnloadingEnabled . Notes: See here for problems related to the heap space allocations on 32bit Java versions See here for background information on Java memory management I get an error saying VerifyError: Inconsistent stackmap frames at branch target . What should I do? \u00b6 If the execution of the Maven Surefire Plugin during the Maven lifecycle phase test fails with a java.lang.VerifyError similar to the following: [ERROR] Failed to execute goal org.apache.maven.plugins:maven-surefire-plugin:2.16:test (default-test) on project foo-bar: Execution default-test of goal org.apache.maven.plugins:maven-surefire-plugin:2.16:test failed: There was an error in the forked process [ERROR] java.lang.VerifyError: Inconsistent stackmap frames at branch target 54 [ERROR] Exception Details: [ERROR] Location: [ERROR] com/acme/FooTest.<init>()V @54: aconst_null [ERROR] Reason: [ERROR] Type uninitializedThis (current frame, locals[0]) is not assignable to 'com/acme/FooTest' (stack map, locals[0]) [ERROR] Current Frame: [ERROR] bci: @16 [ERROR] flags: { flagThisUninit } [ERROR] locals: { uninitializedThis, null, 'java/lang/ClassLoader' } [ERROR] stack: { 'java/lang/ClassLoader', null } [ERROR] Stackmap Frame: [ERROR] bci: @54 [ERROR] flags: { } [ERROR] locals: { 'com/acme/FooTest', 'java/net/URL', 'java/lang/ClassLoader' } [ERROR] stack: { } [ERROR] Bytecode: [ERROR] 0000000: b200 bd9a 0047 014c 1235 b600 914d 2c01 [ERROR] 0000010: a500 262c bb00 9359 b700 9412 35b6 0098 [ERROR] 0000020: 102e 102f b600 9cb6 00a0 12a2 b600 a0b6 [ERROR] 0000030: 00a5 b600 ab4c 014e 12bf 2c2b 0101 0101 [ERROR] 0000040: 2d03 0304 b800 c2b3 00bd 2ab7 0001 b800 [ERROR] 0000050: 022a b600 0312 04b6 0005 4c2a 2bb8 0006 [ERROR] 0000060: b500 07b1 [ERROR] Stackmap Table: [ERROR] full_frame(@54,{Object[#53],Object[#181],Object[#167]},{}) [ERROR] full_frame(@74,{UninitializedThis},{}) [ERROR] [ERROR] at java.lang.Class.getDeclaredMethods0(Native Method) then you should include the Java option noverify in the Surefire configuration as follows: <argLine> -javaagent:target/vulas/lib/vulas-core-${vulas.version}-jar-with-dependencies.jar -DperiodicUpload.enabled=false -DappContext.fixed.groupId=${project.groupId} -DappContext.fixed.artifactId=${project.artifactId} -DappContext.fixed.version=${project.version} -noverify <!-- Uncomment to debug the test execution or the Eclipse Steady plugin --> <!-- -Xrunjdwp:transport=dt_socket,server=y,suspend=y,address=8000 --> </argLine> See here for more information on the noverify option: Stackoverflow Informit","title":"FAQ"},{"location":"user/support/faq/#general-questions","text":"","title":"General questions"},{"location":"user/support/faq/#why-cant-i-compile-my-maven-project-anymore-after-i-activate-the-eclipse-steady-profile","text":"You may want to check whether there are other <profile> sections that declare dependencies. If so, one of those is probably activated by default. In this case, when using the Eclipse Steady profile, those other profiles will not be active, hence, there are dependencies missing, which can lead to compile exceptions. To fix, you should activate multiple profiles at once using the -P option, see here for more information.","title":"Why can't I compile my Maven project anymore after I activate the Eclipse Steady profile?"},{"location":"user/support/faq/#why-does-eclipse-steady-backend-refuse-http-connections-established-by-eclipse-steady-maven-plugin","text":"The Eclipse Steady plugins gathers very detailed information about all Java archives required by an application. For example, it collects the method signatures of all methods contained in every JAR. For every archive, identified by its SHA1, this information must be uploaded to and stored by the Eclipse Steady backend in case it is not yet known. This requirement will cause a lot of uploads when an application is first analyzed, because a lot of dependencies may not be known. Problem: As a result of the above, it can happen that several HTTP POST connection requests are refused by the Eclipse Steady backend during the Eclipse Steady Maven plugin execution, which will result in error messages as follows. Copy&paste from console Solution Eclipse Steady plugin users can simply re-run the Eclipse Steady goal \"app\" multiple times up until the information for all archives has been uploaded. With each run, more and more archives will be successfully uploaded, up until a point where every archive is known. According to our experience, this is the case after a few runs only ( <5 ).","title":"Why does Eclipse Steady backend refuse HTTP connections established by Eclipse Steady Maven plugin?"},{"location":"user/support/faq/#why-do-all-http-connections-fail-from-the-eclipse-steady-maven-plugin","text":"Problem Not a single HTTP connection can be established, which becomes obvious if even the first connection request hangs for several minutes and eventually fails as follows: [INFO] ------------------------------------------------------------------------ [INFO] Building com.at.example.spring-01 0.0.1-SNAPSHOT [INFO] ------------------------------------------------------------------------ [INFO] [INFO] --- maven-clean-plugin:2.5:clean (default-clean) @ com.at.example.spring-01 --- [INFO] Deleting C:\\My Documents\\com.at.example.spring-01\\target [INFO] [INFO] --- maven-dependency-plugin:2.10:copy (copy-vulas) @ com.at.example.spring-01 --- [INFO] Configured Artifact: org.eclipse.steady:vulas-core:jar-with-dependencies:1.1.0-SNAPSHOT:jar [INFO] Configured Artifact: org.eclipse.steady:vulas-core:jar-with-dependencies:1.1.0-SNAPSHOT:jar [INFO] Copying vulas-core-1.1.0-SNAPSHOT-jar-with-dependencies.jar to C:\\My Documents\\com.at.example.spring-01\\target\\vulas\\lib\\vulas-core-1.1.0-SNAPSHOT-jar-with-dependencies.jar [INFO] Copying vulas-core-1.1.0-SNAPSHOT-jar-with-dependencies.jar to C:\\My Documents\\com.at.example.spring-01\\target\\vulas\\include\\vulas-core-1.1.0-SNAPSHOT-jar-with-dependencies.jar [INFO] [INFO] --- vulas-maven-plugin:1.1.0-SNAPSHOT:clean (vulas-clean) @ com.at.example.spring-01 --- [main] INFO com.sap.psr.vulas.GoalExecution - Eclipse Steady goal execution started [id=CLEAN-1448374577441-14554386, goal=CLEAN, app=(com.at.example:com.at.example.spring-01:jar:0.0.1-SNAPSHOT)] [main] INFO com.sap.psr.vulas.backend.Collector - HTTP request started [url=, user=] [vulas-memo] INFO com.sap.psr.vulas.GoalExecution - Memory consumption (used/avg): [57.75 MB/57.75 MB], JVM (free/total/max): [183.75 MB/241.50 MB/3559.50 MB] [main] ERROR com.sap.psr.vulas.backend.Collector - HTTP request error while calling [], HTTP response written to [C:\\Users\\iXXXXXX\\AppData\\Local\\Temp\\vulas-tmp-8966348801119324800.html] Solution Run the Eclipse Steady Maven plugin with a different proxy than the default proxy specified in the configuration ( none ). You need to change 2 settings: On the command line, run Maven as follows, whereby <proxy> can be custom_proxy or simply proxy mvn -Dhttp.proxyHost = <proxy> -Dsteady steady:app In the Maven Surefire plugin, include the -Dhttp.proxyHost system property for the JVM spawned for JUnit tests: <plugin> <groupId> org.apache.maven.plugins </groupId> <artifactId> maven-surefire-plugin </artifactId> <version> 2.14 </version> <configuration> <argLine> ... -Dhttp.proxyHost=custom_proxy ... </argLine> </configuration> </plugin>","title":"Why do all HTTP connections fail from the Eclipse Steady Maven plugin?"},{"location":"user/support/faq/#why-does-my-workspace-stay-empty","text":"When executing a vulas goal, your workspace is not filled with the results of the scan. Instead of this your results are usually uploaded to the PUBLIC workspace of the Eclipse Steady Frontend. You first need to insure that you are using at least version 3.0 of Eclipse Steady. The workspace feature was introduced with Eclipse Steady 3. By default, if you are running Eclipse Steady 2.x (and you should not!) all the data are stored in the \"PUBLIC\" workspace in the Eclipse Steady Frontend. Please notice that the Eclipse Steady plugin name was changed with Eclipse Steady 3: it was changed from vulas-maven-plugin to plugin-maven (click here for more details). It is quite usual that developers working with Jenkins/Piper are pointing to an old version of Eclipse Steady (2.x) because their Jenkins/Piper platform itself points to the old Eclipse Steady plugin name. A simple update there usually solves the issue. You need to insure that you have correctly indicated to Eclipse Steady where to upload the results of your scans (e.g. in your workspace). Please click here and here for details about workspaces and how to use them.","title":"Why does my workspace stay empty?"},{"location":"user/support/faq/#what-is-the-cause-of-the-following-error-vulas-maven-plugin3xx-or-one-of-its-dependencies-could-not-be-resolved","text":"You are running the execution of a maven goal and are facing an error similar to the following one: [ERROR] Plugin org.eclipse.steady:vulas-maven-plugin:3.0.8 or one of its dependencies could not be resolved: Could not find artifact org.eclipse.steady:vulas-maven-plugin:jar:3.0.8 in mirror1 (url) -> [Help 1] You most probably updated your settings to use Maven 3.x instead of Maven 2.x. The Eclipse Steady plugin was renamed with Eclipse Steady 3.x: it was changed from vulas-maven-plugin to plugin-maven . You may need to update your settings accordingly (click here for more details on how to update your settings).","title":"What is the cause of the following ERROR: vulas-maven-plugin:3.x.x or one of its dependencies could not be resolved?"},{"location":"user/support/faq/#why-do-i-get-the-following-message-warn-app-does-not-exist-in-backend-goal-upload-skipped","text":"Symptom : The console contains a log message as follows: WARN com.sap.psr.vulas.backend.BackendConnector - App [group=com.acme, artifact=parent, version=1-SNAPSHOT, packaging=pom] does not exist in backend, goal upload skipped Explanation : Information related to the execution of a goal, e.g., execution time or memory consumption, cannot be uploaded as the respective application does not exist in the backend. This is not necessarily a problem, hence, the message is issued as warning. Examples where an application does not exist in the backend are as follows: If an application does neither have any dependencies nor source code, e.g., in folder src/main/java , it will not be uploaded to the backend (depending on configuration parameter vulas.core.app.uploadEmpty , which defaults to false ). In this case, the execution of goal execution information cannot be uploaded. Typical examples of empty applications are Maven aggregator projects ( <packaging>pom</packaging> ). If an application version is analyzed for the first time, the initial execution of the clean goal will also result in this warning message.","title":"Why do I get the following message: WARN: App does not exist in backend, goal upload skipped?"},{"location":"user/support/faq/#why-does-eclipse-steady-show-vulnerabilities-that-are-seemingly-related-to-other-components","text":"Symptom : In the Web frontend or in the report, Eclipse Steady displays findings which seem to be related to others components. Example : In the following screenshot, several CVEs related to jackson-databind are shown for spring-cloud-cloudfoundry-connector . Explanation : Eclipse Steady detects the presence of vulnerable code, no matter the file name or GAV of a dependency. Sometimes, an archive re-bundles code of other open source projects. Sometimes, re-bundled code is even re-packaged, thus, the Java package namespace is altered. Both of those cases are still detected by Eclipse Steady. In the previous example, the file spring-cloud-cloudfoundry-connector-2.0.5.RELEASE.jar contains (re-bundles) vulnerable code of jackson-databind .","title":"Why does Eclipse Steady show vulnerabilities that are seemingly related to other components"},{"location":"user/support/faq/#understanding-the-results-produced-by-eclipse-steady","text":"","title":"Understanding the results produced by Eclipse Steady"},{"location":"user/support/faq/#eclipse-steady-reported-vulnerabilities-for-which-i-found-no-data-in-nvd-what-should-i-do-about-them","text":"For vulnerabilities that do not come from the NVD we do provide reference links. They are listed in the vulnerability details page accessible clicking on the different rows of the vulnerability main table (see example below).","title":"Eclipse Steady reported vulnerabilities for which I found no data in NVD. What should I do about them?"},{"location":"user/support/faq/#why-is-eclipse-steady-is-not-detecting-all-vulnerabilities-of-my-project","text":"If the vulnerability is included in our knowledge base but it is not detected for your application, you can select the checkbox \u201cInclude historical vulnerabilities\u201d in the Eclipse Steady frontend and hit \u201cReload\u201d button: you will see all CVEs that applied to previous versions of your dependencies. The indicates that a given CVE did apply to earlier versions, but you are currently using a non-vulnerable one. Despite our best efforts to keep the Eclipse Steady vulnerability knowledge base continuously updated, it is possible that a particular vulnerability is not yet covered. Query /backend/bugs to check if a vulnerability is covered or not.","title":"Why is Eclipse Steady is not detecting all vulnerabilities of my project?"},{"location":"user/support/faq/#method-level-bill-of-material-goal-app","text":"","title":"Method-level bill of material (goal app)"},{"location":"user/support/faq/#app-notfoundexception-when-analyzing-jar-files","text":"Problem: When analyzing JAR files, error messages similar to the following are printed: ERROR com.sap.psr.vulas.JarAnalyzer - JarAnalyzer[jar/war=org.apache.servicemix.bundles.jaxb-xjc-2.2.4_1.jar, mavenId=(org.apache.servicemix.bundles:org.apache.servicemix.bundles.jaxb-xjc:2.2.4_1), instr=false, instrCtx=(com.acme:foo:pom:1.0-SNAPSHOT)]: NotFoundException while analyzing class [1.0.com.sun.xml.xsom.parser.JAXPParser]: 1.0.com.sun.xml.xsom.parser.JAXPParser Explanation: This can be due to the use of Java identifiers that do not confirm with the Java language specification . In this example, the actual package name of \"1.0.com.sun.xml.xsom.parser.JAXPParser\", as seen in the JAR file, is \"1.0\". Eclipse Steady, however, uses dots for separating package identifiers. Note: As of Java 9, multi-release archives can contain class files in subdirectories. They are not yet supported by Eclipse Steady. Solution: Not yet known. For the time being, clarify who produced the respective JAR file.","title":"app : NotFoundException when analyzing JAR files?"},{"location":"user/support/faq/#app-the-goal-execution-takes-very-long","text":"Problem: The execution of the APP goal takes very long. Explanation: Whenever a JAR, identified by its SHA1, is unknown to the backend, all its method signatures are gathered and uploaded. As a result, the first execution(s) of steady:app can take some time, as any yet unknown JAR need to be covered. Future executions will be significantly faster.","title":"app : The goal execution takes very long"},{"location":"user/support/faq/#app-the-goal-execution-breaks-with-a-5xx-response-code-received-from-the-backend","text":"Problem: The goal execution breaks with a 5xx response code received from the backend. Explanation: This can happen if multiple processes (on the same computer or remotely) try to upload the same method signature to the backend. In such cases, one can simply restart at a later time to avoid the clash.","title":"app : The goal execution breaks with a 5xx response code received from the backend"},{"location":"user/support/faq/#app-the-goal-execution-breaks-with-a-javaniofileinvalidpathexception","text":"Problem: The goal execution breaks with a java.nio.file.InvalidPathException: Malformed input or input contains unmappable characters as viewable here below. [ERROR] Failed to execute goal org.eclipse.steady:plugin-maven:3.2.2:app (default-cli) on project xxxxx: java.nio.file.InvalidPathException: Malformed input or input contains unmappable characters: shapeless/$tilde$qmark$greater$?.class Explanation : the exception is often due to an encoding problem. Solution : Try one of the following options. 1/ Add the property <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding> to your pom.xml file. Current property <encoding> only works if added to the configuration section of individual plugins. OR 2/ Force the usage of the UTF-8 encoding using the \"-Dsun.jnu.encoding=UTF-8 -Dfile.encoding=UTF-8\" properties in your command line.","title":"app : The goal execution breaks with a java.nio.file.InvalidPathException"},{"location":"user/support/faq/#reachability-analysis-goals-a2c-and-t2c","text":"","title":"Reachability Analysis (goals a2c and t2c)"},{"location":"user/support/faq/#a2c-javalangoutofmemoryerror","text":"Solutions: Increase the maximum and minimum JVM heap space with -Xmx and -Xms . Prior to Java8, also add -XX:MaxPermSize=2g -XX:+CMSClassUnloadingEnabled .","title":"a2c : java.lang.OutOfMemoryError"},{"location":"user/support/faq/#a2c-timeout-during-reachability-analysis","text":"Problem: The execution of the reachability analysis causes a timeout, e.g., [main] WARN com.sap.psr.vulas.cg.ReachabilityAnalyzer - [vulas-reach-7] reached timeout and will be interrupted [main] WARN com.sap.psr.vulas.cg.ReachabilityAnalyzer - com.ibm.wala.util.intset.BitVectorIntSet.<init>(BitVectorIntSet.java:45) [main] WARN com.sap.psr.vulas.cg.ReachabilityAnalyzer - com.ibm.wala.util.intset.BitVectorIntSet.addAllOblivious(BitVectorIntSet.java:126) [main] WARN com.sap.psr.vulas.cg.ReachabilityAnalyzer - com.ibm.wala.util.intset.MutableSharedBitVectorIntSet.makeDenseCopy(MutableSharedBitVectorIntSet.java:984) [main] WARN com.sap.psr.vulas.cg.ReachabilityAnalyzer - com.ibm.wala.util.intset.MutableSharedBitVectorIntSet.addAll(MutableSharedBitVectorIntSet.java:752) [main] WARN com.sap.psr.vulas.cg.ReachabilityAnalyzer - com.ibm.wala.util.intset.MutableSharedBitVectorIntSet.addAllInIntersectionInternal(MutableSharedBitVectorIntSet.java:1067) [main] WARN com.sap.psr.vulas.cg.ReachabilityAnalyzer - com.ibm.wala.util.intset.MutableSharedBitVectorIntSet.addAllInIntersection(MutableSharedBitVectorIntSet.java:1032) [main] WARN com.sap.psr.vulas.cg.ReachabilityAnalyzer - com.ibm.wala.fixpoint.IntSetVariable.addAllInIntersection(IntSetVariable.java:175) [main] WARN com.sap.psr.vulas.cg.ReachabilityAnalyzer - com.ibm.wala.fixpoint.IntSetVariable.addAllInIntersection(IntSetVariable.java:158) [main] WARN com.sap.psr.vulas.cg.ReachabilityAnalyzer - com.ibm.wala.ipa.callgraph.propagation.FilteredPointerKey$SingleClassFilter.addFiltered(FilteredPointerKey.java:65) [main] WARN com.sap.psr.vulas.cg.ReachabilityAnalyzer - com.ibm.wala.ipa.callgraph.propagation.PropagationCallGraphBuilder$FilterOperator.evaluate(PropagationCallGraphBuilder.java:623) [main] WARN com.sap.psr.vulas.cg.ReachabilityAnalyzer - com.ibm.wala.ipa.callgraph.propagation.PropagationCallGraphBuilder$FilterOperator.evaluate(PropagationCallGraphBuilder.java:1) [main] WARN com.sap.psr.vulas.cg.ReachabilityAnalyzer - com.ibm.wala.fixpoint.UnaryStatement.evaluate(UnaryStatement.java:36) [main] WARN com.sap.psr.vulas.cg.ReachabilityAnalyzer - com.ibm.wala.fixedpoint.impl.AbstractFixedPointSolver.solve(AbstractFixedPointSolver.java:150) [main] WARN com.sap.psr.vulas.cg.ReachabilityAnalyzer - com.ibm.wala.ipa.callgraph.propagation.StandardSolver.solve(StandardSolver.java:40) [main] WARN com.sap.psr.vulas.cg.ReachabilityAnalyzer - com.ibm.wala.ipa.callgraph.propagation.PropagationCallGraphBuilder.makeCallGraph(PropagationCallGraphBuilder.java:269) [main] WARN com.sap.psr.vulas.cg.ReachabilityAnalyzer - com.sap.psr.vulas.cg.wala.WalaCallgraphConstructor.buildCallgraph(WalaCallgraphConstructor.java:308) [main] WARN com.sap.psr.vulas.cg.ReachabilityAnalyzer - com.sap.psr.vulas.cg.ReachabilityAnalyzer.run(ReachabilityAnalyzer.java:265) [main] WARN com.sap.psr.vulas.cg.ReachabilityAnalyzer - java.lang.Thread.run(Thread.java:745) [main] ERROR com.sap.psr.vulas.cg.ReachabilityAnalyzer - [vulas-reach-7] terminated w/o success after [ 15,0 min] Solution(s): Increase the timeout by changing the configuration setting vulas.reach.timeout , e.g., mvn -Dvulas.reach.timeout=600 -Dsteady compile steady:a2c Decrease the precision of the call graph construction, e.g., by changing the system property vulas.reach.wala.callgraph.reflection . For instance, run the reachability analysis as follows: mvn -Dsteady steady:a2c -Dcallgraph.reflection=NONE . See manual/analysis#a2c for more configuration options.","title":"a2c : Timeout during reachability analysis"},{"location":"user/support/faq/#a2c-javaiofilenotfoundexception","text":"Problem: During a2c , a given JAR cannot be found by Wala, which produces an error message as following: Exception in thread \"vulas-reach-1\" com.ibm.wala.util.debug.UnimplementedError: java.io.FileNotFoundException: .\\InfoView\\dep\\BOE\\WEB-INF\\eclipse\\plugins\\axis2\\lib\\jaxb-api.jar (The system cannot find the file specified) Solution(s): Set the configuration parameter vulas.reach.preprocessDependencies to true Explanation: The problem occurs if the MANIFEST file of a JAR refers to other dependencies using the Class-Path entry. Wala, for instance, will try to resolve those dependencies. The pre-processing will remove the corresponding manifest file entries.","title":"a2c : java.io.FileNotFoundException?"},{"location":"user/support/faq/#a2c-invalid-byte-code-in-method","text":"Problem: During a2c or t2c , the call graph construction by Wala fails with an error message as follows: error: invalid byte code in method org.springframework.asm.ClassReader.readConst(I[C)Ljava/lang/Object; Exception in thread \"vulas-reach-1\" com.ibm.wala.util.debug.UnimplementedError at com.ibm.wala.util.debug.Assertions.UNREACHABLE(Assertions.java:46) at com.ibm.wala.classLoader.ShrikeCTMethod.makeDecoder(ShrikeCTMethod.java:107) Solution: Append the respective package to the configuration setting vulas.reach.wala.callgraph.exclusions , which lists all the Java packages to be ignored by Wala. Note that dots (.) separating package names are replaced by slash (/). Example: In case of the above error message, one has to add the string org/springframework/asm/.* in order to ignore all classes of package asm . The new value of the configuration setting looks as follows: vulas.reach.wala.callgraph.exclusions = java/awt/.*;javax/swing/.*;sun/awt/.*;sun/swing/.*;org/netbeans/.*;com/sun/.*;org/openide/.*;com/ibm/crypto/.*;com/ibm/security/.*;org/apache/xerces/.*;org/springframework/asm/.*","title":"a2c : Invalid byte code in method?"},{"location":"user/support/faq/#instrumentation-and-trace-collection-goals-test-and-instr","text":"","title":"Instrumentation and trace collection (goals test and instr)"},{"location":"user/support/faq/#test-javalangnosuchmethoderror","text":"Problem: The execution of the test phase throws a NoSuchMethodError exception. This can happen if an application makes use (directly or transitively) of an older release of a library that is also required by Eclipse Steady. In the below example, an application used commons-collections v3.0.0, while Eclipse Steady needs commons-collections v3.2.2 (whose classes are actually included in the vulas-with-dependencies.jar). ------------------------------------------------------- T E S T S ------------------------------------------------------- java.lang.reflect.InvocationTargetException at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:497) at sun.instrument.InstrumentationImpl.loadClassAndStartAgent(InstrumentationImpl.java:386) at sun.instrument.InstrumentationImpl.loadClassAndCallPremain(InstrumentationImpl.java:401) Caused by: java.lang.NoSuchMethodError: org.apache.commons.collections.CollectionUtils.isEmpty(Ljava/util/Collection;)Z at org.apache.commons.configuration.XMLConfiguration.constructHierarchy(XMLConfiguration.java:640) at org.apache.commons.configuration.XMLConfiguration.initProperties(XMLConfiguration.java:596) at org.apache.commons.configuration.XMLConfiguration.load(XMLConfiguration.java:1009) at org.apache.commons.configuration.XMLConfiguration.load(XMLConfiguration.java:972) at org.apache.commons.configuration.XMLConfiguration$XMLFileConfigurationDelegate.load(XMLConfiguration.java:1647) at org.apache.commons.configuration.AbstractFileConfiguration.load(AbstractFileConfiguration.java:324) at org.apache.commons.configuration.AbstractFileConfiguration.load(AbstractFileConfiguration.java:261) at org.apache.commons.configuration.AbstractFileConfiguration.load(AbstractFileConfiguration.java:238) at org.apache.commons.configuration.AbstractHierarchicalFileConfiguration.load(AbstractHierarchicalFileConfiguration.java:184) at org.apache.commons.configuration.DefaultConfigurationBuilder.getConfiguration(DefaultConfigurationBuilder.java:608) at org.apache.commons.configuration.DefaultConfigurationBuilder.getConfiguration(DefaultConfigurationBuilder.java:587) at com.sap.psr.vulas.monitor.DynamicTransformer.<init>(DynamicTransformer.java:81) at com.sap.psr.vulas.monitor.DynamicTransformer.getInstance(DynamicTransformer.java:304) at com.sap.psr.vulas.monitor.DynamicTransformer.premain(DynamicTransformer.java:320) ... 6 more FATAL ERROR in native method: processing of -javaagent failed Exception in thread \"main\" Solution: Change the dependency of your application to a more recent release. In the above example, the following XML snippet was added to the application's POM (which transitively depended on it): <dependency> <groupId> commons-collections </groupId> <artifactId> commons-collections </artifactId> <version> 3.2.2 </version> </dependency>","title":"TEST : java.lang.NoSuchMethodError?"},{"location":"user/support/faq/#test-not-all-eclipse-steady-analysis-results-are-uploaded-to-the-backend","text":"Problem: At the end of the JUnit test case execution ( mvn -Dsteady test ), not all the Eclipse Steady analysis results are uploaded to the the Eclipse Steady backend. The reason is that the Maven Surefire Plugin kills the JVM before Eclipse Steady' shutdown hook uploaded all the data. Solution: Disable the upload by changing the Surefire configuration in the POM file as follows. The analysis results will then be written in the folder target/vulas/upload . Afterwards, run the Eclipse Steady plugin goal \"upload\" in order to upload the JSON analysis results to the backend ( mvn -Dsteady steady:upload ). <argLine> -Dvulas.upload=false","title":"TEST : Not all Eclipse Steady analysis results are uploaded to the backend"},{"location":"user/support/faq/#test-how-to-run-dsteady-test-in-projects-using-mockito","text":"Problem : when running mvn -Dsteady test , tests fail with an error such as org.mockito.exceptions.misusing.MissingMethodInvocationException Solution : Run your tests as usual: mvn test Then run them again with Eclipse Steady enabled to perform reachability analysis: mvn -Dmaven.test.failure.ignore = true -Dsteady test steady:upload Alternative solutions (when running mvn -Dsteady test ) : disable selectively the failing tests ignore selected jars","title":"TEST : How to run -Dsteady test in projects using Mockito?"},{"location":"user/support/faq/#test-byte-code-instrumentation-fails","text":"Problem No traces are collected during the execution of JUnit tests, no matter which instrumentor is used. Moreover, no corresponding error messages or exceptions are printed to the console. A possible indicator of that problem is the appearance of the log message \"Completed instantiation of trace collector\" after the log message \"Tests run: XXX, Failures: XXX, Errors: XXX, Skipped: XXX, Time elapsed: XXX sec\", which signals the termination of the actual JUnit tests. Example: [main] INFO com.sap.psr.vulas.monitor.InstrumentationControl - JAR [C:\\Users\\XXXXXX\\.m2\\repository\\org\\apache\\commons\\commons-lang3\\3.2\\commons-lang3-3.2.jar] is blacklisted: [false] Tests run: 2, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.141 sec - in code.MainTest [vulas-shutdown-trace-upload] INFO com.sap.psr.vulas.backend.requests.BasicHttpRequest - HTTP GET [uri=http://localhost:8033/backend/apps/XXXXXX/XXXXXX/XXXXXX/bugs?historical=false, proxy=false] [vulas-shutdown-trace-upload] INFO com.sap.psr.vulas.backend.requests.BasicHttpRequest - HTTP GET completed with response code [200] in [0,0573 min] [vulas-shutdown-trace-upload] INFO com.sap.psr.vulas.backend.BackendConnector - [53] constructs for [7] bugs received from backend [vulas-shutdown-trace-upload] INFO com.sap.psr.vulas.monitor.trace.TraceCollector - Completed instantiation of trace collector [vulas-shutdown-trace-upload] INFO com.sap.psr.vulas.monitor.trace.TraceCollector - No paths collected [vulas-shutdown-trace-upload] INFO com.sap.psr.vulas.monitor.trace.TraceCollector - No traces collected [vulas-shutdown-trace-upload] INFO com.sap.psr.vulas.GoalExecution - Eclipse Steady goal execution finished [id=TEST-1487175325075-7552264, goal=TEST, app=(XXXXXX:XXXXXX:XXXXXX)] in [0,0877 min] Solution Similar to the above problem, it can happen that an application depends on a previous release of Javassist. As such, methods required by Eclipse Steady are not present at the time Eclipse Steady tries to change the byte code of loaded classes. As for the previous problem, you can add an explicit dependency to the application under test in order to let Maven resolve to a recent release of Javassist.","title":"TEST : Byte code instrumentation fails"},{"location":"user/support/faq/#test-the-forked-vm-terminated","text":"Problem: Tests terminate with a log message as follows: The forked VM terminated without properly saying goodbye. VM crash or System.exit called? Solutions: Increase JVM heap space by adding -Xmx4096M -Xms2048M (or more if possible) to the <argLine> argument of the Maven Surefire plugin Select an instrumentor that consumes less memory by adding, for instance, -Dvulas.core.instr.instrumentorsChoosen=com.sap.psr.vulas.monitor.trace.SingleTraceInstrumentor .","title":"TEST : The forked VM terminated"},{"location":"user/support/faq/#test-incomplete-app-context","text":"Problem Tests terminate with the error message App context incomplete: [group=, artifact=, version=] and there exists a white space in any of the parent directories of the Maven project (e.g., C:\\My Documents\\projects\\foo ). Solutions Move the Maven project to a location without whitespaces in the names of any of the parent directories. Open the pom.xml and replace the Maven variable ${project.build.directory} in the <argLine> configuration setting of the maven-surefire-plugi n by the relative path of the respective directory, typically target . Open the POM file and remove the -Dvulas.core.uploadDir and -Dvulas.shared.tmpDir system properties in the <argLine> configuration setting of the maven-surefire-plugin . Create two new system property variables in the configuration section of the maven-surefire-plugin as follows (see here for more information). <systemPropertyVariables> <vulas.core.uploadDir> ${project.build.directory}/vulas/upload </vulas.core.uploadDir> <vulas.shared.tmpDir> ${project.build.directory}/vulas/tmp </vulas.shared.tmpDir> </systemPropertyVariables>","title":"TEST : Incomplete app context"},{"location":"user/support/faq/#test-error-injecting-private-orgeclipseaetherspiloglogger-orgapachemavenrepositoryinternaldefaultversionresolverlogger","text":"Problem When running the Eclipse Steady test goal, you face an error similar to Error injecting: private org.eclipse.aether.spi.log.Logger org.apache.maven.repository.internal.DefaultVersionResolver.logger Solution This error seems to appear with certain versions of Maven. It should disappear with maven 3.5.2 or higher. Please insure which version of maven you are using. If you locally run maven on your machine, please upgrade your local maven version to maven 3.5.2 or higher and run your scan again. If you perform your scans in a CI/CD environment like Jenkins, please check which version of Maven is used there. Then validate that the issue is linked to the current maven version (see previous point). Once you validated that the current Maven version is responsible for the issue, proceed with the update/upgrade to Maven 3.5.2 or higher in your CI/CD environment. As an example in Jenkins environments you can use one of the following alternatives: Make an upgrade request to your Jenkins administrator. Install Maven \"globaly\": in this case you can continue using your former command ex: mvn clean compile steady:clean steady:app install steady:upload -Pvulas -Dskip.integration.tests as it is and Jenkins will use the new version. Install maven as new \"Global Tool\": you can do this in \"Manage Jenkins\" -> \"Global Tool Configuration\". Here you find the entry \"Maven installations\". Add there the new Maven installation \"M360\" (if you like to install maven 3.6.0) with the installer \"Install from Apache\" Version 3.6.0. As a consequence, you will need to change the command in your job/task so that the new Maven version is used instead of the global one (which is still the version including the bug) and your command should like like /var/jenkins_home/tools/hudson.tasks.Maven_MavenInstallation/M360/bin/mvn clean compile steady:clean steady:app install steady:upload -Pvulas -Dskip.integration.tests","title":"TEST : \"Error injecting: private org.eclipse.aether.spi.log.Logger org.apache.maven.repository.internal.DefaultVersionResolver.logger\""},{"location":"user/support/faq/#junit-tests-using-powermock-fail-when-using-eclipse-steady","text":"Problem JUnit tests making use of Powermock fail when activating the Eclipse Steady profile. Explanation In order to collect execution traces during test execution, the Eclipse Steady agent has to be registered at the JVM. This is done in the configuration section of the surefire plugin inside the Eclipse Steady profile. The parallel use of Powermock and the Eclipse Steady agent, which modifies all the bytecode of every class loaded by the JVM, fails in certain cases. Solution(s) This problem can be solved in several ways: Ignore all test failures by adding -Dmaven.test.failure.ignore=true (also see other options of the maven-surefire-plugin ) In case of multi-module projects, continue the build of later modules using the options --fail-never or --fail-at-end (see here for more information) Exclude problematic classes from being instrumented by adding their prefixes via -Dvulas.core.instr.blacklist.classes.custom=foo.bar,bar.baz.Class,... Exclude single problematic tests by modifying the <excludes> section of the surefire configuration in the Eclipse Steady profile: <excludes> <exclude> **/doesnotexist.java </exclude> </excludes>","title":"JUnit tests using Powermock fail when using Eclipse Steady"},{"location":"user/support/faq/#python","text":"","title":"Python"},{"location":"user/support/faq/#app-goal-is-slow","text":"Dependencies are analyzed by setting up a virtual environment for the respective application. The setup of such a virtualenv can take some time (no matter whether it is done in the context of Eclipse Steady or not). Moreover, whenever a Python library is found that is not yet known to the backend, its bill of material needs to be uploaded. The delay caused by this initial upload will not occur for subsequent scans.","title":"app goal is slow"},{"location":"user/support/faq/#virtualenv-problems","text":"Run virtualenv from the command line to see whether it is properly installed and working.","title":"virtualenv problems"},{"location":"user/support/faq/#other-topics","text":"","title":"Other topics"},{"location":"user/support/faq/#report-the-html-result-report-is-not-properly-rendered-inside-jenkins","text":"Symptom : The HTML report is not properly rendered inside Jenkins (e.g., no images, no color-coding, no JavaScript, see the example screenshot below). Solution : Either (a) download a ZIP of the Eclipse Steady report (the link can be found in the upper-right corner), or (b) adjust the content security policy (CSP) of Jenkins as described here . In the latter case, you should execute the following command in the Jenkins script console (on a single line ): System . setProperty ( \"hudson.model.DirectoryBrowserSupport.CSP\" , \"sandbox allow-scripts; default-src 'none'; img-src 'self' data:; style-src 'self' 'unsafe-inline'; script-src 'unsafe-inline'\" )","title":"report: The HTML result report is not properly rendered inside Jenkins"},{"location":"user/support/faq/#no-log-messages-of-the-eclipse-steady-maven-plugin-appear-on-the-console-why","text":"Symptom Eclipse Steady log messages are not printed to the console (e.g., during the execution of the Maven lifecycle phase \"test\"). Instead, the following error message is printed. ERROR StatusLogger No log4j2 configuration file found. Using default configuration: logging only errors to the console. Explanation The Eclipse Steady Maven plugin makes use of log4j version 1, a corresponding configuration file is included in its JAR file. If, however, the project under analysis makes use of log4j version 2, but does not have a log4j2.xml file in folder src/main/resources , no log message of Eclipse Steady but the above error message is printed. Still, the traces are actually collected and uploaded to the central engine. Solution Create a file src/main/resources/log4j2.xml with the following sample content (copied from here ) and adapt as needed. <?xml version=\"1.0\" encoding=\"UTF-8\"?> <Configuration> <Appenders> <Console name= \"STDOUT\" target= \"SYSTEM_OUT\" > <PatternLayout pattern= \"%d %-5p [%t] %C{2} (%F:%L) - %m%n\" /> </Console> </Appenders> <Loggers> <Logger name= \"org.apache.log4j.xml\" level= \"info\" /> <Root level= \"info\" > <AppenderRef ref= \"STDOUT\" /> </Root> </Loggers> </Configuration>","title":"No log messages of the Eclipse Steady Maven plugin appear on the console. Why?"},{"location":"user/support/faq/#outofmemoryerror-gc-overhead-limit-exceeded","text":"Use the command line options -Xms and -Xmx to adjust the heap memory available to the JVM. Chose a value for -Xmx that is close to your machine's physical memory. In case of Maven, use the statement export MAVEN_OPTS=\"-Xms4g -Xmx8g\" . For versions before Java 8, you should also add the options -XX:MaxPermSize=2024M -XX:+CMSClassUnloadingEnabled . Notes: See here for problems related to the heap space allocations on 32bit Java versions See here for background information on Java memory management","title":"OutOfMemoryError: GC overhead limit exceeded?"},{"location":"user/support/faq/#i-get-an-error-saying-verifyerror-inconsistent-stackmap-frames-at-branch-target-what-should-i-do","text":"If the execution of the Maven Surefire Plugin during the Maven lifecycle phase test fails with a java.lang.VerifyError similar to the following: [ERROR] Failed to execute goal org.apache.maven.plugins:maven-surefire-plugin:2.16:test (default-test) on project foo-bar: Execution default-test of goal org.apache.maven.plugins:maven-surefire-plugin:2.16:test failed: There was an error in the forked process [ERROR] java.lang.VerifyError: Inconsistent stackmap frames at branch target 54 [ERROR] Exception Details: [ERROR] Location: [ERROR] com/acme/FooTest.<init>()V @54: aconst_null [ERROR] Reason: [ERROR] Type uninitializedThis (current frame, locals[0]) is not assignable to 'com/acme/FooTest' (stack map, locals[0]) [ERROR] Current Frame: [ERROR] bci: @16 [ERROR] flags: { flagThisUninit } [ERROR] locals: { uninitializedThis, null, 'java/lang/ClassLoader' } [ERROR] stack: { 'java/lang/ClassLoader', null } [ERROR] Stackmap Frame: [ERROR] bci: @54 [ERROR] flags: { } [ERROR] locals: { 'com/acme/FooTest', 'java/net/URL', 'java/lang/ClassLoader' } [ERROR] stack: { } [ERROR] Bytecode: [ERROR] 0000000: b200 bd9a 0047 014c 1235 b600 914d 2c01 [ERROR] 0000010: a500 262c bb00 9359 b700 9412 35b6 0098 [ERROR] 0000020: 102e 102f b600 9cb6 00a0 12a2 b600 a0b6 [ERROR] 0000030: 00a5 b600 ab4c 014e 12bf 2c2b 0101 0101 [ERROR] 0000040: 2d03 0304 b800 c2b3 00bd 2ab7 0001 b800 [ERROR] 0000050: 022a b600 0312 04b6 0005 4c2a 2bb8 0006 [ERROR] 0000060: b500 07b1 [ERROR] Stackmap Table: [ERROR] full_frame(@54,{Object[#53],Object[#181],Object[#167]},{}) [ERROR] full_frame(@74,{UninitializedThis},{}) [ERROR] [ERROR] at java.lang.Class.getDeclaredMethods0(Native Method) then you should include the Java option noverify in the Surefire configuration as follows: <argLine> -javaagent:target/vulas/lib/vulas-core-${vulas.version}-jar-with-dependencies.jar -DperiodicUpload.enabled=false -DappContext.fixed.groupId=${project.groupId} -DappContext.fixed.artifactId=${project.artifactId} -DappContext.fixed.version=${project.version} -noverify <!-- Uncomment to debug the test execution or the Eclipse Steady plugin --> <!-- -Xrunjdwp:transport=dt_socket,server=y,suspend=y,address=8000 --> </argLine> See here for more information on the noverify option: Stackoverflow Informit","title":"I get an error saying VerifyError: Inconsistent stackmap frames at branch target. What should I do?"},{"location":"user/tutorials/","text":"Quickstart \u00b6 This section provides the bare minimum to setup Steady and to use its Maven plugin for scanning a Java application. The Steady backend , a Docker Compose application, stores information about open-source vulnerabilities and scan results. It has to be installed once, ideally on a dedicated host, and must be running during application scans. Download and run setup-steady.sh to install the backend on any host with a recent version of Docker/Docker Compose (the use of profiles requires a version >= 1.28, installable with pip install docker-compose or as described here ). Notes : During its first execution, triggered by the setup script or directly using start-steady.sh -s ui , the backend will be bootstrapped by downloading and processing code-level information of hundreds of vulnerabilities maintained in the open-source knowledge base Project KB . While the bootstrapping can take up to one hour, later updates will import the delta on a daily basis. Run start-steady.sh -s none to shut down all Docker Compose services of the backend. A Steady scan client , e.g. the Maven plugin, analyzes the code of your application project and its dependencies. Being available on Maven Central , the clients do not require any installation. However, they need to be run whenever your application's code or dependencies change. In case application scan and Steady backend run on different hosts, the scan clients must be configured accordingly. Just copy and adjust the file ~/.steady.properties , which has been created in the user's home directory during the backend setup. For Maven, cd into your project and run the app analysis goal as follows (see here for more information about available goals): mvn org.eclipse.steady:plugin-maven:3.2.0:app Note : During application scans, a lot of information about its dependencies is uploaded to the backend, which makes that the first scan takes significantly more time than later scans of the same application. Next Steps \u00b6 In the following a set of step-by-step guides on how to perform the most common operations with Eclipse Steady. For more detailed documentation, please check out the Eclipse Steady Manual . Workspace \u00b6 If multiple applications or application versions are scanned, it makes sense to create dedicated workspaces rather than keeping all scan results in the default workspace. Create a workspace (Beginner) Workspaces for multiple releases/branches (Advanced) Java \u00b6 Scanning Java apps built with Maven (Beginner) Scanning Java apps built with Gradle (Beginner) Scanning Java apps (no/other build system) (Beginner) - please follow this tutorial if your project neither uses Maven nor Gradle. Reachability analysis (Java/Maven) (Advanced) Python \u00b6 Scanning Python apps (other build systems) (Beginner) Other topics \u00b6 Automating Eclipse Steady scans with Jenkins Demystifying Eclipse Steady reports","title":"Getting started"},{"location":"user/tutorials/#quickstart","text":"This section provides the bare minimum to setup Steady and to use its Maven plugin for scanning a Java application. The Steady backend , a Docker Compose application, stores information about open-source vulnerabilities and scan results. It has to be installed once, ideally on a dedicated host, and must be running during application scans. Download and run setup-steady.sh to install the backend on any host with a recent version of Docker/Docker Compose (the use of profiles requires a version >= 1.28, installable with pip install docker-compose or as described here ). Notes : During its first execution, triggered by the setup script or directly using start-steady.sh -s ui , the backend will be bootstrapped by downloading and processing code-level information of hundreds of vulnerabilities maintained in the open-source knowledge base Project KB . While the bootstrapping can take up to one hour, later updates will import the delta on a daily basis. Run start-steady.sh -s none to shut down all Docker Compose services of the backend. A Steady scan client , e.g. the Maven plugin, analyzes the code of your application project and its dependencies. Being available on Maven Central , the clients do not require any installation. However, they need to be run whenever your application's code or dependencies change. In case application scan and Steady backend run on different hosts, the scan clients must be configured accordingly. Just copy and adjust the file ~/.steady.properties , which has been created in the user's home directory during the backend setup. For Maven, cd into your project and run the app analysis goal as follows (see here for more information about available goals): mvn org.eclipse.steady:plugin-maven:3.2.0:app Note : During application scans, a lot of information about its dependencies is uploaded to the backend, which makes that the first scan takes significantly more time than later scans of the same application.","title":"Quickstart"},{"location":"user/tutorials/#next-steps","text":"In the following a set of step-by-step guides on how to perform the most common operations with Eclipse Steady. For more detailed documentation, please check out the Eclipse Steady Manual .","title":"Next Steps"},{"location":"user/tutorials/#workspace","text":"If multiple applications or application versions are scanned, it makes sense to create dedicated workspaces rather than keeping all scan results in the default workspace. Create a workspace (Beginner) Workspaces for multiple releases/branches (Advanced)","title":"Workspace"},{"location":"user/tutorials/#java","text":"Scanning Java apps built with Maven (Beginner) Scanning Java apps built with Gradle (Beginner) Scanning Java apps (no/other build system) (Beginner) - please follow this tutorial if your project neither uses Maven nor Gradle. Reachability analysis (Java/Maven) (Advanced)","title":"Java"},{"location":"user/tutorials/#python","text":"Scanning Python apps (other build systems) (Beginner)","title":"Python"},{"location":"user/tutorials/#other-topics","text":"Automating Eclipse Steady scans with Jenkins Demystifying Eclipse Steady reports","title":"Other topics"},{"location":"user/tutorials/java_cli/","text":"Scanning Java apps with the CLI \u00b6 This tutorial will walk you through the steps needed to setup and use Eclipse Steady to scan a Java application that is not built with tools such as Maven or Gradle . Terminology: 'Goals' For consistency with the terminology used in Maven, the different \"commands\" available in Eclipse Steady are referred to as \" goals \". Prerequisites \u00b6 JDK 7 or later URLs of the backend service and apps Web frontend Apps Web frontend: http://localhost:8033/apps Backend service: http://localhost:8033/backend/ The token of a Eclipse Steady workspace Workspace creation If you do not have a workspace yet, you can easily create one by going on the application frontend and clicking on the third button in the lower left corner: For a detailed description of workspaces and of the inputs you have to provide in the form that is displayed when you click that button, please see this section of the manual . Download \u00b6 Please download the latest ZIP archive steady-cli-3.2.2.zip from Releases and extract it into a newly created folder. This folder will contain the following items: ./app/ Put the application code (java, class or JAR files) and all application dependencies (JAR files) into this folder. It will be searched recursively, thus, it is possible to just copy the entire installation directory of an application into the folder. ./steady-cli-3.2.2-jar-with-dependencies.jar An executable JAR, which is the actual command-line version of the Eclipse Steady client. This is what you will use later to execute Eclipse Steady scans. ./instr/lang-java-3.2.2-jar-with-dependencies.jar This is used to instrument the Java runtime when performing dynamic analysis. ./steady-custom.properties.sample This is a template for the configuration file required by Eclipse Steady. You will change it in order to specify an identifier for your application (see below). Setup \u00b6 Rename the file steady-custom.properties.sample to steady-custom.properties and edit it to specify <GROUP> , <ARTIFACT> and <VERSION> of the application to be analyzed. Those settings will be used to uniquely identify the application in the backend. Set the option vulas.core.space.token so that it is assigned your own workspace token. Put the application code (java, class or JAR files) and all application dependencies (JAR files) into this folder. Specify how Eclipse Steady can distinguish the code of your application from its dependencies, which is necessary for the call graph construction during the reachability analyses (goals a2c and t2c ). You can do so in two different ways: you can use either vulas.core.app.appPrefixes or vulas.core.app.appJarNames . # Package prefix(es) of application code (multiple values to be separated by comma), only relevant for CLI vulas.core.app.appPrefixes = # Regex that identifies JARs with application code (multiple values to be separated by comma), only relevant for CLI vulas.core.app.appJarNames = Warning In order for the static reachability analysis to be performed correctly, all application methods must be used as entry points for the call graph construction. Therefore, if the criterion to distinguish application code and dependencies is not specified correctly, the potential execution of vulnerable open-source methods may be missed. To check whether the specification is correct, you may want to inspect the application frontend and see whether there are any items in the Dependencies tab that are created by you or your organization (there should be none, only 3 rd party libraries should be there), and whether there are open-source packages at all in the table on the Dependencies tab (there should be none, only packages from your own project). IMPORTANT REMARKS You should also keep the following into account: Single java and class files are always considered as application code ( regardless of the package prefix configured with vulas.core.app.appPrefixes ). JARs are always considered application dependencies unless they only contain methods starting with the configured package prefix. Nested JARs must be manually extracted (but no need to do so for WARs). Goal execution \u00b6 See here for a description of all analysis goals. app \u00b6 java -jar steady-cli-3.2.2-jar-with-dependencies.jar -goal app Connect to the apps Web frontend, then select your workspace and application. The table in tab Dependencies is populated. Dependencies with known vulnerabilities are shown in tab Vulnerabilities . Assess and mitigate Once app has been run, the assessment of findings can already start: Each finding shown on the Vulnerabilities tab corresponds to a dependency of an application on a component with a known security vulnerability. See here for more information on how to assess and mitigate findings. Other analysis goals can be used to collect further evidence concerning the reachability of vulnerable code. report \u00b6 java -jar steady-cli-3.2.2-jar-with-dependencies.jar -goal report Check the console to see where the HTML, JSON and XML reports have been written to. clean \u00b6 java -jar steady-cli-3.2.2-jar-with-dependencies.jar -goal clean All application-specific data in the Eclipse Steady backend are deleted. Run clean whenever the application changes If you already scanned your project in the past, you should run the clean goal prior to new analyses in order to delete the old analysis results in the backend. Otherwise, old analysis results will be shown together with new results. For example, if you updated a dependency from a vulnerable to a non-vulnerable version, both versions will be shown in the apps Web frontend. Useful links \u00b6 Automate with Jenkins Configure the client-side analysis Get help if you run into troubles Assess and mitigate reported vulnerabilities","title":"Scanning Java (CLI)"},{"location":"user/tutorials/java_cli/#scanning-java-apps-with-the-cli","text":"This tutorial will walk you through the steps needed to setup and use Eclipse Steady to scan a Java application that is not built with tools such as Maven or Gradle . Terminology: 'Goals' For consistency with the terminology used in Maven, the different \"commands\" available in Eclipse Steady are referred to as \" goals \".","title":"Scanning Java apps with the CLI"},{"location":"user/tutorials/java_cli/#prerequisites","text":"JDK 7 or later URLs of the backend service and apps Web frontend Apps Web frontend: http://localhost:8033/apps Backend service: http://localhost:8033/backend/ The token of a Eclipse Steady workspace Workspace creation If you do not have a workspace yet, you can easily create one by going on the application frontend and clicking on the third button in the lower left corner: For a detailed description of workspaces and of the inputs you have to provide in the form that is displayed when you click that button, please see this section of the manual .","title":"Prerequisites"},{"location":"user/tutorials/java_cli/#download","text":"Please download the latest ZIP archive steady-cli-3.2.2.zip from Releases and extract it into a newly created folder. This folder will contain the following items: ./app/ Put the application code (java, class or JAR files) and all application dependencies (JAR files) into this folder. It will be searched recursively, thus, it is possible to just copy the entire installation directory of an application into the folder. ./steady-cli-3.2.2-jar-with-dependencies.jar An executable JAR, which is the actual command-line version of the Eclipse Steady client. This is what you will use later to execute Eclipse Steady scans. ./instr/lang-java-3.2.2-jar-with-dependencies.jar This is used to instrument the Java runtime when performing dynamic analysis. ./steady-custom.properties.sample This is a template for the configuration file required by Eclipse Steady. You will change it in order to specify an identifier for your application (see below).","title":"Download"},{"location":"user/tutorials/java_cli/#setup","text":"Rename the file steady-custom.properties.sample to steady-custom.properties and edit it to specify <GROUP> , <ARTIFACT> and <VERSION> of the application to be analyzed. Those settings will be used to uniquely identify the application in the backend. Set the option vulas.core.space.token so that it is assigned your own workspace token. Put the application code (java, class or JAR files) and all application dependencies (JAR files) into this folder. Specify how Eclipse Steady can distinguish the code of your application from its dependencies, which is necessary for the call graph construction during the reachability analyses (goals a2c and t2c ). You can do so in two different ways: you can use either vulas.core.app.appPrefixes or vulas.core.app.appJarNames . # Package prefix(es) of application code (multiple values to be separated by comma), only relevant for CLI vulas.core.app.appPrefixes = # Regex that identifies JARs with application code (multiple values to be separated by comma), only relevant for CLI vulas.core.app.appJarNames = Warning In order for the static reachability analysis to be performed correctly, all application methods must be used as entry points for the call graph construction. Therefore, if the criterion to distinguish application code and dependencies is not specified correctly, the potential execution of vulnerable open-source methods may be missed. To check whether the specification is correct, you may want to inspect the application frontend and see whether there are any items in the Dependencies tab that are created by you or your organization (there should be none, only 3 rd party libraries should be there), and whether there are open-source packages at all in the table on the Dependencies tab (there should be none, only packages from your own project). IMPORTANT REMARKS You should also keep the following into account: Single java and class files are always considered as application code ( regardless of the package prefix configured with vulas.core.app.appPrefixes ). JARs are always considered application dependencies unless they only contain methods starting with the configured package prefix. Nested JARs must be manually extracted (but no need to do so for WARs).","title":"Setup"},{"location":"user/tutorials/java_cli/#goal-execution","text":"See here for a description of all analysis goals.","title":"Goal execution"},{"location":"user/tutorials/java_cli/#app","text":"java -jar steady-cli-3.2.2-jar-with-dependencies.jar -goal app Connect to the apps Web frontend, then select your workspace and application. The table in tab Dependencies is populated. Dependencies with known vulnerabilities are shown in tab Vulnerabilities . Assess and mitigate Once app has been run, the assessment of findings can already start: Each finding shown on the Vulnerabilities tab corresponds to a dependency of an application on a component with a known security vulnerability. See here for more information on how to assess and mitigate findings. Other analysis goals can be used to collect further evidence concerning the reachability of vulnerable code.","title":"app"},{"location":"user/tutorials/java_cli/#report","text":"java -jar steady-cli-3.2.2-jar-with-dependencies.jar -goal report Check the console to see where the HTML, JSON and XML reports have been written to.","title":"report"},{"location":"user/tutorials/java_cli/#clean","text":"java -jar steady-cli-3.2.2-jar-with-dependencies.jar -goal clean All application-specific data in the Eclipse Steady backend are deleted. Run clean whenever the application changes If you already scanned your project in the past, you should run the clean goal prior to new analyses in order to delete the old analysis results in the backend. Otherwise, old analysis results will be shown together with new results. For example, if you updated a dependency from a vulnerable to a non-vulnerable version, both versions will be shown in the apps Web frontend.","title":"clean"},{"location":"user/tutorials/java_cli/#useful-links","text":"Automate with Jenkins Configure the client-side analysis Get help if you run into troubles Assess and mitigate reported vulnerabilities","title":"Useful links"},{"location":"user/tutorials/java_gradle/","text":"Scanning Java apps built with Gradle \u00b6 Prerequisites \u00b6 JDK 7 or later URLs of the backend service and apps Web frontend Apps Web frontend: http://localhost:8033/apps Backend service: http://localhost:8033/backend/ The token of a Eclipse Steady workspace Workspace creation If you do not have a workspace yet, you can easily create one by going on the application frontend and clicking on the third button in the lower left corner: For a detailed description of workspaces and of the inputs you have to provide in the form that is displayed when you click that button, please see this section of the manual . Setup \u00b6 The plugin for Gradle requires changes of the following two files: build.gradle buildscript { repositories { mavenCentral() } dependencies { classpath('org.eclipse.steady:plugin-gradle:3.2.2') { changing = true } } } allprojects { apply plugin: \"steady\" } gradle.properties // Used to identify the scan in the apps Web frontend group = <GROUP> version = <VERSION> // Replace token of test space vulas.core.space.token = <WORKSPACE-TOKEN> vulas.shared.backend.serviceUrl = http://localhost:8033/backend/ Note: Rather than adding configuration settings to gradle.properties , they can also be passed as project properties in the command line, e.g., -Pvulas.report.exceptionThreshold=noException . The use of -D system properties for changing configuration settings is discouraged (because of the cache of the Gradle daemon). The configuration is correct if the Eclipse Steady analysis goals app , a2c etc. are listed among Other tasks when running the following command: ./gradlew tasks --all The Gradle plugin only works with later releases of Gradle. How to upgrade is described here . Goal execution \u00b6 See here for a description of all analysis goals. app \u00b6 ./gradlew assemble vulasApp Connect to the apps Web frontend, then select your workspace and application. The table in tab Dependencies is populated. Dependencies with known vulnerabilities are shown in tab Vulnerabilities . Assess and mitigate Once app has been run, the assessment of findings can already start: Each finding shown on the Vulnerabilities tab corresponds to a dependency of an application on a component with a known security vulnerability. See here for more information on how to assess and mitigate findings. Other analysis goals can be used to collect further evidence concerning the reachability of vulnerable code. report \u00b6 ./gradlew vulasReport A summary report is written to disk (in HTML, XML and JSON format), by default into folder target/vulas/report . By default a build exception is thrown if the application includes a library subject to known vulnerabilities. clean \u00b6 ./gradlew vulasClean All application-specific data in the Eclipse Steady backend are deleted. Run clean whenever the application changes If you already scanned your project in the past, you should run the clean goal prior to new analyses in order to delete the old analysis results in the backend. Otherwise, old analysis results will be shown together with new results. For example, if you updated a dependency from a vulnerable to a non-vulnerable version, both versions will be shown in the apps Web frontend. Useful links \u00b6 Automate with Jenkins Configure the client-side analysis Get help if you run into troubles Assess and mitigate reported vulnerabilities","title":"Scanning Java (Gradle)"},{"location":"user/tutorials/java_gradle/#scanning-java-apps-built-with-gradle","text":"","title":"Scanning Java apps built with Gradle"},{"location":"user/tutorials/java_gradle/#prerequisites","text":"JDK 7 or later URLs of the backend service and apps Web frontend Apps Web frontend: http://localhost:8033/apps Backend service: http://localhost:8033/backend/ The token of a Eclipse Steady workspace Workspace creation If you do not have a workspace yet, you can easily create one by going on the application frontend and clicking on the third button in the lower left corner: For a detailed description of workspaces and of the inputs you have to provide in the form that is displayed when you click that button, please see this section of the manual .","title":"Prerequisites"},{"location":"user/tutorials/java_gradle/#setup","text":"The plugin for Gradle requires changes of the following two files: build.gradle buildscript { repositories { mavenCentral() } dependencies { classpath('org.eclipse.steady:plugin-gradle:3.2.2') { changing = true } } } allprojects { apply plugin: \"steady\" } gradle.properties // Used to identify the scan in the apps Web frontend group = <GROUP> version = <VERSION> // Replace token of test space vulas.core.space.token = <WORKSPACE-TOKEN> vulas.shared.backend.serviceUrl = http://localhost:8033/backend/ Note: Rather than adding configuration settings to gradle.properties , they can also be passed as project properties in the command line, e.g., -Pvulas.report.exceptionThreshold=noException . The use of -D system properties for changing configuration settings is discouraged (because of the cache of the Gradle daemon). The configuration is correct if the Eclipse Steady analysis goals app , a2c etc. are listed among Other tasks when running the following command: ./gradlew tasks --all The Gradle plugin only works with later releases of Gradle. How to upgrade is described here .","title":"Setup"},{"location":"user/tutorials/java_gradle/#goal-execution","text":"See here for a description of all analysis goals.","title":"Goal execution"},{"location":"user/tutorials/java_gradle/#app","text":"./gradlew assemble vulasApp Connect to the apps Web frontend, then select your workspace and application. The table in tab Dependencies is populated. Dependencies with known vulnerabilities are shown in tab Vulnerabilities . Assess and mitigate Once app has been run, the assessment of findings can already start: Each finding shown on the Vulnerabilities tab corresponds to a dependency of an application on a component with a known security vulnerability. See here for more information on how to assess and mitigate findings. Other analysis goals can be used to collect further evidence concerning the reachability of vulnerable code.","title":"app"},{"location":"user/tutorials/java_gradle/#report","text":"./gradlew vulasReport A summary report is written to disk (in HTML, XML and JSON format), by default into folder target/vulas/report . By default a build exception is thrown if the application includes a library subject to known vulnerabilities.","title":"report"},{"location":"user/tutorials/java_gradle/#clean","text":"./gradlew vulasClean All application-specific data in the Eclipse Steady backend are deleted. Run clean whenever the application changes If you already scanned your project in the past, you should run the clean goal prior to new analyses in order to delete the old analysis results in the backend. Otherwise, old analysis results will be shown together with new results. For example, if you updated a dependency from a vulnerable to a non-vulnerable version, both versions will be shown in the apps Web frontend.","title":"clean"},{"location":"user/tutorials/java_gradle/#useful-links","text":"Automate with Jenkins Configure the client-side analysis Get help if you run into troubles Assess and mitigate reported vulnerabilities","title":"Useful links"},{"location":"user/tutorials/java_maven/","text":"Scanning Java apps built with Maven \u00b6 Prerequisites \u00b6 JDK 7 or later Apache Maven 3.x with settings.xml configured to download from the Maven repository hosting the Eclipse Steady plugin for Maven URLs of the backend service and apps Web frontend Apps Web frontend: http://localhost:8033/apps Backend service: http://localhost:8033/backend/ The token of a Eclipse Steady workspace Workspace creation If you do not have a workspace yet, you can easily create one by going on the application frontend and clicking on the third button in the lower left corner: For a detailed description of workspaces and of the inputs you have to provide in the form that is displayed when you click that button, please see this section of the manual . Setup \u00b6 The plugin for Maven can be used with or without adding a Eclipse Steady profile to the pom.xml of your application. This tutorial guides you through the setup with Eclipse Steady profile . Cannot add the Eclipse Steady profile? If possible we recommend to use the Eclipse Steady profile as the execution of goals using the command-line is more concise (readable). If you cannot paste the Eclipse Steady profile in the pom.xml of your application you can still use the Eclipse Steady plugin for Maven. Check out the Manual Java (Maven) Add the following to the <profiles> section of the pom.xml of your application project and make sure that <vulas.shared.backend.serviceUrl> points to the URL of the backend service and that <vulas.core.space.token> specifies the token of your individual workspace (see highlighted lines). <profile> <id> steady </id> <activation> <property> <name> steady </name> </property> </activation> <properties> <vulas.version> 3.2.2 </vulas.version> <vulas.shared.backend.serviceUrl> http://localhost:8033/backend/ </vulas.shared.backend.serviceUrl> <vulas.core.space.token> WORKSPACE_TOKEN </vulas.core.space.token> <vulas.core.appContext.group> ${project.groupId} </vulas.core.appContext.group> <vulas.core.appContext.artifact> ${project.artifactId} </vulas.core.appContext.artifact> <vulas.core.appContext.version> ${project.version} </vulas.core.appContext.version> </properties> <build> <plugins> <plugin> <groupId> org.eclipse.steady </groupId> <artifactId> plugin-maven </artifactId> <version> ${vulas.version} </version> <configuration> <layeredConfiguration> <vulas.shared.backend.serviceUrl> ${vulas.shared.backend.serviceUrl} </vulas.shared.backend.serviceUrl> <vulas.core.space.token> ${vulas.core.space.token} </vulas.core.space.token> <vulas.core.appContext.group> ${vulas.core.appContext.group} </vulas.core.appContext.group> <vulas.core.appContext.artifact> ${vulas.core.appContext.artifact} </vulas.core.appContext.artifact> <vulas.core.appContext.version> ${vulas.core.appContext.version} </vulas.core.appContext.version> <vulas.shared.tmpDir> ${project.build.directory}/vulas/tmp </vulas.shared.tmpDir> <vulas.core.uploadDir> ${project.build.directory}/vulas/upload </vulas.core.uploadDir> <vulas.core.app.sourceDir> ${project.build.directory}/classes,${project.basedir}/src/main/java,${project.basedir}/src/main/python </vulas.core.app.sourceDir> <!-- steady:instr : Instruments JAR/WAR files found in source dir, and writes to target dir. Files in include dir are put into /WEB-INF/lib of output WARs. Files in lib dir are part of the class path when instrumenting. --> <vulas.core.instr.sourceDir> ${project.build.directory} </vulas.core.instr.sourceDir> <vulas.core.instr.targetDir> ${project.build.directory}/vulas/target </vulas.core.instr.targetDir> <vulas.core.instr.includeDir> ${project.build.directory}/vulas/include </vulas.core.instr.includeDir> <vulas.core.instr.libDir> ${project.build.directory}/vulas/lib </vulas.core.instr.libDir> <vulas.core.instr.writeCode> false </vulas.core.instr.writeCode> <vulas.core.instr.instrumentorsChoosen> org.eclipse.steady.java.monitor.trace.SingleTraceInstrumentor </vulas.core.instr.instrumentorsChoosen> <vulas.core.instr.searchRecursive> false </vulas.core.instr.searchRecursive> <vulas.core.monitor.periodicUpload.enabled> false </vulas.core.monitor.periodicUpload.enabled> <vulas.core.instr.maxStacktraces> 10 </vulas.core.instr.maxStacktraces> <!-- steady:a2c/t2c : Performs static call graph analysis --> <vulas.reach.wala.callgraph.reflection> NO_FLOW_TO_CASTS_NO_METHOD_INVOKE </vulas.reach.wala.callgraph.reflection> <vulas.reach.timeout> 60 </vulas.reach.timeout> <!-- steady:report --> <vulas.report.reportDir> ${project.build.directory}/vulas/report </vulas.report.reportDir> </layeredConfiguration> </configuration> </plugin> </plugins> </build> </profile> In case of aggregated, multi-module Maven projects with modules inheriting from their parent, it is sufficient to include the profile in the top-level (parent) pom.xml . If a module does not inherit from the parent, the profile has to be added to its POM file. Goal execution \u00b6 See here for a description of all analysis goals. app \u00b6 mvn -Dsteady compile steady:app Connect to the apps Web frontend, then select your workspace and application. The table in tab Dependencies is populated. Dependencies with known vulnerabilities are shown in tab Vulnerabilities . In case your application does not follow the standard structure of Maven applications, please refer to the Manual Java (Maven) to learn how to configure the Eclipse Steady plugin accordingly. Assess and mitigate Once app has been run, the assessment of findings can already start: Each finding shown on the Vulnerabilities tab corresponds to a dependency of an application on a component with a known security vulnerability. See here for more information on how to assess and mitigate findings. Other analysis goals can be used to collect further evidence concerning the reachability of vulnerable code. report \u00b6 mvn -Dsteady steady:report A summary report is written to disk (in HTML, XML and JSON format), by default into folder target/vulas/report . By default a build exception is thrown if the application includes a library subject to known vulnerabilities. Warning The goal report must be executed separately from the other analysis goal. Otherwise, in case of multi-module Maven projects, it may throw a build exception before all modules have been analyzed. clean \u00b6 mvn -Dsteady steady:clean All application-specific data in the Eclipse Steady backend are deleted. Run clean whenever the application changes If you already scanned your project in the past, you should run the clean goal prior to new analyses in order to delete the old analysis results in the backend. Otherwise, old analysis results will be shown together with new results. For example, if you updated a dependency from a vulnerable to a non-vulnerable version, both versions will be shown in the apps Web frontend. Useful links \u00b6 Automate with Jenkins Configure the client-side analysis Get help if you run into troubles Assess and mitigate reported vulnerabilities","title":"Scanning Java (Maven)"},{"location":"user/tutorials/java_maven/#scanning-java-apps-built-with-maven","text":"","title":"Scanning Java apps built with Maven"},{"location":"user/tutorials/java_maven/#prerequisites","text":"JDK 7 or later Apache Maven 3.x with settings.xml configured to download from the Maven repository hosting the Eclipse Steady plugin for Maven URLs of the backend service and apps Web frontend Apps Web frontend: http://localhost:8033/apps Backend service: http://localhost:8033/backend/ The token of a Eclipse Steady workspace Workspace creation If you do not have a workspace yet, you can easily create one by going on the application frontend and clicking on the third button in the lower left corner: For a detailed description of workspaces and of the inputs you have to provide in the form that is displayed when you click that button, please see this section of the manual .","title":"Prerequisites"},{"location":"user/tutorials/java_maven/#setup","text":"The plugin for Maven can be used with or without adding a Eclipse Steady profile to the pom.xml of your application. This tutorial guides you through the setup with Eclipse Steady profile . Cannot add the Eclipse Steady profile? If possible we recommend to use the Eclipse Steady profile as the execution of goals using the command-line is more concise (readable). If you cannot paste the Eclipse Steady profile in the pom.xml of your application you can still use the Eclipse Steady plugin for Maven. Check out the Manual Java (Maven) Add the following to the <profiles> section of the pom.xml of your application project and make sure that <vulas.shared.backend.serviceUrl> points to the URL of the backend service and that <vulas.core.space.token> specifies the token of your individual workspace (see highlighted lines). <profile> <id> steady </id> <activation> <property> <name> steady </name> </property> </activation> <properties> <vulas.version> 3.2.2 </vulas.version> <vulas.shared.backend.serviceUrl> http://localhost:8033/backend/ </vulas.shared.backend.serviceUrl> <vulas.core.space.token> WORKSPACE_TOKEN </vulas.core.space.token> <vulas.core.appContext.group> ${project.groupId} </vulas.core.appContext.group> <vulas.core.appContext.artifact> ${project.artifactId} </vulas.core.appContext.artifact> <vulas.core.appContext.version> ${project.version} </vulas.core.appContext.version> </properties> <build> <plugins> <plugin> <groupId> org.eclipse.steady </groupId> <artifactId> plugin-maven </artifactId> <version> ${vulas.version} </version> <configuration> <layeredConfiguration> <vulas.shared.backend.serviceUrl> ${vulas.shared.backend.serviceUrl} </vulas.shared.backend.serviceUrl> <vulas.core.space.token> ${vulas.core.space.token} </vulas.core.space.token> <vulas.core.appContext.group> ${vulas.core.appContext.group} </vulas.core.appContext.group> <vulas.core.appContext.artifact> ${vulas.core.appContext.artifact} </vulas.core.appContext.artifact> <vulas.core.appContext.version> ${vulas.core.appContext.version} </vulas.core.appContext.version> <vulas.shared.tmpDir> ${project.build.directory}/vulas/tmp </vulas.shared.tmpDir> <vulas.core.uploadDir> ${project.build.directory}/vulas/upload </vulas.core.uploadDir> <vulas.core.app.sourceDir> ${project.build.directory}/classes,${project.basedir}/src/main/java,${project.basedir}/src/main/python </vulas.core.app.sourceDir> <!-- steady:instr : Instruments JAR/WAR files found in source dir, and writes to target dir. Files in include dir are put into /WEB-INF/lib of output WARs. Files in lib dir are part of the class path when instrumenting. --> <vulas.core.instr.sourceDir> ${project.build.directory} </vulas.core.instr.sourceDir> <vulas.core.instr.targetDir> ${project.build.directory}/vulas/target </vulas.core.instr.targetDir> <vulas.core.instr.includeDir> ${project.build.directory}/vulas/include </vulas.core.instr.includeDir> <vulas.core.instr.libDir> ${project.build.directory}/vulas/lib </vulas.core.instr.libDir> <vulas.core.instr.writeCode> false </vulas.core.instr.writeCode> <vulas.core.instr.instrumentorsChoosen> org.eclipse.steady.java.monitor.trace.SingleTraceInstrumentor </vulas.core.instr.instrumentorsChoosen> <vulas.core.instr.searchRecursive> false </vulas.core.instr.searchRecursive> <vulas.core.monitor.periodicUpload.enabled> false </vulas.core.monitor.periodicUpload.enabled> <vulas.core.instr.maxStacktraces> 10 </vulas.core.instr.maxStacktraces> <!-- steady:a2c/t2c : Performs static call graph analysis --> <vulas.reach.wala.callgraph.reflection> NO_FLOW_TO_CASTS_NO_METHOD_INVOKE </vulas.reach.wala.callgraph.reflection> <vulas.reach.timeout> 60 </vulas.reach.timeout> <!-- steady:report --> <vulas.report.reportDir> ${project.build.directory}/vulas/report </vulas.report.reportDir> </layeredConfiguration> </configuration> </plugin> </plugins> </build> </profile> In case of aggregated, multi-module Maven projects with modules inheriting from their parent, it is sufficient to include the profile in the top-level (parent) pom.xml . If a module does not inherit from the parent, the profile has to be added to its POM file.","title":"Setup"},{"location":"user/tutorials/java_maven/#goal-execution","text":"See here for a description of all analysis goals.","title":"Goal execution"},{"location":"user/tutorials/java_maven/#app","text":"mvn -Dsteady compile steady:app Connect to the apps Web frontend, then select your workspace and application. The table in tab Dependencies is populated. Dependencies with known vulnerabilities are shown in tab Vulnerabilities . In case your application does not follow the standard structure of Maven applications, please refer to the Manual Java (Maven) to learn how to configure the Eclipse Steady plugin accordingly. Assess and mitigate Once app has been run, the assessment of findings can already start: Each finding shown on the Vulnerabilities tab corresponds to a dependency of an application on a component with a known security vulnerability. See here for more information on how to assess and mitigate findings. Other analysis goals can be used to collect further evidence concerning the reachability of vulnerable code.","title":"app"},{"location":"user/tutorials/java_maven/#report","text":"mvn -Dsteady steady:report A summary report is written to disk (in HTML, XML and JSON format), by default into folder target/vulas/report . By default a build exception is thrown if the application includes a library subject to known vulnerabilities. Warning The goal report must be executed separately from the other analysis goal. Otherwise, in case of multi-module Maven projects, it may throw a build exception before all modules have been analyzed.","title":"report"},{"location":"user/tutorials/java_maven/#clean","text":"mvn -Dsteady steady:clean All application-specific data in the Eclipse Steady backend are deleted. Run clean whenever the application changes If you already scanned your project in the past, you should run the clean goal prior to new analyses in order to delete the old analysis results in the backend. Otherwise, old analysis results will be shown together with new results. For example, if you updated a dependency from a vulnerable to a non-vulnerable version, both versions will be shown in the apps Web frontend.","title":"clean"},{"location":"user/tutorials/java_maven/#useful-links","text":"Automate with Jenkins Configure the client-side analysis Get help if you run into troubles Assess and mitigate reported vulnerabilities","title":"Useful links"},{"location":"user/tutorials/java_maven_advanced/","text":"Scanning Java apps built with Maven \u00b6 Beginner? Read here This tutorial is the second part of the introductory tutorial that you can find here . If you have not done so yet, you are warmly encouraged to follow that one first, and then come back here. This document will assume you already have a working configuration and have successfully executed the steps described in the basic tutorial. Prerequisites \u00b6 The same prerequisites as in the introductory tutorial also apply here. Goal execution \u00b6 The introductory tutorial explained how to use the app analysis goal in order to establish whether an application projects depends on open-source libraries that contain vulnerable code . This tutorial explains how to perform the static and dynamic analyses in order to collect evidence regarding the reachability or execution of vulnerable code in the context of a given application project. The reachability of vulnerable code is an important pre-requisite for the vulnerability to be exploitable. a2c \u00b6 mvn -Dsteady compile steady:a2c Connect to the apps Web frontend, then select your workspace and application. In the tab Vulnerabilities , the column Static Analysis is populated for all libraries subject to known vulnerabilities reachable from application code. By selecting a single row of this table and the one of the detailed page, one can get more information up until the paths of potential executions (if any). test \u00b6 mvn -Dsteady steady:prepare-agent test steady:upload Connect to the apps Web frontend, then select your workspace and application. In the tab Vulnerabilities , the column Dynamic Analysis is populated for all libraries subject to known vulnerabilities whose vulnerable code is executed during tests. By selecting single row of this table and the one of the detailed page, one can get more information up until the paths of actual executions (if any). In the tab Statistics , the number of traced vs. the number of total executable constructs (e.g., Java methods) is shown per application package. t2c \u00b6 mvn -Dsteady compile steady:t2c Connect to the apps Web frontend, then select your workspace and application. In the tab Vulnerabilities , the column Static Analysis is populated for all libraries subject to known vulnerabilities reachable from code executed during tests. By selecting single row of this table and the one of the detailed page, one can get more information up until the paths of potential executions (if any). report \u00b6 mvn -Dsteady steady:report A summary report is written to disk (in HTML, XML and JSON format), by default into folder target/vulas/report . By default a build exception is thrown if the application includes a library subject to known vulnerabilities. Warning The goal report must be executed separately from the other analysis goal. Otherwise, in case of multi-module Maven projects, it may throw a build exception before all modules have been analyzed. clean \u00b6 mvn -Dsteady steady:clean All application-specific data in the Eclipse Steady backend are deleted. Run clean whenever the application changes If you already scanned your project in the past, you should run the steady:clean goal prior to new analyses in order to delete the old analysis results in the backend. Otherwise, old analysis results will be shown together with new results. For example, if you updated a dependency from a vulnerable to a non-vulnerable version, both versions will be shown in the apps Web frontend. Useful links \u00b6 Automate with Jenkins Configure the client-side analysis Get help if you run into troubles Assess and mitigate reported vulnerabilities","title":"Reachability analysis (Java/Maven)"},{"location":"user/tutorials/java_maven_advanced/#scanning-java-apps-built-with-maven","text":"Beginner? Read here This tutorial is the second part of the introductory tutorial that you can find here . If you have not done so yet, you are warmly encouraged to follow that one first, and then come back here. This document will assume you already have a working configuration and have successfully executed the steps described in the basic tutorial.","title":"Scanning Java apps built with Maven"},{"location":"user/tutorials/java_maven_advanced/#prerequisites","text":"The same prerequisites as in the introductory tutorial also apply here.","title":"Prerequisites"},{"location":"user/tutorials/java_maven_advanced/#goal-execution","text":"The introductory tutorial explained how to use the app analysis goal in order to establish whether an application projects depends on open-source libraries that contain vulnerable code . This tutorial explains how to perform the static and dynamic analyses in order to collect evidence regarding the reachability or execution of vulnerable code in the context of a given application project. The reachability of vulnerable code is an important pre-requisite for the vulnerability to be exploitable.","title":"Goal execution"},{"location":"user/tutorials/java_maven_advanced/#a2c","text":"mvn -Dsteady compile steady:a2c Connect to the apps Web frontend, then select your workspace and application. In the tab Vulnerabilities , the column Static Analysis is populated for all libraries subject to known vulnerabilities reachable from application code. By selecting a single row of this table and the one of the detailed page, one can get more information up until the paths of potential executions (if any).","title":"a2c"},{"location":"user/tutorials/java_maven_advanced/#test","text":"mvn -Dsteady steady:prepare-agent test steady:upload Connect to the apps Web frontend, then select your workspace and application. In the tab Vulnerabilities , the column Dynamic Analysis is populated for all libraries subject to known vulnerabilities whose vulnerable code is executed during tests. By selecting single row of this table and the one of the detailed page, one can get more information up until the paths of actual executions (if any). In the tab Statistics , the number of traced vs. the number of total executable constructs (e.g., Java methods) is shown per application package.","title":"test"},{"location":"user/tutorials/java_maven_advanced/#t2c","text":"mvn -Dsteady compile steady:t2c Connect to the apps Web frontend, then select your workspace and application. In the tab Vulnerabilities , the column Static Analysis is populated for all libraries subject to known vulnerabilities reachable from code executed during tests. By selecting single row of this table and the one of the detailed page, one can get more information up until the paths of potential executions (if any).","title":"t2c"},{"location":"user/tutorials/java_maven_advanced/#report","text":"mvn -Dsteady steady:report A summary report is written to disk (in HTML, XML and JSON format), by default into folder target/vulas/report . By default a build exception is thrown if the application includes a library subject to known vulnerabilities. Warning The goal report must be executed separately from the other analysis goal. Otherwise, in case of multi-module Maven projects, it may throw a build exception before all modules have been analyzed.","title":"report"},{"location":"user/tutorials/java_maven_advanced/#clean","text":"mvn -Dsteady steady:clean All application-specific data in the Eclipse Steady backend are deleted. Run clean whenever the application changes If you already scanned your project in the past, you should run the steady:clean goal prior to new analyses in order to delete the old analysis results in the backend. Otherwise, old analysis results will be shown together with new results. For example, if you updated a dependency from a vulnerable to a non-vulnerable version, both versions will be shown in the apps Web frontend.","title":"clean"},{"location":"user/tutorials/java_maven_advanced/#useful-links","text":"Automate with Jenkins Configure the client-side analysis Get help if you run into troubles Assess and mitigate reported vulnerabilities","title":"Useful links"},{"location":"user/tutorials/jenkins_howto/","text":"Jenkins automation \u00b6 Quick vs. deep scans \u00b6 CI/CD jobs configured with Jenkins or Travis can be triggered in many different ways, e.g., on-commit or periodically, which decides about the frequency of scan jobs. Quick scans (without reachability analysis): If scan jobs are expected to run very frequently, e.g., after every commit in the application's source code repository, it is preferable to only execute the app analysis goal, which typically does not take more than a couple of minutes (at most). Such a quick scan detects the very same number of vulnerabilities than a deep scan, but does not collect any information about the reachability of vulnerable code. Maven mvn -Dsteady clean compile steady:clean steady:app Deep scans (with reachability analysis): Scan jobs that run once a day or less can include analysis goals such as a2c , test and t2c . The static analysis goals a2c and t2c , in particular, can take a considerable amount of time until completion (up to several hours), depending on the complexity of the application project under analysis (number of modules, number of application constructs, etc.): Maven mvn -Dsteady clean compile steady:clean steady:app steady:a2c steady:prepare-agent package steady:upload steady:t2c See here for more information on Eclipse Steady goals. Jenkins \u00b6 A typical Jenkins job configuration using the Eclipse Steady plugin for Maven comprises the following two build steps and one post-build action (see screenshot below): Build step for a quick scan or deep scan , depending on the expected run frequency. Build step -Dsteady steady:report to create result reports (per default in folder target/vulas/result ). Post-build action with HTML Publisher Plugin to copy the Html report created by report into the Jenkins dashboard. As such, Eclipse Steady results can be consumed w/o the need to scroll through the verbose console output. Additional notes: The above assumes that the Eclipse Steady Maven profile is present in the project's pom.xml . The report goal should always be run in a separate Maven invocation. Otherwise, in case of multi-module Maven projects, report may throw a build exception before all of the modules have been analyzed.","title":"Jenkins automation"},{"location":"user/tutorials/jenkins_howto/#jenkins-automation","text":"","title":"Jenkins automation"},{"location":"user/tutorials/jenkins_howto/#quick-vs-deep-scans","text":"CI/CD jobs configured with Jenkins or Travis can be triggered in many different ways, e.g., on-commit or periodically, which decides about the frequency of scan jobs. Quick scans (without reachability analysis): If scan jobs are expected to run very frequently, e.g., after every commit in the application's source code repository, it is preferable to only execute the app analysis goal, which typically does not take more than a couple of minutes (at most). Such a quick scan detects the very same number of vulnerabilities than a deep scan, but does not collect any information about the reachability of vulnerable code. Maven mvn -Dsteady clean compile steady:clean steady:app Deep scans (with reachability analysis): Scan jobs that run once a day or less can include analysis goals such as a2c , test and t2c . The static analysis goals a2c and t2c , in particular, can take a considerable amount of time until completion (up to several hours), depending on the complexity of the application project under analysis (number of modules, number of application constructs, etc.): Maven mvn -Dsteady clean compile steady:clean steady:app steady:a2c steady:prepare-agent package steady:upload steady:t2c See here for more information on Eclipse Steady goals.","title":"Quick vs. deep scans"},{"location":"user/tutorials/jenkins_howto/#jenkins","text":"A typical Jenkins job configuration using the Eclipse Steady plugin for Maven comprises the following two build steps and one post-build action (see screenshot below): Build step for a quick scan or deep scan , depending on the expected run frequency. Build step -Dsteady steady:report to create result reports (per default in folder target/vulas/result ). Post-build action with HTML Publisher Plugin to copy the Html report created by report into the Jenkins dashboard. As such, Eclipse Steady results can be consumed w/o the need to scroll through the verbose console output. Additional notes: The above assumes that the Eclipse Steady Maven profile is present in the project's pom.xml . The report goal should always be run in a separate Maven invocation. Otherwise, in case of multi-module Maven projects, report may throw a build exception before all of the modules have been analyzed.","title":"Jenkins"},{"location":"user/tutorials/python_cli/","text":"Scanning Python apps with the CLI \u00b6 Using Eclipse Steady for Python applications not built with SetupTools Prerequisites \u00b6 JDK 7 or later pip is installed and \"knows\" all application dependencies (check with pip list ) URLs of the backend service and apps Web frontend Apps Web frontend: http://localhost:8033/apps Backend service: http://localhost:8033/backend/ The token of a Eclipse Steady workspace Workspace creation If you do not have a workspace yet, you can easily create one by going on the application frontend and clicking on the third button in the lower left corner: For a detailed description of workspaces and of the inputs you have to provide in the form that is displayed when you click that button, please see this section of the manual . Download \u00b6 Please download the latest ZIP archive steady-cli-3.2.2.zip from Releases and extract it into a newly created folder. This folder will contain the following items: ./app/ Put the application code (python files) into this folder. It will be searched recursively, thus, it is possible to just copy the entire installation directory of an application into the folder. ./steady-cli-3.2.2-jar-with-dependencies.jar An executable JAR, which is the actual command-line version of the Eclipse Steady client. This is what you will use later to execute Eclipse Steady scans. ./steady-custom.properties.sample This is a template for the configuration file required by Eclipse Steady. You will change it in order to specify an identifier for your application (see below). Setup \u00b6 Rename the file steady-custom.properties.sample to steady-custom.properties and edit it to specify <GROUP> , <ARTIFACT> and <VERSION> of the application to be analyzed. Those settings will be used to uniquely identify the application in the backend. For Python applications, feel free to use the same value for both <GROUP> and <ARTIFACT> . Set the option vulas.core.space.token so that it is assigned your own workspace token. Put the application code (python files) into the folder ./app/ . Specify the setting vulas.core.bom.python.pip such that it points to a pip binary (not only the path in which the binary is located, but the binary itself, e.g., /foor/bar/pip ). pip will be used to determine the dependencies of your Python application. You can either use the global pip or one installed in a virtual environment ( virtualenv , Anaconda, etc.). # Full path to PIP binary (e.g., global installation, virtual environment or Anaconda) #vulas.core.bom.python.pip = <PATH-TO-PIP-BINARY>/pip Additional notes: Java resources contained in folder ./app/ will also be added as application code or dependencies. For the above reason, make sure that the Eclipse Steady CLI is not contained in ./app/ or other folders specified by setting vulas.core.app.sourceDir , if any. Goal execution \u00b6 See here for a description of all analysis goals. app \u00b6 java -jar steady-cli-3.2.2-jar-with-dependencies.jar -goal app Connect to the apps Web frontend, then select your workspace and application. The table in tab Dependencies is populated. Dependencies with known vulnerabilities are shown in tab Vulnerabilities . Assess and mitigate Once app has been run, the assessment of findings can already start: Each finding shown on the Vulnerabilities tab corresponds to a dependency of an application on a component with a known security vulnerability. See here for more information on how to assess and mitigate findings. Other analysis goals can be used to collect further evidence concerning the reachability of vulnerable code. report \u00b6 java -jar steady-cli-3.2.2-jar-with-dependencies.jar -goal report Check the console to see where the HTML, JSON and XML reports have been written to. clean \u00b6 java -jar steady-cli-3.2.2-jar-with-dependencies.jar -goal clean All application-specific data in the Eclipse Steady backend are deleted. Run clean whenever the application changes If you already scanned your project in the past, you should run the clean goal prior to new analyses in order to delete the old analysis results in the backend. Otherwise, old analysis results will be shown together with new results. For example, if you updated a dependency from a vulnerable to a non-vulnerable version, both versions will be shown in the apps Web frontend. Useful links \u00b6 Automate with Jenkins Configure the client-side analysis Get help if you run into troubles Assess and mitigate reported vulnerabilities","title":"Scanning Python (CLI)"},{"location":"user/tutorials/python_cli/#scanning-python-apps-with-the-cli","text":"Using Eclipse Steady for Python applications not built with SetupTools","title":"Scanning Python apps with the CLI"},{"location":"user/tutorials/python_cli/#prerequisites","text":"JDK 7 or later pip is installed and \"knows\" all application dependencies (check with pip list ) URLs of the backend service and apps Web frontend Apps Web frontend: http://localhost:8033/apps Backend service: http://localhost:8033/backend/ The token of a Eclipse Steady workspace Workspace creation If you do not have a workspace yet, you can easily create one by going on the application frontend and clicking on the third button in the lower left corner: For a detailed description of workspaces and of the inputs you have to provide in the form that is displayed when you click that button, please see this section of the manual .","title":"Prerequisites"},{"location":"user/tutorials/python_cli/#download","text":"Please download the latest ZIP archive steady-cli-3.2.2.zip from Releases and extract it into a newly created folder. This folder will contain the following items: ./app/ Put the application code (python files) into this folder. It will be searched recursively, thus, it is possible to just copy the entire installation directory of an application into the folder. ./steady-cli-3.2.2-jar-with-dependencies.jar An executable JAR, which is the actual command-line version of the Eclipse Steady client. This is what you will use later to execute Eclipse Steady scans. ./steady-custom.properties.sample This is a template for the configuration file required by Eclipse Steady. You will change it in order to specify an identifier for your application (see below).","title":"Download"},{"location":"user/tutorials/python_cli/#setup","text":"Rename the file steady-custom.properties.sample to steady-custom.properties and edit it to specify <GROUP> , <ARTIFACT> and <VERSION> of the application to be analyzed. Those settings will be used to uniquely identify the application in the backend. For Python applications, feel free to use the same value for both <GROUP> and <ARTIFACT> . Set the option vulas.core.space.token so that it is assigned your own workspace token. Put the application code (python files) into the folder ./app/ . Specify the setting vulas.core.bom.python.pip such that it points to a pip binary (not only the path in which the binary is located, but the binary itself, e.g., /foor/bar/pip ). pip will be used to determine the dependencies of your Python application. You can either use the global pip or one installed in a virtual environment ( virtualenv , Anaconda, etc.). # Full path to PIP binary (e.g., global installation, virtual environment or Anaconda) #vulas.core.bom.python.pip = <PATH-TO-PIP-BINARY>/pip Additional notes: Java resources contained in folder ./app/ will also be added as application code or dependencies. For the above reason, make sure that the Eclipse Steady CLI is not contained in ./app/ or other folders specified by setting vulas.core.app.sourceDir , if any.","title":"Setup"},{"location":"user/tutorials/python_cli/#goal-execution","text":"See here for a description of all analysis goals.","title":"Goal execution"},{"location":"user/tutorials/python_cli/#app","text":"java -jar steady-cli-3.2.2-jar-with-dependencies.jar -goal app Connect to the apps Web frontend, then select your workspace and application. The table in tab Dependencies is populated. Dependencies with known vulnerabilities are shown in tab Vulnerabilities . Assess and mitigate Once app has been run, the assessment of findings can already start: Each finding shown on the Vulnerabilities tab corresponds to a dependency of an application on a component with a known security vulnerability. See here for more information on how to assess and mitigate findings. Other analysis goals can be used to collect further evidence concerning the reachability of vulnerable code.","title":"app"},{"location":"user/tutorials/python_cli/#report","text":"java -jar steady-cli-3.2.2-jar-with-dependencies.jar -goal report Check the console to see where the HTML, JSON and XML reports have been written to.","title":"report"},{"location":"user/tutorials/python_cli/#clean","text":"java -jar steady-cli-3.2.2-jar-with-dependencies.jar -goal clean All application-specific data in the Eclipse Steady backend are deleted. Run clean whenever the application changes If you already scanned your project in the past, you should run the clean goal prior to new analyses in order to delete the old analysis results in the backend. Otherwise, old analysis results will be shown together with new results. For example, if you updated a dependency from a vulnerable to a non-vulnerable version, both versions will be shown in the apps Web frontend.","title":"clean"},{"location":"user/tutorials/python_cli/#useful-links","text":"Automate with Jenkins Configure the client-side analysis Get help if you run into troubles Assess and mitigate reported vulnerabilities","title":"Useful links"},{"location":"user/tutorials/reports/","text":"Reports comprehension \u00b6 Coming soon This is being written, please come back later.","title":"Understanding reports"},{"location":"user/tutorials/reports/#reports-comprehension","text":"Coming soon This is being written, please come back later.","title":"Reports comprehension"},{"location":"user/tutorials/workspace_howto/","text":"Workspaces \u00b6 A workspace acts as a container to group the results of several application analyses. Prerequisites \u00b6 URL of the apps Web frontend: http://localhost:8033/apps Create workspace \u00b6 Proceed as follows to create a workspace. Note that by creating a workspace, you will also generate a token to be used when performing actual application scans. Connect to the apps Web frontend: http://localhost:8033/apps Click on the third button in the lower left corner: Enter the following workspace properties: Name : Must be provided. Note that the name is not unique, thus, there can be several workspaces having the same name. Description : Must be provided. Contact : Please provide the email address of a distribution list (DL). Export results : AGGREGATED: Findings are aggregated on workspace-level, one item for the entire workspace will be exported DETAILED: Findings are aggregated on application-level, one item for every application of the workspace will be exported OFF: No export of findings Public : A public workspace appears in the drop-down box of the apps Web frontend, a private one does not. Important: It will not be possible to retrieve the token of a private space at later points in time, thus, note it down when it is shown right after workspace creation. Once the fields have been filled, press the \"Save\" button. The system then returns with a pop-up containing the random token generated upon workspace creation. Do not forget to note down this token, it will be needed later on for each scan of your application(s). Use workspace \u00b6 To use a workspace, you need to pass the token as configuration parameter vulas.core.space.token . See here for more information on how-to configure the scans clients or continue with the scan tutorials .","title":"Workspace"},{"location":"user/tutorials/workspace_howto/#workspaces","text":"A workspace acts as a container to group the results of several application analyses.","title":"Workspaces"},{"location":"user/tutorials/workspace_howto/#prerequisites","text":"URL of the apps Web frontend: http://localhost:8033/apps","title":"Prerequisites"},{"location":"user/tutorials/workspace_howto/#create-workspace","text":"Proceed as follows to create a workspace. Note that by creating a workspace, you will also generate a token to be used when performing actual application scans. Connect to the apps Web frontend: http://localhost:8033/apps Click on the third button in the lower left corner: Enter the following workspace properties: Name : Must be provided. Note that the name is not unique, thus, there can be several workspaces having the same name. Description : Must be provided. Contact : Please provide the email address of a distribution list (DL). Export results : AGGREGATED: Findings are aggregated on workspace-level, one item for the entire workspace will be exported DETAILED: Findings are aggregated on application-level, one item for every application of the workspace will be exported OFF: No export of findings Public : A public workspace appears in the drop-down box of the apps Web frontend, a private one does not. Important: It will not be possible to retrieve the token of a private space at later points in time, thus, note it down when it is shown right after workspace creation. Once the fields have been filled, press the \"Save\" button. The system then returns with a pop-up containing the random token generated upon workspace creation. Do not forget to note down this token, it will be needed later on for each scan of your application(s).","title":"Create workspace"},{"location":"user/tutorials/workspace_howto/#use-workspace","text":"To use a workspace, you need to pass the token as configuration parameter vulas.core.space.token . See here for more information on how-to configure the scans clients or continue with the scan tutorials .","title":"Use workspace"},{"location":"user/tutorials/workspace_howto_advanced/","text":"Workspaces \u00b6 If an application has been already released to customers and, at the same time, new releases are under development, you may want to setup workspaces as follows: One workspace for the development branch, to prevent that vulnerable dependencies are introduced at development time One workspace for every release branch, to monitor whether there are new vulnerabilities for dependencies of production releases","title":"Workspaces (advanced)"},{"location":"user/tutorials/workspace_howto_advanced/#workspaces","text":"If an application has been already released to customers and, at the same time, new releases are under development, you may want to setup workspaces as follows: One workspace for the development branch, to prevent that vulnerable dependencies are introduced at development time One workspace for every release branch, to monitor whether there are new vulnerabilities for dependencies of production releases","title":"Workspaces"},{"location":"user/tutorials/partials/create_workspace/","text":"Workspace creation If you do not have a workspace yet, you can easily create one by going on the application frontend and clicking on the third button in the lower left corner: For a detailed description of workspaces and of the inputs you have to provide in the form that is displayed when you click that button, please see this section of the manual .","title":"Create workspace"},{"location":"user/tutorials/partials/vulas_profile/","text":"<profile> <id> steady </id> <activation> <property> <name> steady </name> </property> </activation> <properties> <vulas.version> 3.2.2 </vulas.version> <vulas.shared.backend.serviceUrl> http://localhost:8033/backend/ </vulas.shared.backend.serviceUrl> <vulas.core.space.token> WORKSPACE_TOKEN </vulas.core.space.token> <vulas.core.appContext.group> ${project.groupId} </vulas.core.appContext.group> <vulas.core.appContext.artifact> ${project.artifactId} </vulas.core.appContext.artifact> <vulas.core.appContext.version> ${project.version} </vulas.core.appContext.version> </properties> <build> <plugins> <plugin> <groupId> org.eclipse.steady </groupId> <artifactId> plugin-maven </artifactId> <version> ${vulas.version} </version> <configuration> <layeredConfiguration> <vulas.shared.backend.serviceUrl> ${vulas.shared.backend.serviceUrl} </vulas.shared.backend.serviceUrl> <vulas.core.space.token> ${vulas.core.space.token} </vulas.core.space.token> <vulas.core.appContext.group> ${vulas.core.appContext.group} </vulas.core.appContext.group> <vulas.core.appContext.artifact> ${vulas.core.appContext.artifact} </vulas.core.appContext.artifact> <vulas.core.appContext.version> ${vulas.core.appContext.version} </vulas.core.appContext.version> <vulas.shared.tmpDir> ${project.build.directory}/vulas/tmp </vulas.shared.tmpDir> <vulas.core.uploadDir> ${project.build.directory}/vulas/upload </vulas.core.uploadDir> <vulas.core.app.sourceDir> ${project.build.directory}/classes,${project.basedir}/src/main/java,${project.basedir}/src/main/python </vulas.core.app.sourceDir> <!-- steady:instr : Instruments JAR/WAR files found in source dir, and writes to target dir. Files in include dir are put into /WEB-INF/lib of output WARs. Files in lib dir are part of the class path when instrumenting. --> <vulas.core.instr.sourceDir> ${project.build.directory} </vulas.core.instr.sourceDir> <vulas.core.instr.targetDir> ${project.build.directory}/vulas/target </vulas.core.instr.targetDir> <vulas.core.instr.includeDir> ${project.build.directory}/vulas/include </vulas.core.instr.includeDir> <vulas.core.instr.libDir> ${project.build.directory}/vulas/lib </vulas.core.instr.libDir> <vulas.core.instr.writeCode> false </vulas.core.instr.writeCode> <vulas.core.instr.instrumentorsChoosen> org.eclipse.steady.java.monitor.trace.SingleTraceInstrumentor </vulas.core.instr.instrumentorsChoosen> <vulas.core.instr.searchRecursive> false </vulas.core.instr.searchRecursive> <vulas.core.monitor.periodicUpload.enabled> false </vulas.core.monitor.periodicUpload.enabled> <vulas.core.instr.maxStacktraces> 10 </vulas.core.instr.maxStacktraces> <!-- steady:a2c/t2c : Performs static call graph analysis --> <vulas.reach.wala.callgraph.reflection> NO_FLOW_TO_CASTS_NO_METHOD_INVOKE </vulas.reach.wala.callgraph.reflection> <vulas.reach.timeout> 60 </vulas.reach.timeout> <!-- steady:report --> <vulas.report.reportDir> ${project.build.directory}/vulas/report </vulas.report.reportDir> </layeredConfiguration> </configuration> </plugin> </plugins> </build> </profile>","title":"Vulas profile"},{"location":"vuln_db/","text":"Vulnerability Data \u00b6 How to import vulnerability data in the Eclipse Steady backend \u00b6 TL;DR: There is nothing to do, it's all automated :-) When you deploy Eclipse Steady using Docker , not only the vulnerability data from project KB is automatically imported , but it is also periodically updated so that any new vulnerabilities are imported automatically into your Eclipse Steady backend. If you want to customize the mechanism whereby vulnerabilities are imported or if you just want to learn more about it, please refer to the dedicated technical documentation . Why code-level vulnerability data are needed \u00b6 The code-level vulnerability analysis performed by Eclipse Steady is based on the concept of change list , a set of constructs (e.g., methods) that are changed to fix a given security vulnerability. The vulnerability detection capabilities of Eclipse Steady rely on this concept: an artifact (e.g. a library) is considered to be affected by a vulnerability if it contains the constructs that were changed to fix a vulnerability. A positive consequence of this approach is that, once the change list for a vulnerability has been created and added to the database, one can immediately determine if any of the applications scanned in the past are potentially impacted by this new vulnerability, no need to re-run the analysis for each application! Hence, if one considers Eclipse Steady as a powerful machine, then vulnerability data are the fuel , since Eclipse Steady can only detect and assess vulnerabilities if they are present in its vulnerability database. The fix commits for hundreds of vulnerabilities that affect Java and Python open source projects are mantained in a dedicated repository ( project \"KB\" ) that focuses on fostering a community-based approach to gathering and maintaining a comprehensive knowledge base. Eclipse Steady automatically imports data from project KB, so in typical scenarios you do not need to do anything for it to work. Contributing to the vulnerability database \u00b6 In this page you will find information about how to contribute vulnerability information to project KB. How to list the vulnerabilities that are currently available in your instance of Eclipse Steady \u00b6 Assuming that Eclipse Steady is deployed on http://localhost:8033 , you can list of the vulnerabilities saved in the database of your installation via this endpoint: http://localhost:8033/backend/bugs Detailed information for a given vulnerability can be obtained using the following link http://localhost:8033/backend/bugs/<foo> (where <vuln_id> has to be replaced by a real vulnerability identifier).","title":"Vulnerability data"},{"location":"vuln_db/#vulnerability-data","text":"","title":"Vulnerability Data"},{"location":"vuln_db/#how-to-import-vulnerability-data-in-the-eclipse-steady-backend","text":"TL;DR: There is nothing to do, it's all automated :-) When you deploy Eclipse Steady using Docker , not only the vulnerability data from project KB is automatically imported , but it is also periodically updated so that any new vulnerabilities are imported automatically into your Eclipse Steady backend. If you want to customize the mechanism whereby vulnerabilities are imported or if you just want to learn more about it, please refer to the dedicated technical documentation .","title":"How to import vulnerability data in the Eclipse Steady backend"},{"location":"vuln_db/#why-code-level-vulnerability-data-are-needed","text":"The code-level vulnerability analysis performed by Eclipse Steady is based on the concept of change list , a set of constructs (e.g., methods) that are changed to fix a given security vulnerability. The vulnerability detection capabilities of Eclipse Steady rely on this concept: an artifact (e.g. a library) is considered to be affected by a vulnerability if it contains the constructs that were changed to fix a vulnerability. A positive consequence of this approach is that, once the change list for a vulnerability has been created and added to the database, one can immediately determine if any of the applications scanned in the past are potentially impacted by this new vulnerability, no need to re-run the analysis for each application! Hence, if one considers Eclipse Steady as a powerful machine, then vulnerability data are the fuel , since Eclipse Steady can only detect and assess vulnerabilities if they are present in its vulnerability database. The fix commits for hundreds of vulnerabilities that affect Java and Python open source projects are mantained in a dedicated repository ( project \"KB\" ) that focuses on fostering a community-based approach to gathering and maintaining a comprehensive knowledge base. Eclipse Steady automatically imports data from project KB, so in typical scenarios you do not need to do anything for it to work.","title":"Why code-level vulnerability data are needed"},{"location":"vuln_db/#contributing-to-the-vulnerability-database","text":"In this page you will find information about how to contribute vulnerability information to project KB.","title":"Contributing to the vulnerability database"},{"location":"vuln_db/#how-to-list-the-vulnerabilities-that-are-currently-available-in-your-instance-of-eclipse-steady","text":"Assuming that Eclipse Steady is deployed on http://localhost:8033 , you can list of the vulnerabilities saved in the database of your installation via this endpoint: http://localhost:8033/backend/bugs Detailed information for a given vulnerability can be obtained using the following link http://localhost:8033/backend/bugs/<foo> (where <vuln_id> has to be replaced by a real vulnerability identifier).","title":"How to list the vulnerabilities that are currently available in your instance of Eclipse Steady"}]}